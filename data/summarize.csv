input;output
"Pengenalan Android Apa itu Android Android adalah sistem operasi yang dikeluarkan oleh Google. Android dibuat khusus untuk smartphone dan tablet. Berbagai macam produsen telah menggunakan Android sebagai sistem operasi untuk peranti ( device ) yang mereka produksi. Android juga mempunyai  store  dengan lebih dari 2.5 miliar pengguna aktif per bulannya, per Mei 2019  [1] . Mengapa Android Kenapa menggunakan Android? Android memanjakan penggunanya dengan fitur yang sangat canggih dan tampilan yang bagus. Sistem Android dapat digunakan sebagai alat multimedia seperti pemutar musik dan video. Ia juga memiliki perangkat keras seperti  accelerometer ,  gyroscope  dan sensor lainnya. Di samping itu ada beberapa hal yang membuat Android menjadi sistem operasi yang memang layak digunakan oleh pengguna atau dikembangkan para developer, seperti yang akan diuraikan berikut ini. Sistem Operasi Smartphone Terpopuler Pada tahun 2013, Android menjadi  operation system  (OS) terlaris pada tablet dan smartphone. Kini  market share  Android sedikitnya 70 % dari total penjualan smartphone di tingkat global (statista.com)  [2] . Tercatat pada tahun 2016 Android  store  memiliki lebih dari 2.8 juta aplikasi  [3] . Android menarik bagi perusahaan teknologi yang membutuhkan barang siap jadi, biaya rendah dan kustomisasi OS untuk perangkat teknologi tinggi mereka. Hal ini menjadi daya tarik bagi banyak perusahaan, sehingga mereka memilih Android. Source code  dari Android bersifat  open source . Ini adalah hal menarik bagi komunitas developer, karena lisensi  open source  sangat mendukung untuk mengembangkan produknya dengan aman. Store Aplikasi Android bisa didistribusikan menggunakan  web ,  copy APK , dan  store . Android  s tore  , yaitu Google Play, merupakan cara termudah bagi para developer untuk mendistribusikan aplikasinya ke pasar dengan miliaran pengguna. Google play merupakan  store  resmi Android yang dikelola oleh Google. Pengguna bisa mencari dan mengunduh aplikasi yang dikembangkan dengan menggunakan Android Software Development Kit. Google Play tak hanya menawarkan aplikasi. Ada beragam konten lainnya yang dapat dinikmati pengguna, misalnya media digital, musik, buku, majalah, film dan program televisi. Bagaimana para developer memonetisasi aplikasi yang ada di dalam Google Play? Strategi monetisasi aplikasi yang ditawarkan Google Play ada bermacam-macam. Dimulai dari  app  berbayar ( paid distribution ), pembelian dalam aplikasi ( in-app purchase ), langganan ( subscriptions ), dan iklan ( ads ). Tentunya developer harus mengikuti aturan yang ada untuk memastikan bahwa pengguna mendapatkan pengalaman ( user experience)  terbaik. Development Kit untuk Developer Android Software Development Kit (SDK) merupakan  kit  yang bisa digunakan oleh para developer untuk mengembangkan aplikasi berbasis Android. Di dalamnya, terdapat beberapa  tools  seperti  debugger ,  software libraries ,  emulator , dokumentasi,  sample code  dan tutorial. Bahasa pemrograman yang sering digunakan untuk mengembangkan aplikasi Android adalah Java. Namun ada beberapa bahasa lainnya yang dapat digunakan, seperti C++ dan Go. Pada IO 2017 Google juga menetapkan Kotlin sebagai tambahan bahasa resmi  [4] . Berbicara tentang pemrograman tentunya tak lepas dari  Integrated Development Environment  (IDE). Pada 2014 Google mengeluarkan IDE yang bernama Android Studio yang berbasiskan Intellij IDEA. Dengan menggunakan Android Studio, para developer dapat membuat aplikasi dari nol hingga dipublikasikan ke dalam  store . Android Studio juga mempunyai beberapa fitur  built-in  yang sangat membantu para developer untuk memaksimalkan proses pembuatan aplikasi. Fitur-fitur ini misalnya project template, layout editor, debugging, testing, hingga membuat berkas APK. Sejarah Perkembangan Android Berikut adalah rangkaian sejarah perkembangan Android yang resmi diluncurkan oleh Google dari waktu ke waktu. Platform Version Version Code Release date API level Feature Highlight Icon 13 TIRAMISU August 15, 2022 33 Themed app icons Per-app language preferences Photo picker Notification permissions 12 S October 4, 2021 31-32 Material You Widget improvement Approximate location permissions Privacy Dashboard 11 R September 8, 2020 30 Chat Bubbles Screen Recorder Device Control Predictive Tool One-time permission  10 Q September 3, 2019 29 Live Caption Smart Reply Sound Amplifier Dark Theme Privacy & Security Digital Wellbeing 9 P August 6, 2018 28 Adaptive Battery Adaptive Brightness 8.0-8.1 O October 25, 2017 26 - 27 Picture-in-Picture 7.1 - 7.1.2 N August 22, 2016 24 - 25 Multi-window GIF Keyboard 6.0 - 6.0.1 M October 5, 2015 23 Now On Tap Permissions Battery (Doze & App Standby) 5.1 - 5.1.1 LOLLIPOP November 12, 2014 21 - 22 Material Design Multiscreen Notifications 4.4 - 4.4.4 KITKAT October 31, 2013 19 - 20 Voice : Ok Google Immersive Design Smart Dialer 4.1 - 4.3.1 JELLY_BEAN July 9, 2012 16-18 Google Now Actionable Notifications Account Switching 4.0 - 4.6 ICE_CREAM_SANDWICH October 19, 2011 14-15 Custom Home Screen Data Usage Control Android Beam 3.0 - 3.2.6 HONEYCOMB February 22, 2011 11 - 13 Tablet-Friendly Design System Bar Quick Settings 2.3 - 2.3.7 GINGERBREAD February 9, 2011 9 - 10 Gaming APIs NFC Battery Management 2.2 - 2.23 FROYO May 20, 2010 8 Voice Action Portable Hotspot Dalvik JIT 2.0 - 2.1 ECLAIR October 26, 2009 5-7 Google Maps Navigation Home Screen Customization Speech-to-Text 1.6 DONUT September 15, 2009 4 Quick Search Box Screen Size Diversity Android Market 1.5 CUPCAKE April 27, 2009 3 - Saat versi baru Android dirilis, developer hendaknya terus mengikuti  best-practice  terbaru untuk memastikan aplikasi yang dibuat tetap memberikan pengalaman yang terbaik di sebanyak mungkin device. Untuk mencari tahu tentang versi terbaru, Anda dapat melihatnya pada tautan berikut. What is API Level? ART dan DVM Dari tabel sejarah perkembangan di atas dapat kita lihat ada kolom DVM / ART. Kolom ini menunjukkan eksekusi kompilasi ketika menjalankan aplikasi Android. Pada API KitKat dan sebelumnya Android menggunakan DVM (Dalvik Virtual Machine).  DVM  menerapkan pendekatan JIT ( Just-In-Time ), di mana kompilasi dijalankan ketika ada permintaan untuk menjalankan aplikasi. Sedangkan  ART  ( Android Runtime ) menerapkan pendekatan berbeda yaitu AOT ( Ahead-Of-Time ). AOT melakukan kompilasi pada saat proses instalasi aplikasi. Dari versi Lollipop hingga sekarang, Android sepenuhnya mengadopsi ART. Mengapa demikian? DVM menggunakan JIT yang berarti kompilasi dilakukan setiap kali aplikasi dijalankan. Hal ini sangat mempengaruhi kecepatan respon aplikasi. Setiap kali kita menyentuh ikon aplikasi maka kompilasi akan dilakukan. Tentu proses ini menghabiskan CPU dan berimbas pada relatif lebih borosnya penggunaan baterai. Beda dengan DVM, ART melakukan proses kompilasi pada saat proses instalasi. Jadi setiap kali aplikasi dijalankan, sudah tidak ada lagi proses kompilasi. Hal ini meningkatkan performa dalam menjalankan aplikasi. Selain itu karena penggunaan sumber daya CPU bisa dikurangi, pemakaian baterai jadi lebih hemat. Akan tetapi ART membutuhkan  space  (ukuran berkas) yang lebih besar jika dibandingkan dengan DVM. Jika ingin mendalami proses  run-time  yang ada di Android, silakan klik tautan berikut ini:  Android Runtime (ART) and Dalvik  Beberapa bacaan dasar yang dapat menambah wawasan Anda, antara lain:  Apa Itu Android? Android Studio Android Studio adalah Lingkungan Pengembangan Terpadu -  Integrated Development Environment  (IDE) untuk pengembangan aplikasi Android, berdasarkan  IntelliJ IDEA  . Selain merupakan editor kode IntelliJ dan alat pengembang yang berdaya guna, Android Studio menawarkan fitur lebih demi meningkatkan produktifitas Anda saat membuat aplikasi Android, misalnya: Template : template memulai project maupun Activity tanpa harus membuatnya dari nol. Intelligent code editor : code completion yang memudahkan untuk menulis kode dengan cepat tanpa harus menuliskan secara lengkap. Selain itu, juga ada warning apabila terdapat kesalahan penulisan kode. Design tool : digunakan untuk mendesain aplikasi beserta melihat preview secara langsung sebelum dijalankan. Flexible build system : Android Studio menggunakan Gradle yang fleksibel untuk menciptakan build variant yang berbeda untuk berbagai device. Anda juga dapat menganalisa prosesnya secara mendetail. Emulator : menjalankan aplikasi tanpa harus menggunakan device Android. Debugging : memudahkan untuk mencari tahu masalah. Testing : menjalankan pengujian untuk memastikan semua kode aman sebelum rilis. Publish : membuat berkas AAB/APK dan menganalisanya guna dibagikan dan di-publish ke PlayStore. Dilengkapi dengan Instant Run untuk melihat perubahan tanpa harus build project dari awal. Integrasi : Terhubung dengan berbagai layanan yang memudahkan untuk mengembangkan aplikasi, seperti Github, Firebase, dan Google Cloud. Persyaratan Sistem Windows Mac Microsoft® Windows® 8/10 (64-bit) x86_64 CPU architecture; Intel Core 2nd Gen atau lebih, atau AMD CPU dengan support  Windows Hypervisor RAM 8 GB atau lebih Ruang disk minimum yang tersedia 8 GB (IDE + Android SDK + Android Emulator) Resolusi layar minimum 1280 x 800 MacOS® 10.14 (Mojave) atau lebih baru ARM-based chips, atau Intel Core 2nd Gen atau lebih dengan support  Hypervisor.Framework RAM 8 GB atau lebih Ruang disk minimum yang tersedia 8 GB (IDE + Android SDK + Android Emulator) Resolusi layar minimum 1280 x 800 Linux Chrome OS Linux 64-bit yang support GNOME, KDE, atau Unity DE, GNU C Library (glibc) 2.31 atau lebih x86_64 CPU architecture; Intel Core atau lebih 2nd Gen, atau AMD processor dengan support AMD Virtualization (AMD-V) dan SSSE3 RAM 8 GB atau lebih Ruang disk minimum yang tersedia 8 GB (IDE + Android SDK + Android Emulator) Resolusi layar minimum 1280 x 800 Disarankan 8 GB RAM atau lebih Ruang disk minimum yang tersedia 4 GB Resolusi layar minimum 1280 x 800 Disarankan Intel i5 atau lebih (U series atau lebih)  Perangkat yang direkomendasikan bisa dilihat di  chromeos.dev .";Android adalah sistem operasi yang dikembangkan oleh Google untuk perangkat smartphone dan tablet, dengan lebih dari 2,5 miliar pengguna aktif setiap bulan. Populer karena fitur canggih dan tampilan menarik, Android mendukung perangkat keras seperti accelerometer dan gyroscope. Sebagai sistem operasi terlaris dengan lebih dari 70% market share, Android menarik bagi perusahaan karena biaya rendah dan kustomisasi OS yang fleksibel. Pengembang dapat memanfaatkan Android Software Development Kit (SDK) untuk membuat aplikasi menggunakan bahasa seperti Java atau Kotlin, dengan Android Studio sebagai Integrated Development Environment (IDE) resmi. Android terus berkembang dengan pembaruan versi yang meningkatkan performa dan fitur, serta mengadopsi Android Runtime (ART) untuk efisiensi daya dan kinerja lebih baik.
"Persiapan Tools JDK Salah satu Bahasa yang bisa digunakan untuk development Android adalah Java. Selain Java ada beberapa Bahasa lain yang bisa digunakan seperti C/C++, Go, dan Kotlin (per Mei 2017). Pada akademi ini kita hanya akan fokus menggunakan  Kotlin  dan  Java  sebagai bahasa pemrograman. Oleh karena itu mari instal dulu software yang harus kita gunakan untuk coding (menuliskan baris code). Siapkan senjata Anda sebelum berperang. Instal Java Development Kit yang bisa kita dapatkan pada tautan berikut: https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html Biasanya muncul pertanyaan, ""Apakah JRE cukup?"" Tidak, JRE adalah Java Runtime Environment yang berfungsi sebagai Virtual Machine untuk menjalankan program Java. Sedangkan JDK merupakan Java SE Development Kit, di mana JRE juga terdapat di dalamnya. Dan yang lebih penting adalah di dalamnya terdapat  compiler  dan  tools  untuk membuat dan  compile  program. Sederhananya JRE untuk menjalankan program, sedangkan JDK untuk membuat program.  Catatan : Saat ini ketika menginstall Android Studio sudah terdapat JDK yang bawaan (OpenJDK) yang bisa digunakan. Sehingga langkah di bawah ini bersifat opsional jika Anda mengalami kendala JDK. Mari kita mulai dengan proses instalasi dari JDK dari Oracle. Langsung saja buka tautan di atas menggunakan browser Anda. Pilihlah  link download  yang sesuai dengan OS yang Anda pakai. Jangan lupa untuk mencentang  Accept License Agreement  dan klik tombol  Download . Anda akan diminta untuk login terlebih dahulu, silakan mendaftar dulu jika Anda belum memiliki akun. Setelah proses mengunduh selesai, langsung  install  ke gawai Anda dan ikuti petunjuknya sampai selesai. Android Studio Pada akademi kali ini kita akan menggunakan Android Studio sebagai IDE ( Integrated Development Environment ). Android Studio dirilis 16 Mei 2013 saat Google IO berlangsung  [5] . Android Studio berbasiskan JetBrains Intellij IDEA, dan dikhususkan untuk pengembangan  software  berbasis Android. Mari langsung saja kita mulai instalasi Android Studio. Buka web browser dan masuk ke halaman  https://developer.android.com/studio . Tautan tersebut akan otomatis mengarahkan ke versi software yang sesuai dengan OS Anda. Anda juga dapat melihat fitur fitur baru dan fitur utama pada halaman tersebut. Klik tombol  Download Android Studio .  Baca license agreement dan beri tanda centang pada  I have read and agree with the above terms and conditions  yang ada di bagian bawah. Klik  Download Android Studio ... for ...  . Pilih lokasi penyimpanan dan tunggu proses mengunduh sampai selesai. Kemudian instal Android Studio ke komputer Anda dan ikuti petunjuknya sampai selesai. Untuk melihat proses instalasi secara lebih detail untuk masing-masing OS, Anda dapat melihatnya pada tautan berikut. https://developer.android.com/studio/install Saat proses instalasi, Android Studio juga akan menginstal beberapa komponen lain supaya Android Studio dapat berjalan lancar. Contohnya adalah ADB dan SDK. Android SDK adalah sekumpulan tool yang digunakan untuk mengembangkan aplikasi Android. Untuk itu, silakan izinkan atau tekan ""Yes"" jika ada pop up atau alert yang muncul dan pastikan PC Anda sudah terhubung ke internet saat proses instalasi tersebut. Setelah selesai melakukan instalasi Android Studio, akan muncul seperti gambar di bawah ini. Gambar di atas berarti aplikasi Android Studio sudah bisa digunakan. Anda juga dapat melihat semua versi dari Android Studio yang dapat Anda unduh pada tautan ini: https://developer.android.com/studio/archive.html Catatan: Untuk migrasi dari Android Studio versi 2.x ke versi 3.4 ke atas, terkadang perlu menyesuaikan beberapa kode terutama pada berkas  gradle -nya. Silakan kunjungi tautan  ini  untuk keterangan lebih lanjut.";Persiapkan tools untuk pengembangan Android dengan menginstal Java Development Kit (JDK) yang diperlukan untuk membuat program Java, termasuk aplikasi Android. JDK mencakup Java Runtime Environment (JRE), namun lebih lengkap karena termasuk compiler dan tools untuk mengembangkan program. Meskipun Android Studio sudah dilengkapi dengan OpenJDK, Anda bisa menginstal JDK secara terpisah jika diperlukan. Setelah itu, instal Android Studio, IDE yang digunakan untuk mengembangkan aplikasi Android, yang juga akan menginstal Android SDK dan ADB. Ikuti petunjuk instalasi hingga selesai, dan pastikan sistem Anda terhubung ke internet selama proses ini.
"Pengenalan Project pada Android Studio Supaya lancar ketika menggunakan Android Studio, sebaiknya Anda perlu mengetahui strukturnya terlebih dahulu. Jika terbiasa menggunakan produk IntelliJ IDEA lainnya, akan mudah bagi Anda untuk menavigasi tata letak dan struktur Android Studio. Hanya saja perbedaannya terletak pada komponen tambahan pendukung yang membantu pengembangan dan pembuatan aplikasi Android.  Yuk , kita mulai mengenal Android Studio lebih jauh. Project Android Pertama Kali pertama menjalankan Android Studio, Anda akan melihat tampilan seperti berikut ini. Untuk memulai proyek baru, pilihlah  “New project” . Jika sudah membuka project lain, klik  File → New → New Project  untuk membuat project baru. Project Wizard Selanjutnya, mari kita membuat sebuah aplikasi pertama, yaitu  Hello World.  Ikuti langkah-langkahnya di bawah ini. Setelah memilih  New  project , Anda diminta untuk memilih tema template awal project. Adanya template mempermudah Anda supaya tidak membuat project dari nol, sehingga proses awal menjadi lebih cepat dan sesuai dengan best-practice tanpa error (misal tidak mendaftarkan Activity ke Manifest). Saat ini Android Studio sudah menyediakan berbagai macam  template project  dari yang paling sederhana hingga yang paling kompleks seperti: Nama Template Activity Fungsi No Activity Project murni tanpa ada Activity yang ditambahkan Empty Activity Activity dengan menggunakan Jetpack Compose dalam bentuk yang paling sederhana (tanpa menu) Empty Views Activity Activity dengan menggunakan XML/View System dalam bentuk yang paling sederhana (tanpa menu) Basic Views Activity Activity menggunakan XML/View System dengan  template  komponen  material design  seperti FloatingActionButton dan menu Toolbar Bottom Navigation Views Activity Activity menggunakan XML/View System dengan tampilan  bottom navigation menu  di bagian bawah Navigation Drawer Activity Activity dengan tampilan  side bar menu  yang bisa di- swipe Selain itu, Anda juga bisa memilih  target device  mana yang akan dibuat seperti   Wear OS ,  Android  TV , atau  Android Auto . Pada kelas ini, kita akan sering menggunakan  Empty Views Activity  sebagai standar. Pada kelas ini, kita akan sering menggunakan XML/View System sebagai standar. Untuk itu, pilihlah template  Empty Views Activity  dan klik  Next . Kemudian Anda akan diarahkan ke dalam dialog untuk memberi nama dari aplikasi, lokasi proyek dan   nama package   seperti berikut . Berikut adalah fungsi dari masing-masing kolom di atas. Name : nama dari aplikasi yang akan dibuat. Package name : digunakan sebagai identifikasi unik dari aplikasi ketika sudah di- publish  di PlayStore. Antara satu aplikasi dengan aplikasi lainnya harus berbeda. Biasanya penamaan package menggunakan format domain website, tetapi urutannya dibalik. Save location : mengganti direktori tempat kita menyimpan  project . Language : memilih bahasa yang digunakan untuk mengembangkan aplikasi, apakah menggunakan Kotlin atau Java. Minimum SDK : menentukan versi minimum Android yang dapat menjalankan project ini. Anda dapat menekan  Help me choose  untuk melihat distribusi pemakai Android pada setiap versi sehingga bisa menentukan minimum SDK yang cocok. Klik  Finish  dan tunggu proses pembuatan project selesai. Antarmuka Android Studio Setelah membuat proyek pertama di Project Wizard, Anda akan dihadapkan pada tampilan penuh Android Studio berbasis IntelliJ IDEA seperti di bawah ini. Mungkin tampilan tersebut akan berbeda dengan yang ada di layar Anda karena perbedaan konfigurasi dan versi Android Studio. Untuk meningkatkan produktivitas, mari kita bahas lebih jauh tentang antarmuka ( interface ) yang ada di Android Studio ini. Toolbar Merupakan  t ool  yang sering digunakan dalam  development,  mulai dari  copy/paste, build,  menjalankan aplikasi, hingga menjalankan emulator. Navigation Bar Membantu untuk melihat struktur dari kedalaman ( depth ) dan posisi proyek yang saat ini sedang dibuka.   Project Explorer dan Editor Merupakan bagian utama dari IDE Android Studio karena di sanalah tempat kita menulis kode nantinya. Pada tampilan di atas, sebelah kiri adalah struktur proyek dan sebelah kanan adalah editor. Bagian ini akan dibahas lebih detail di poin selanjutnya. Tool Window Bar Tools menu yang mengelilingi editor ini (baik di kiri, kanan, maupun bawah) merupakan tool   yang dapat diatur lebarnya dan ditampilkan secara terpisah. Status Bar Terletak di bagian paling bawah dalam Android Studio, ia berfungsi untuk menampilkan status proyek dan pesan peringatan ( warning message ) bila ada. Struktur Project Struktur Project adalah bagian yang menunjukkan struktur berkas-berkas yang dibutuhkan untuk mengembangkan aplikasi. Secara  default , Android Studio akan menampilkan berkas proyek Anda dalam tampilan  Android , seperti yang ditampilkan dalam gambar berikut: Pada tampilan struktur  Android , Android Studio akan menampilkan struktur yang lebih ringkas dan cepat sesuai dengan kebutuhan pengembangan Android. Bila ingin melihat struktur proyek dalam bentuk selain standar Android, kita dapat mengubahnya dengan tombol  dropdown  yang terdapat di atas  project structure . Pada bagian ini kita dapat mengganti tampilan  project structure  sesuai kebutuhan. Misalnya jika ingin melihat struktur sesuai seperti yang ada di Explorer (folder aslinya), Anda bisa menggunakan jenis tampilan  Project . Nah, sekarang mari kita bahas lebih detail tentang projek yang baru saja kita buat. Berikut adalah isi dari masing-masing folder yang ada pada struktur project tersebut. Android Manifest AndroidManifest adalah salah satu berkas yang harus ada di dalam sebuah proyek Android. Manifest memberikan beragam informasi penting kepada sistem Android. Sistem perlu mengetahui apa saja komponen yang akan digunakan oleh aplikasi sebelum dijalankan. Beberapa komponen yang ada di dalam Android Manifest adalah sebagai berikut: Komponen Aplikasi Berfungsi untuk mendeskripsikan komponen dasar aplikasi Android, mulai dari  activity ,  services ,  broadcast receiver , dan  content provider . <application     android:allowBackup=""true""     android:icon=""@mipmap/ic_launcher""     android:label=""@string/app_name""     android:roundIcon=""@mipmap/ic_launcher_round""     android:supportsRtl=""true""     android:theme=""@style/AppTheme"">      <activity          android:name="".MainActivity""         android:exported=""true"">         <intent-filter>             <action android:name=""android.intent.action.MAIN"" />             <category android:name=""android.intent.category.LAUNCHER"" />         </intent-filter>     </activity>      <service         android:name="".MyIntentService""         android:exported=""false""/>      <receiver         android:name="".MyReceiver""         android:enabled=""true""         android:exported=""true""/>      <provider         android:name="".MyProvider""         android:authorities=""com.dicoding.picodiploma.myapplication""         android:enabled=""true""         android:exported=""true"">     </provider> </application> Jika Anda belum memahami fungsi dari masing-masing komponen tersebut, itu tidak masalah. Kita akan mempelajarinya satu per satu seiring dengan berjalannya waktu. Yang terpenting adalah Anda memahami bahwa semua komponen aplikasi harus didaftarkan di AndroidManifest di antara tag  <application> . Di dalam sini, Anda juga dapat menentukan Activity atau halaman apa yang ingin ditampilkan pertama kali ketika aplikasi dibuka dengan menambahkan kategori  LAUNCHER  pada  <intent-filter> . Permission Mendeklarasikan  permission  apa saja yang harus dimiliki oleh aplikasi untuk akses ke dalam komponen API seperti internet,  external  storage , kontak, lokasi, dan lain sebagainya. Sebagai contoh, ini adalah kode untuk  permission  Internet. <uses-permission android:name=""android.permission.INTERNET""/> Kode ini biasanya diletakkan di atas tag  <application>  dan masih di dalam tag  <manifest> Java Merupakan salah satu folder yang sering dipakai, berisi berkas  source code  kita yang ditulis dalam bahasa Kotlin/Java, termasuk juga kode Unit Test dan androidTest (Instrumentation Test). Catatan: Penamaan folder ""java"" bisa juga diganti sesuai dengan bahasa yang dipakai, misal ""kotlin."" Res / Resource   Mengatur  resource  di dalamnya, yang mana bukan berupa kode, melainkan  layout  aplikasi, sumber gambar, ikon, hingga  style . Di dalam folder  res  ini juga terdapat sejumlah folder yang sudah diatur dan dikategorikan sesuai kebutuhan, seperti: Drawable Untuk menyimpan berkas gambar maupun ikon. Layout Salah satu folder yang sering dipakai untuk berkas desain aplikasi. Mipmap Untuk menyimpan logo dalam berbagai dimensi. Values Berisi berbagai macam sumber data, seperti  colors.xml  untuk warna,  strings.xml  untuk teks,  dimens.xml  untuk ukuran, dan  themes.xml  untuk membuat theme dan  style . Selain itu, juga ada jenis folder resource yang bisa Anda tambahkan seperti yang ada pada tautan berikut. App resources overview Gradle Gradle merupakan  open source build automation system .  Automation system  berguna untuk mengotomatisasi proses pembuatan dari kode program menjadi sebuah aplikasi (APK) yang bisa dijalankan.  build.gradle (Project: MyApplication) Merupakan  software build  tingkat teratas yang meliputi keseluruhan dari proyek dari sebuah aplikasi. Di dalamnya berisi konfigurasi library Android dan Kotlin untuk semua module. build.gradle (Module: app) Merupakan  software build  yang ada pada setiap modul di dalam proyek sebuah aplikasi. Beberapa konfigurasi yang diedit di antaranya adalah android settings, defaultConfig dan productFlavors, buildTypes, dan dependencies.  plugins {     id 'com.android.application'     id 'org.jetbrains.kotlin.android' }  android {      namespace  'com.dicoding.picodiploma.myapplication'      compileSdk  ...      defaultConfig {          applicationId  ""com.dicoding.picodiploma.myapplication""          minSdk  ...          targetSdk  ...          versionCode  1 //incremental         versionName ""1.0""          testInstrumentationRunner ""androidx.test.runner.AndroidJUnitRunner""     }       buildTypes  {         release {             minifyEnabled false             proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'         }     }     compileOptions {         sourceCompatibility JavaVersion.VERSION_1_8         targetCompatibility JavaVersion.VERSION_1_8     } }   dependencies  {     implementation ...     testImplementation ...     androidTestImplementation ... } Berikut adalah beberapa detail konfigurasi yang dapat diubah pada level modul. namespace : package name unik yang digunakan untuk Play Store, sama seperti yang kita atur pada saat membuat project. compileSdk : merupakan versi SDK yang digunakan untuk meng-compile project. applicationId : biasanya sama dengan namespace, nilainya bisa berubah untuk kebutuhan build variant. minSdk : merupakan versi SDK minimal yang didukung oleh project ini. Android dengan versi di bawahnya tidak dapat menjalankan aplikasi ini. targetSdk : target versi SDK yang menandakan aplikasi ini sudah dites pada versi SDK tertentu. Best practice-nya adalah memilih SDK yang terbaru. Jika tidak didefinisikan, nilainya sama dengan minSdk. versionCode : nilai integer yang menandakan versi dari aplikasi. Apabila kita sudah publish aplikasi ke PlayStore dengan versionCode 1, ketika ingin meng-update aplikasinya lagi ke Playstore, kita perlu mengubah versionCode menjadi 2 (incremental satu tingkat). Jika tidak diubah, PlayStore akan menolak APK yang di-upload. versionName : versi aplikasi berupa String yang biasa ditunjukkan ke user, misalnya 1.0.1. buildTypes : di dalamnya terdapat  properties  dari   debuggable , ProGuard enabling, debug signing, version name suffix  dan  test information . dependencies : di dalamnya terdapat informasi tentang  library  yang digunakan oleh aplikasi. Untuk lebih mengenal Android Studio lebih dalam, Anda juga dapat membaca materi ini. https://developer.android.com/studio/intro/index.html . Sync Project Setiap kali terjadi perubahan informasi di dalam  build.gradle  kita harus melakukan sinkronisasi terlebih dahulu. Tombol  sync now  akan muncul pada sebelah kanan atas ketika terjadi perubahan. Setelah proses sinkronisasi selesai, log akan menampilkan informasi apakah proses sinkronisasi berhasil atau tidak. Resource Manager Resource Manager berfungsi untuk memanajemen segala  resource  yang ada di proyek Anda seperti gambar, warna, layout dll. Jika Anda perhatikan struktur dari  res , dengan menggunakan Resource Manager semua  resource  akan tampil di sini dan dapat dimanipulasi sesuai kebutuhan.  Useful Tools pada Android Studio Android Studio menyediakan fasilitas yang  powerful  di bawah IntelliJ IDEA ini. Banyak  tools  milik Android yang membantu kita saat mengembangkan Aplikasi. Mari kita bahas  tools  yang sering digunakan beserta manfaatnya.   Shortcut Pencarian: Shift+Shift Search Everywhere,  atau dapat dikatakan pencarian semua jenis berkas yang masih dalam 1 proyek. Ctrl+F   Find,  pencarian teks dalam salah satu berkas. Ctrl+Shift+F Find in path , pencarian teks di seluruh berkas proyek. Ctrl+Shift+A Find action , pencarian aksi atau perintah-perintah yang ada di Android Studio. Ctrl+R  Replace , mengganti teks di dalam berkas. Navigasi: Ctrl+N  Find Class , navigasi ke kelas tertentu. Ctrl+Shift+N  Find file , navigasi ke berkas. Ctrl+B Go to declaration , lompat ke deklarasi yang dipilih. Alt+↑  Lompat ke method sebelumnya. Alt+↓  Lompat ke method sesudahnya. Ctrl+G  Go to line , lompat ke baris tertentu. Ctrl+E Membuka berkas teranyar ( recent file ). Ctrl+Left Mouse (or) Ctrl+Alt+F7 Melihat penggunaan pada variabel/objek yang diklik. Alt+F7 / Ctrl+F7 Melihat penggunaan variabel/objek yang dipilih di seluruh berkas proyek. Ctrl+Shift+B  Mencari tahu implementasi dari variabel/objek yang dipilih. Redaksi: Ctrl+D  Menggandakan bagian yang dipilih. Ctrl+Q  Melihat dokumentasi dengan tampilan minimal. Ctrl+P Melihat isi dari parameter, penting ketika melihat method dari Android atau library lain. Ctrl+Space  Basic code completion , menampilkan saran untuk melengkapi kode Anda. Ctrl+Shift+Space  Smart code completion , menampilkan saran kode untuk melengkapi kode Anda dengan lebih pintar (menampilkan apa yang benar-benar terkait dengan kode Anda). Alt+Insert Generate code,  menghasilkan ( generate ) kode. Perintah ini sangat memudahkan ketika membuat constructor dan setter/getter. Ctrl+Alt+L Memformat ulang kode, merapikan kode. Ctrl+Y Delete One Line , menghapus satu baris kode. Ctrl+Alt+V Create variable , membuat teks yang diblok menjadi sebuah variabel. Ctrl+Alt+M Create method , membuat teks yang diblok menjadi sebuah fungsi. Shift+F6 Rename, untuk mengganti nama suatu file atau variabel maupun fungsi. Run: Ctrl+F9 Make project, build project. Ctrl+Shift+F9  Melakukan kompilasi pada berkas, package atau modul. Shift+F10 Run.  Menjalankan aplikasi ke  emulator  atau  devices. Shift+F9  Debug.  Menjalankan aplikasi ke  emulator  atau  devices  dalam mode  Debug ,   biasanya untuk keperluan  testing. Code Completion Untuk meminimalisir salah ketik ( typo ) dalam pemanggilan  class ,  method  hingga variabe l  sebaiknya kita memanfaatkan Code Completion di Android Studio. Terdapat dua jenis  code completion  yang sering digunakan di Android Studio: Basic Code Completion (Ctrl+Space) Pemanggilan  code completion  standar untuk membantu kita melengkapi kode. Ketika kita ingin memanggil sebuah variabel, cukup ketikkan  code completion  di atas. Kemudian saran pun akan diberikan. Statement Completion (Ctrl+Shift+Enter) Perintah ini sangat membantu karena kita bisa menyelesaikan kode tanpa harus mengetik lengkap dan tanpa tanda kurung, kurung siku, kurung kurawal, serta banyak macam pemformatan lainnya. Kode di bawah ini ditulis sebelum menggunakan  shortcut : Kemudian kita menggunakan Statement Completion. Lihat apa yang terjadi! Statement kita yang belum tuntas akan diselesaikan oleh Android Studio. Tentu hal ini akan mempercepat waktu kita dalam menggarap aplikasi.  Selengkapnya Anda dapat mempelajarinya di  sini . Style dan Formatting Gaya penulisan kode adalah seni dalam pemrograman. Kita memiliki  signature style  masing-masing, Semua tergantung pilihan kita sendiri. Tetapi kita tetap perlu memperhatikan bagaimana tata letak kode, apalagi bila suatu saat nanti kita membuat aplikasi bersama orang lain. Kode yang rapi itu enak dilihat dan memudahkan, baik kita maupun orang lain untuk membacanya. Secara  default  Android Studio memberikan  code style formatting  untuk tata letak kode yang kita miliki. Untuk menyesuaikan setelan  code style , klik   File > Settings > Editor > Code Style  ( Android Studio > Preferences > Editor > Code Style  pada Mac.) Bagaimana menurut Anda tentang kode di atas? Ya tidak ada yang salah. Namun,  code style  berantakan dan tidak indah untuk dilihat. Nah, kini kita akan melakukan kode  formatting  dengan menggunakan shortcut  Ctrl+Alt+L.   Hasilnya lebih baik, bukan? Mungkin bila kode yang kita miliki sedikit, tidak terlalu berpengaruh. Namun, bila baris kode sudah mulai kompleks,  formatting code  seperti ini akan sangat membantu. Sample Code Android Studio juga membantu kita menemukan kode yang berkualitas dan  best practice -nya. Melalui Google, Android Studio memiliki  sample code  yang bebas kita gunakan dan manfaatkan untuk kebutuhan kita belajar atau membuat aplikasi Android. Dengan mengakses   File > New > Import Sample , kita punya banyak pilihan contoh kode yang bisa dipakai. Selengkapnya dapat kita jumpai di  sini . Keren, kan? Jadi biasakan diri Anda menggunakan alat bantu dari Android Studio untuk membantu dan mempercepat pembuatan aplikasi.";Untuk memulai dengan Android Studio, penting untuk mengenal struktur dan komponen dasar proyek yang akan membantu Anda dalam pengembangan aplikasi Android. Setelah membuka Android Studio, pilih “New project” untuk membuat proyek baru. Anda akan diminta memilih template yang memudahkan pembuatan aplikasi, seperti Empty Views Activity, yang sering digunakan sebagai standar di kelas ini. Setiap proyek memiliki struktur yang mencakup beberapa folder penting, seperti AndroidManifest.xml, yang mendeskripsikan komponen aplikasi, folder Java untuk kode sumber, dan res untuk resource seperti gambar, layout, dan strings. Selain itu, Gradle digunakan untuk mengelola build dan dependencies proyek. Setelah proyek dibuat, Anda akan melihat antarmuka Android Studio yang terdiri dari beberapa bagian utama, seperti toolbar, navigation bar, dan editor. Anda juga akan menggunakan berbagai tools dan shortcut untuk meningkatkan produktivitas pengembangan aplikasi, seperti pencarian berkas atau mengganti teks dalam proyek.
Menjalankan Aplikasi di Device & Emulator Uji coba aplikasi wajib dilakukan seorang  developer . Proses  running  atau  debugging  bisa dilakukan dengan dua cara, yaitu  running  dengan peranti ( physical  device ) atau emulator. Emulator adalah tool yang mensimulasikan OS Android di dalam komputer. Baik device langsung maupu emulator memiliki kelebihan dan kekurangan masing-masing. Kita sebagai  developer  tinggal pilih mana yang sesuai dengan keperluan. Persiapan Running Menggunakan Emulator Sebelum menggunakan emulator, pastikan beberapa hal berikut ini:   Virtualization Untuk menjalankan emulator di dalam Android Studio, pastikan aspek  virtualization . S istem Anda harus memenuhi persyaratannya, yakni ketentuan prosesor dan sistem operasi dari laptop / PC yang Anda gunakan. Processor   Prosesor Intel: Jika laptop/pc Anda menggunakan prosesor Intel, maka pastikan ia mendukung Intel VT-x, Intel EM64T (Intel 64), dan Execute Disable (XD) Bit functionality. Prosesor AMD: Jika laptop/pc Anda menggunakan AMD, maka pastikan bahwa ia support dengan AMD Virtualization (AMD-V) dan Supplemental Streaming SIMD Extensions 3 (SSSE3). Sistem Operasi Intel: Jika menggunakan processor Intel maka Anda dapat menjalankannya di sistem operasi Windows, Linux, maupun Mac. AMD: Untuk prosesor AMD maka hanya bisa menjalankannya di sistem operasi Linux. Konfigurasi Hardware Accelerated Execution Manager (HAXM) Dalam beberapa device yang tidak mendukung Emulator, Anda perlu menginstal HAXM. HAXM adalah  hardware-assisted virtualization engine  yang menggunakan teknologi VT dari Intel untuk mempercepat aplikasi Android yang diemulasi di mesin host. HAXM diperlukan untuk menjalankan emulator di Android Studio. HAXM diperlukan jika sistem operasi yang Anda gunakan adalah Windows atau Mac. Untuk menginstalnya, ikuti petunjuk berikut ini. Buka SDK Manager. Pilih SDK Update Sites, kemudian hidupkan Intel HAXM. Tekan OK. Cari berkas installer-nya di directory folder sdk komputer Anda, ~sdk\extras\intel\Hardware_Accelerated_Execution_Manager\intelhaxm-android.exe. Jalankan installer dan ikuti petunjuknya sampai selesai. Catatan: Jika HAXM sudah otomatis ter- install , maka Anda dapat melewati langkah di atas. Menginstal Kernel-based Virtual Machine (KVM) untuk Pengguna Linux Karena HAXM hanya untuk Windows dan Mac, bagaimana dengan sistem operasi Linux? Untuk Linux, Anda harus menginstal KVM. Sistem operasi Linux dapat support accelerated virtual machine dengan menggunakan KVM. Untuk instal KVM, Anda bisa menggunakan perintah berikut ini. $ sudo apt-get install qemu-kvm libvirt-bin ubuntu-vm-builder bridge-utils ia32-libs-multiarch Selengkapnya dapat Anda baca pada halaman berikut ini: https://developer.android.com/studio/run/emulator.html https://developer.android.com/studio/run/emulator-acceleration.html Run dengan device Bila Anda hendak melakukan  run  atau  debugging , lebih baik Anda menjalankannya pada peranti  smartphone  asli.  Running  dengan menggunakan peranti memiliki beberapa kelebihan jika dibandingkan dengan emulator yaitu: Lebih cepat dan ringan, Fitur seperti geo-location,  push notif  bisa digunakan, Bisa mengetahui daya serap baterai terhadap aplikasi, Lebih mudah. Dengan menggunakan peranti  smartphone  asli, kita dapat memastikan bahwa aplikasi kita berjalan dengan wajar ketika sudah sampai di tangan pengguna. Kendala dari pendekatan ini adalah beragamnya model peranti yang ada di pasaran. Namun, pembahasan mengenai hal tersebut tidak tercakup dalam kelas ini. Mari ikuti langkah-langkah untuk menjalankan proses  run  atau  debugging . Tampilan dari langkah berikut bisa dipastikan akan berbeda dengan peranti yang Anda pakai. Akan tetapi secara garis besar langkahnya akan sama. Pastikan peranti yang akan dipakai sesuai dengan target SDK atau paling tidak mendukung versi SDK terendah yang digunakan aplikasi. Buka  setting  dan masuk ke dalam menu  About . Pada halaman menu ini, Anda perlu menemukan informasi tentang  Build number . Kemudian tekan  Build number   sebanyak  7 kali . Kembali ke   menu setting  di awal dan akan muncul menu baru di bawah  about  yaitu  Developer Options . Masuk ke dalam menu  Developer Options  dan pastikan opsi  USB Debugging Mode  sudah  on . Catatan : Beberapa vendor  smartphone  memiliki sistem operasi yang unik. Tampilan  setting  dan letak opsi bisa jadi tak sama dengan gambar di atas. Beberapa vendor juga mengharuskan Anda untuk mengunduh  driver  khusus sebelum bisa menghubungkannya ke Android Studio. Kami sarankan untuk mengunjungi website atau membaca petunjuk yang sesuai dengan vendor dari peranti Anda. Anda bisa unduh ADB Driver di tautan berikut: http://adbdriver.com/downloads/ https://adb.clockworkmod.com/ Setelah menyelesaikan pengaturan pada peranti, peranti pun dapat dihubungkan dengan laptop atau komputer dengan menggunakan kabel data. Klik  Izinkan  dan centang untuk  selalu izinkan  apabila muncul pop up  Izinkan debugging USB . Selain menggunakan kabel data, saat ini juga tersedia fitur wireless debugging di Android Studio. Anda hanya cukup menghubungkan device ke jaringan Wi-Fi yang sama dengan PC. Kemudian pada tool window  Device Manager , pilih tab  Physical , klik  Pair Using Wi-Fi , dan scan QR code yang muncul. Jika device sudah terdeteksi pada Android Studio, ia akan otomatis muncul pada daftar device dan Anda bisa menjalankan aplikasi dengan klik ikon segitiga hijau berikut: Menggunakan Emulator Jika Anda memiliki spesifikasi laptop yang lumayan tinggi, Anda dapat juga menggunakan emulator untuk menjalankan aplikasi langsung di PC Anda tanpa perlu menggunakan device. Penasaran caranya, silakan ikuti langkah-langkah berikut. Buka AVD Manager dengan klik icon berikut: Akan muncul Kemudian pilih  Create device . Akan muncul dialog dengan pilihan beberapa emulator yang bisa Anda pilih. Pilih salah satu dan klik  Next . Kemudian pilih satu system image, usahakan pilih versi Android yang terbaru dan klik Next. Jika anda ingin membuat spesifikasi  hardware  (perangkat keras)   sendiri, Anda bisa memilihnya pada pilihan  New Hardware Profile . Akan muncul dialog seperti di bawah ini. Anda dapat menentukan konfigurasi  hardware  sesuai dengan kebutuhan Anda. Yang perlu diingat adalah untuk menggunakan konfigurasi emulator yang sesuai dengan kemampuan laptop atau komputer yang Anda gunakan. Anda dapat membuat  hardware  emulator baru atau memilih  hardware  emulator yang sudah ada. Setelah memilih  hardware  emulator, akan muncul dialog seperti ini. Pada dialog ini Anda akan memilih versi android dari emulator yang akan anda buat. Pada dialog tersebut, Anda perlu memilih versi yang sudah diunduh yaitu Nougat. Tombol  download  di sebelah kanan versi menunjukkan bahwa Anda perlu mengunduhnya terlebih dahulu jika ingin menggunakannya. Selanjutnya klik  Next . Akan muncul dialog  verify configuration . Pada dialog ini, Anda bisa memeriksa konfigurasi dari emulator yang Anda pilih. Pada bagian kiri bawah, terdapat tombol  Show Advanced Settings . Bila Anda menekan tombol ini, akan muncul tampilan dialog baru seperti gambar di bawah ini. Pada bagian  advanced setting ,  A nda bisa mengubah konfigurasi  hardware  yang telah ditentukan sebelumnya. Jika sudah selesai, Anda dapat menekan tombol  Finish . Anda dapat membuka emulatornya dengan menekan tombol  hijau  yang ada di sebelah kanan. Pengaturan emulator sudah selesai dan bisa langsung dijalankan. Secara default, emulator akan muncul di dalam tool window. Jika Anda ingin mengubahnya, buka File → Settings → Cari Tools Emulator atau menggunakan keyword Emulator → Ubah  Launch in a tool window  dalam keadaan tidak tercentang. Catatan : Menggunakan emulator dari Android Studio kadang terasa berat untuk beberapa  device  dengan spesifikasi rendah. Untuk mengatasinya Anda bisa menjalankan langsung pada device Android dengan mengikuti langkah selanjutnya atau menggunakan emulator pihak ketiga yang lebih ringan seperti : Nox Player   Memu Play Bluestack KoPlayer Andy Pilih salah satu emulator di atas, kemudian install dan jalankan aplikasinya. Maka emulator tersebut akan otomatis muncul di List Virtual Devices pada Android Studio.;Untuk menjalankan aplikasi Android, Anda dapat memilih antara menggunakan perangkat fisik atau emulator. Untuk emulator, pastikan komputer Anda mendukung virtualisasi dan menginstal HAXM (untuk Windows/Mac) atau KVM (untuk Linux). Di perangkat fisik, aktifkan USB Debugging di Developer Options, sambungkan perangkat dengan kabel USB atau Wi-Fi, dan pilih perangkat di Android Studio untuk menjalankan aplikasi. Jika menggunakan emulator, buat perangkat virtual melalui AVD Manager, pilih system image, dan sesuaikan konfigurasi hardware. Emulator juga bisa dijalankan dengan menggunakan software pihak ketiga seperti Nox Player atau Bluestack jika emulator Android Studio terasa berat.
"Membuat APK dan AAB Salah satu langkah terakhir yang perlu dilakukan setelah mengembangkan aplikasi Android adalah mempublikasikan Aplikasi Anda supaya bisa dijalankan oleh orang lain. Ada jenis format yang perlu Anda ketahui, yaitu APK dan AAB.  APK  (Android Package): merupakan berkas  executable  yang bisa langsung dijalankan di dalam OS Android. Jika Anda belum memahami berkas APK, Anda dapat menyamakannya dengan berkas  exe  di windows atau  ipa  di iOS. AAB  (Android App Bundle): merupakan berkas yang didistribusikan oleh Google Play ke pengguna. Jadi, ketika Anda hendak memublikasikan Aplikasi Anda ke Google Play, berkas inilah yang harus Anda unggah. Dengan format ini, ukuran aplikasi yang diunduh bisa menjadi jauh lebih kecil. Hal ini karena sifatnya yang dinamis, di mana ia dapat mengunduh hanya bagian (seperti bahasa, arsitektur, dan density) yang diperlukan saja. Cara membuat kedua file ini di Android terbilang cukup mudah. Anda dapat menggunakan sebuah  wizard  atau melalui  command line . Pada modul ini, kita akan fokus menggunakan  wizard . Dari sisi kredibilitas, ada 2 macam berkas APK/AAB yang dapat Anda buat. Unsigned APK/AAB : merupakan berkas yang digunakan untuk pengujian saja. Signed APK/AAB : merupakan berkas yang digunakan untuk diupload ke PlayStore. Bedanya yaitu memerlukan keystore. Keystore  adalah sebuah berkas biner yang berisi informasi tentang satu atau lebih  private key .  Private key  ini digunakan untuk mencegah pemalsuan aplikasi. Konsep umumnya adalah: Sistem Operasi Android mewajibkan semua APK di -sign  sebelum terpasang ke dalam device. Proses  signing  ini membutuhkan  Public  dan  Private Key. Proses  signing  ini berlangsung selama pembuatan APK dalam mode  debug  maupun  released. Sebuah sertifikat  digital public key , atau  identity certificate,  berisi informasi mengenai sertifikat itu sendiri dan  metadata  dari pemilik sertifikat tersebut. Pemilik sertifikat ini biasanya adalah developer yang mengembangkan aplikasi. Public key  yang digunakan dalam proses  signing  di atas akan dilampirkan di dalam berkas APK. Proses ini dilakukan secara otomatis oleh Android Studio. Ketika Anda hendak memperbarui Aplikasi Anda pada Google Play, maka Google Play hanya akan menerimanya bila  keystore  yang digunakan sama dengan  keystore  yang pertama kali Anda gunakan ketika mengunggah Aplikasi tersebut ke Google Play. Kegunaan lain dari  keystore  adalah: Untuk integrasi ke layanan Google seperti Google Maps dengan menggunakan nilai  hash  (digest SHA1) di dalamnya. Untuk integrasi ke layanan API Facebook dengan menggunakan key hash base64 yang terkandung di dalam  keystore . Keystore  merupakan sebuah berkas penting yang harus Anda jaga, terlebih ketika aplikasi Anda memiliki jumlah unduhan pengguna yang banyak. Sebabnya, kelalaian menjaga  keystore  ini dapat menghalangi Anda untuk memperbarui aplikasi. Akibat terburuk adalah Anda harus melakukannya dari awal lagi. Berikut adalah tips yang bisa Anda gunakan untuk mengamankan  keystore  : Pilih kata kunci ( password ) yang sulit ditebak. Kombinasikan angka, alfabet dan simbol dalam membuatnya. Jangan memberikan  keystore  kepada orang yang tidak dipercaya apalagi meletakkannya di dalam berkas proyek aplikasi. Letakan di tempat yang Anda ingat dan aman tentunya. Untuk memahami hal di atas lebih jauh, baca tautan berikut: App Signing Jika Anda ingin menemukan  keystore  Anda, maka pengguna Mac dapat menemukannya di  ~/.android/debug.keystore . Sementara itu pengguna Windows bisa menemukannya di   C:\User\YourUser\.android\debug.keystore . Catatan: Pada akhir kelas, Anda akan diminta sebuah project aplikasi Android dengan format APK, cukup yang unsigned saja. Untuk itu, perhatikan baik-baik cara pembuatannya. Codelab Build APK Untuk mulai melakukan proses  build  APK, Anda dapat mengikuti langkah berikut: Buka kembali proyek kosong yang telah kita buat sebelumnya. Sekarang klik menu  Build → Build Bundles(s) / APK(s) → Build APK(s) . Gradle akan membuat berkas APK secara otomatis. Lama proses ini bergantung pada seberapa kompleks Aplikasi yang dibuat serta spesifikasi perangkat yang digunakan. Ketika berhasil, Anda dapat melihat notifikasi pada sudut kanan atas Android Studio: Sekarang tinggal Anda tekan tautan yang terdapat pada notifikasi tersebut. Secara otomatis Anda akan diarahkan ke lokasi di mana berkas APK disimpan. Biasanya lokasinya mengikuti struktur  project-name/module-name/build/outputs/apk/ . Jika proyek bernama  HelloWorld , maka lokasinya adalah  HelloWorld / app/build/outputs/apk/apk-debug.apk . Sekarang coba Anda pindahkan berkas APK yang baru dibuat ke dalam sebuah peranti (device). Buka lokasi berkas tersebut menggunakan  file explorer  pada gawai tersebut. Kemudian lakukan instalasi aplikasi seperti biasa. Selamat, aplikasi Android baru Anda sudah terpasang di peranti. Berkas APK ini bisa Anda berikan ke pengguna lain untuk dicoba. Mudah bukan? Codelab Build Signed AAB Sekarang kita lanjut membuat AAB dengan keystore.  Ingat, APK yang baru saja Anda buat akan ditolak oleh Google Play Store jika Anda mencoba mengunggahnya. Agar dapat diterima, Anda harus memublikasikan dalam format AAB yang sudah ditandatangani dengan menggunakan keystore. Kembali ke project Android Studio, klik  Build → Generate Signed Bundle / APK... . Selanjutnya, pilih  Android App Bundle  dan klik  Next . Selanjutnya, pilih  C reate ne w...  untuk membuat Key store. Pilihah lokasi penyimpanan pada bagian key store path. Lalu, lengkapi isian di dalamnya. Contoh pengisiannya adalah seperti gambar di bawah ini: Berikut penjelasan tiap isiannya: Keystore path Anda perlu menentukan di mana lokasi  keystore  Anda Password       Isikan keystore password minimal 6 digit dan bedakan dengan keypassword di bawahnya Alias           Alias dari keystore P assword       keypassword Validity Berapa lama keystore Anda akan valid (dalam hitungan tahun) Firstname hingga Country Code Isikan  metadata . Penting untuk mengisi data ini dengan benar. Setelah selesai klik  OK . Dialog yang di awal akan secara otomatis terisi ketika Anda sudah berhasil mengisi form sebelumnya. Klik  N ext  untuk melanjutkan. Catatan: Jika muncul pertanyaan kata kunci, masukkan kata kunci yang Anda gunakan untuk laptop atau komputer. Selanjutnya pilih  release  dan klik  Finish . Selain release yang berguna untuk kepentingan publish ke PlayStore, ada juga debug yang berguna untuk pengujian saja. Perhatikan gradle process di status bar bagian bawah untuk melihat progress signed/generate AAB. Ketika berhasil, notifikasi seperti berikut akan tampil. Selamat AAB versi  released  Anda telah berhasil dibuat. Untuk membuka folder secara langsung, Anda dapat membuka link  l ocate , selain itu juga ada juga bisa menganalisa hasil file yang dibuat dengan menggunakan  analyze . Proses ini perlu ketika Anda hendak mempublikasikan aplikasi Anda di Google Play Store dan memperbaruinya di kemudian waktu. Ketika Anda memperbarui aplikasi, jangan lupa untuk mengubah nilai yang ada di dalam  build.gradle(Module:app) : versionCode 2   //Incremental versionName  ""2.0""";Untuk mempublikasikan aplikasi Android, Anda perlu membuat berkas APK atau AAB. APK (Android Package) adalah file executable yang dapat langsung dijalankan di perangkat Android, sedangkan AAB (Android App Bundle) adalah format distribusi yang digunakan oleh Google Play. Untuk membuat APK atau AAB, Anda bisa menggunakan Android Studio melalui wizard. Terdapat dua jenis berkas: unsigned untuk pengujian dan signed untuk dipublikasikan di Google Play. Proses signing memerlukan keystore, yang berisi private key untuk memastikan keamanan aplikasi. Keystore harus dijaga dengan baik agar aplikasi dapat diperbarui di Google Play. Untuk membuat APK, Anda cukup mengikuti menu Build → Build APKs di Android Studio, sedangkan untuk AAB yang signed, pilih Build → Generate Signed Bundle / APK dan buat keystore yang diperlukan. Pastikan untuk menyertakan informasi yang benar dalam keystore dan mengubah versionCode di file build.gradle saat memperbarui aplikasi.
Materi Android Pemula Dalam kelas ini kita akan belajar tentang komponen-komponen dasar yang digunakan untuk membuat aplikasi android sederhana dengan menggunakan Android Studio. Berikut adalah materi yang akan kita pelajari : Pengenalan Android Studio Android Studio merupakan IDE yag dibuat oleh Jetbrains khusus untuk membuat aplikasi Android. Di dalamnya terdapat fitur yang sangat lengkap untuk membuat proses development menjadi lebih mudah dan cepat. Mulai dari membuat project dengan menggunakan template, mendesain dengan menggunakan Layout Editor, menjalankan aplikasi dengan emulator, sampai membuat APK untuk didistribusikan. Activity Merupakan satu komponen yang sangat penting dan berhubungan erat dengan interaksi ke pengguna. Activity menangani tampilan mana yang akan di tampilkan dan mengatur logika yang ada di dalamnya. Activity juga memiliki daur hidup ( lifecycle ) tersendiri yang dimulai dari   onCreate   hingga   onDestroy. Intent Komunikasi antar komponen di dalam sebuah aplikasi merupakan hal yang sangat sering dilakukan. Inilah peran dari suatu Intent. Beberapa fungsi dari Intent adalah digunakan untuk menjalankan sebuah Activity lain dan mengirimkan data saat berpindah antar halaman. Views dan ViewGroup Pada dasarnya semua elemen UI ( user interface ) di aplikasi Android dibangun menggunakan dua buah komponen inti, yaitu View dan Viewgroup. Sebuah View adalah elemen UI tempat kita berinteraksi ketika kita menggunakan aplikasi, seperti tombol, teks, dan gambar. Sedangkan ViewGroup adalah komponen tidak terlihat yang digunakan untuk mengatur tata letak dari komponen yang ada di dalamnya. Style dan Theme Prinsip dasar dalam merancang antarmuka aplikasi Android adalah harus mematuhi kaidah yang ditetapkan oleh Design Guideline. Guideline ini dibuat oleh tim Google dengan nama Material Design Component (MDC). Pada modul ini Anda akan mengubah warna tema MDC tersebut dan membuat style untuk komponen yang mirip sehingga membuat proses desain menjadi lebih cepat. RecyclerView RecyclerView adalah sebuah komponen tampilan  ( widget )  untuk menampilkan data dengan jumlah banyak secara dinamis. RecyclerView juga memiliki kemampuan untuk menampilkan data secara efisien dalam jumlah yang besar. Ia juga dapat mengatur bagaimana suatu konten ditampilkan dengan menggunakan Layout Manager. Setelah mempelajari seluruh materi tersebut, Anda dapat membuat sebuah aplikasi Android yang dapat menampilkan banyak informasi seperti berikut. Keren, bukan? Anda akan diminta untuk mengerjakan submission (tugas akhir) untuk membuat aplikasi seperi di atas. Tentunya dengan tema bebas sesuai keinginan Anda. Mantap!;Dalam kelas Android Pemula ini, Anda akan mempelajari berbagai komponen dasar untuk membuat aplikasi Android sederhana menggunakan Android Studio. Materi yang akan dipelajari meliputi pengenalan Android Studio, yang merupakan IDE khusus untuk pengembangan aplikasi Android dengan berbagai fitur lengkap seperti Layout Editor dan pembuatan APK. Anda juga akan mempelajari tentang Activity, komponen yang mengatur tampilan dan logika interaksi pengguna, serta daur hidupnya yang dimulai dari onCreate hingga onDestroy. Selanjutnya, Anda akan belajar tentang Intent yang digunakan untuk komunikasi antar komponen aplikasi, seperti berpindah antar Activity dan mengirim data. Materi lainnya mencakup Views dan ViewGroup, di mana View adalah elemen UI yang dapat dilihat dan diinteraksikan pengguna (seperti tombol dan teks), sedangkan ViewGroup mengatur tata letak elemen-elemen UI. Anda juga akan mempelajari Style dan Theme, yang berhubungan dengan desain antarmuka menggunakan prinsip Material Design Components (MDC). Terakhir, Anda akan belajar tentang RecyclerView, komponen untuk menampilkan data dalam jumlah banyak secara dinamis dan efisien. Setelah mempelajari seluruh materi ini, Anda akan dapat membuat aplikasi Android yang menampilkan berbagai informasi, sesuai dengan tema yang Anda pilih untuk tugas akhir.
Teori Activity Activity  merupakan salah satu komponen penting Android yang berfungsi untuk menampilkan  user  interface  ke layar pengguna. Ini seperti pada saat Anda melihat daftar percakapan pada aplikasi  chat  atau daftar  email  pada aplikasi Gmail di ponsel Android Anda. Di dalamnya Anda dapat berinteraksi dengan aplikasi Anda, baik dengan menekan tombol atau menampilkan  list . Seperti ketika Anda membuat project baru di Android Studio, biasanya akan ada dua berkas yang sudah tercipta, yaitu  MainActivity  dan  activity_main.xml .  MainActivity ini disebut sebagai class Activity karena mewarisi ( extends )  superclass   Activity. Tugasnya yaitu menampilkan layout activity_main.xml dan mengelola interaksi yang ada di dalamnya. Umumnya dalam sebuah aplikasi terdapat lebih dari satu Activity   yang saling terhubung dengan tugas yang berbeda-beda. Yang perlu diperhatikan yaitu setiap Activity harus terdaftar di  AndroidManifest.xml .   Secara  default , ia akan didaftarkan jika Anda membuat Activity baru dengan cara otomatis. Caranya yaitu klik kanan pada nama package → New → Activity → pilih template Activity yang tersedia.  Activity Lifecycle Developer yang baik harus mengetahui secara detail tentang  life cycle  sebuah Activity. Terutama untuk melakukan aksi yang tepat, saat terjadi perubahan  state  Activity.  Callback methods  yang ada dapat digunakan untuk melakukan beragam proses terkait state dari Activity.   Misalnya melakukan semua inisialisasi komponen di onCreate(), melakukan  disconnect  terhadap koneksi ke  server  pada onStop() atau onDestroy() dan lain sebagainya. Pemahaman yang baik tentang daur hidup Activity akan membuat implementasi rancangan aplikasi Anda menjadi lebih baik. Hal ini juga akan meminimalisir terjadinya  error / bug / force   close  yang tidak diinginkan. Last In, First Out  (LIFO) Gambar 1 Gambar 2 Gambar 3 Aktif: Activity 1 onCreate()  →  onStart()  →  onResume() Aktif: Activity 2 Stack append: Activity 2 [  onResume()  ] Activity 1 onStop()  →  onRestart()  →  onStart()  →  onResume() Aksi: Klik Button1 (Pindah) Aksi: Klik Hardware Back Button Aktif: Activity 1 Stack append: Activity 1 [  onStop()  ] Activity 2 [  finish()  ] Stack pop: Activity 2 [  onDestroy()  ]   Gambar 1 Jika Anda memiliki sebuah aplikasi yang terdiri dari 2 Activity, maka Activity pertama akan dijalankan setelah pengguna meluncurkan aplikasi melalui ikon aplikasi di layar device. Activity yang ada saat ini berada pada posisi Activity   running  setelah melalui beberapa  state  onCreate ( created ) → onStart ( started ) → onResume (resumed) dan masuk ke dalam sebuah stack Activity. Bila pada Activity pertama Anda menekan sebuah tombol untuk menjalankan activity kedua, maka posisi  state  dari Activity pertama berada pada posisi  stop . Saat itu,  callback  onStop() pada Activity pertama akan dipanggil. Ini terjadi karena Activity pertama sudah tidak berada pada layar  foreground  / tidak lagi ditampilkan. Semua informasi terakhir pada Activity pertama akan disimpan secara otomatis. Sementara itu, Activity kedua masuk ke dalam  stack  dan menjadi Activity terakhir yang masuk. Gambar 2 Activity kedua sudah muncul di layar sekarang. Ketika Anda menekan tombol  back  pada  physical button  menu utama atau menjalankan metode finish(), maka   Activity kedua Anda akan dikeluarkan dari  stack . Pada kondisi di atas, state Activity kedua akan berada pada  destroy . Oleh karenanya, metode onDestroy() akan dipanggil. Kejadian keluar dan masuk  stack  pada proses di atas menandakan sebuah model  Last In, First Out .   Activity kedua menjadi yang terakhir masuk  stack  ( Last In ) dan yang paling pertama keluar dari  stack  ( First Out ). Gambar 3 Activity pertama akan dimunculkan kembali di layar setelah melalui beberapa  state  dengan rangkaian  callback method  yang terpanggil, onStop → onRestart → onStart → onResume. Saving Activity State Ketika sebuah Activity mengalami  pause  kemudian  resume , maka state dari sebuah Activity tersebut dapat terjaga. Sebabnya, obyek activity masih tersimpan di  memory  sehingga dapat dikembalikan  state -nya. Dengan menjaga  state  dari Activity, maka ketika Activity   tersebut ditampilkan, kondisinya akan tetap sama dengan kondisi sebelumnya. Akan tetapi ketika sistem menghancurkan Activity   untuk keperluan memori misalnya karena memori habis, maka obyek Activity dihancurkan. Alhasil, ketika Activity   ingin ditampilkan kembali diperlukan proses  re create  Activity yang dihancurkan tadi. Kejadian di atas adalah hal yang lumrah terjadi. Oleh karena itu, perubahan yang terjadi pada Activity perlu disimpan terlebih dahulu sebelum ia dihancurkan. Di sinilah metode onSaveInstanceState() digunakan. Dalam onSaveInstanceState terdapat bundle yang dapat digunakan untuk menyimpan informasi. Informasi dapat disimpan dengan memanfaatkan fungsi seperti putString() dan putInt(). Ketika Activity di- restart ,   bundle akan diberikan kepada metode onCreate dan onRestoreInstanceState. Bundle tersebut akan dimanfaatkan untuk mengembalikan kembali perubahan yang telah terjadi sebelumnya. Proses penghancuran Activity   dapat juga terjadi ketika terdapat perubahan konfigurasi seperti perubahan orientasi layar ( portrait-landscape ),  keyboard availability , dan perubahan bahasa. Penghancuran ini akan menjalankan  callback method  onDestroy dan kemudian menjalankan onCreate. Penghancuran ini dimaksudkan agar Activity   dapat menyesuaikan diri dengan konfigurasi baru yang muncul pada kejadian-kejadian sebelumnya. Hal yang perlu diingat ketika menggunakan onSaveInstanceState adalah untuk tidak menyimpan data yang besar pada bundle. Contohnya, hindari penyimpanan data  bitmap  pada bundle. Bila data pada bundle   berukuran besar, proses serialisasi dan deserialisasi akan memakan banyak memori. Untuk lebih mendalami Activity, kami menyarankan Anda untuk membaca referensi berikut : Activities;Activity di Android adalah komponen utama yang digunakan untuk menampilkan antarmuka pengguna dan mengelola interaksi pengguna. Setiap aplikasi biasanya memiliki beberapa Activity yang saling terhubung, dan setiap Activity memiliki lifecycle yang terdiri dari beberapa metode callback seperti onCreate(), onStart(), onResume(), onStop(), dan onDestroy(). Pemahaman yang baik tentang lifecycle Activity sangat penting untuk mengelola status dan memori aplikasi, serta untuk menangani perubahan konfigurasi atau ketika Activity dihancurkan dan dibuat ulang. Data yang perlu dipertahankan selama perubahan status dapat disimpan menggunakan onSaveInstanceState() dan objek Bundle.
"Tujuan Codelab ini bertujuan untuk mengimplementasikan komponen Activity pada aplikasi pertama yang Anda bangun. Harapannya aktifitas ini dapat memberi gambaran yang jelas tentang cara kerja Activity. Codelab pertama adalah dengan membuat aplikasi yang dapat menghitung volume balok. Seperti ini tampilannya. Logika Dasar Melakukan input ke dalam obyek EditText → melakukan validasi input → melakukan perhitungan volume balok ketika tombol hitung diklik. Codelab Membuat Proyek Baru Hai !  Pasti sudah tidak sabar ya untuk memulai membuat aplikasi pertama kalian. Sebelum mulai lebih lanjut, ada video menarik nih buat teman-teman supaya bisa mendapatkan gambaran terlebih dahulu bagaimana proses pembuatan aplikasi pertama. Silakan dicek ya! Okay, jika sudah dapat gambarannya, yuk kita lanjut untuk bikin aplikasinya.  Cuss! Buat proyek baru dengan klik  File → New → New Project   pada Android Studio Anda atau Anda bisa memilih  Start a new Android Studio project  di bagian  dashboard . Windows iOS Pada bagian ini kita akan memilih tipe activity awal dari  template  yang telah disediakan. Untuk saat ini, pilih tipe  Empty Activity  untuk belajar dari yang paling dasar, lalu klik  Next  untuk melanjutkan. Selanjutnya masukkan  nama aplikasi  dan nama  package  aplikasi Anda. Sebaiknya jangan sama dengan apa yang ada di contoh, karena ini berfungsi sebagai id   dari aplikasi yang Anda buat. Kemudian Anda bisa menentukan lokasi proyek yang akan Anda buat. Setelah itu pilih tipe gawai/peranti ( device ) untuk aplikasi beserta target minimum SDK yang akan digunakan. Pilihan target Android SDK akan mempengaruhi banyaknya peranti yang dapat menggunakan aplikasi. Di sini kita memilih nilai minimum SDK kita pasang ke  Level 21 (Lollipop) . Klik  Finish  untuk melanjutkan. Catatan: Kotlin merupakan rekomendasi Google dalam pembuatan aplikasi ini. Namun, kelas ini juga mendukung bahasa Java. Untuk menggunakan bahasa Java, ubahlah  language  dari Kotlin menjadi Java, maka secara otomatis Android Studio akan menyesuaikan dengan bahasa Java. Tampilan layar Anda akan seperti contoh di bawah ini: Di sebelah kanan Anda adalah  workspace  di mana Activity Anda berada dan bernama MainActivity dengan layout-nya activity_main.xml. Di sebelah kiri Anda terdapat struktur proyek, di mana nanti kita akan banyak menambahkan berbagai komponen baru,  asset  dan  library .  Selanjutnya kita akan mulai melakukan pengkodean aplikasi atau lebih enaknya disebut  ngoding . Berikut flow umumnya: Ngoding Layout  untuk user interface aplikasi. Ngoding Activity  untuk menambahkan logika aplikasi. Untuk mengoptimalkan proses pengetikan, Anda dapat memanfaatkan  code completion  dengan menekan  ctrl + space .   Android Studio juga akan otomatis mengimpor  package  dari komponen yang digunakan.  Dilarang Keras untuk copy - paste!  Ngoding pelan-pelan akan membuat Anda lebih jago di masa depan. Selamat ngoding! Codelab Layouting Menambahkan Code Sederhana pada Layout Activity Silakan pilih berkas  activity_main.xml  pada  workspace  Anda yang terletak di folder  res/layout/activity_main.xml . Pastikan  project window  pada pilihan  Android  seperti di bawah ini. Maka akan ada tampilan seperti ini di sebelah pojok kanan atas, kemudian pilih tab  Code  atau  Split . Ubah layout dasar dari ConstraintLayout menjadi LinearLayout seperti berikut: Catatan: Pada latihan awal ini kita akan menggunakan LinearLayout karena merupakan layout yang paling mudah. Pembahasan lebih lanjut tentang macam-macam layout akan dibahas pada materi selanjutnya. Jadi ikuti saja dulu ya! Perhatikan bahwa dalam penulisan kode XML, ada dua cara dalam penulisan tag seperti gambar di bawah ini. Self-closing tag : tag diawali dengan  <  dan diakhiri dengan  /> . Biasanya digunakan untuk View tanpa isi. Opening dan closing tag : opening tag diawali dengan  <  dan diakhiri dengan  >  saja. Sebagai gantinya, ada closing tag dengan format  </NamaView> . Biasanya digunakan untuk layout yang menampung View lain di dalamnya. Selanjutnya tambahkan baris-baris yang dicetak  tebal  di bawah ini. Berikut adalah contoh cara menuliskannya. Perhatikan bahwa dalam penulisan kode, kita tidak perlu menuliskan kode secara lengkap. Manfaatkanlah snippet untuk code completion yang muncul dan tekan Enter. <?xml version=""1.0"" encoding=""utf-8""?>ndroid:textStyle=""bold"" /> </LinearLayout>   Jika Anda perhatikan, hasil layout sementara akan menjadi seperti ini: Selain menggunakan  code  seperti di atas, Anda juga dapat membuat layout dengan menggunakan  design . Untuk tutorialnya dapat Anda lihat di video berikut: Setelah selesai mendesain aplikasi, silakan coba jalankan aplikasi dengan memilih menu  Run → Run ‘app’  dari  menu bar . Selain cara di atas, Anda juga dapat menekan icon berikut di toolbar: Itu tandanya ADB ( Android Debugger ) pada peranti yang Anda punya telah terhubung dengan Android Studio. Jika Anda tidak memiliki peranti, maka Anda dapat menggunakan emulator. Ikuti materinya di modul  sebelumnya  atau lihat materi di  sini . Catatan: Kami merekomendasikan Anda menggunakan peranti Android sewaktu mengembangkan aplikasi. Selain karena beban memori pada peranti Anda akan jadi lebih rendah, pendekatan ini juga akan memungkinkan Anda untuk merasakan bagaimana aplikasi berjalan di  device  sebenarnya. Pilih  OK  untuk menjalankan dan tunggu hingga proses  building  dan instalasi APK selesai. Jika sudah, seharusnya hasilnya akan seperti ini: Saat ini aplikasi telah tampil, namun ketika Anda coba untuk memasukkan angka dan klik tombol  Hitung , aplikasi tidak akan merespons. Hal ini karena kita belum menambahkan logika kode pada  MainActivity . Nah, yuk kita lanjut ke codelab selanjutnya supaya aplikasi pertama kita bisa berjalan dengan semestinya. Semangat! Codelab Kode Logika Menambahkan Kode Logika Sederhana pada  MainActivity . Selanjutnya setelah selesai, lanjutkan dengan membuka berkas  MainActivity  dan lanjutkan  ngoding  baris-baris di bawah ini. Tambahkan beberapa variabel yang akan digunakan untuk menampung View. Kotlin private lateinit var edtWidth: EditText private lateinit var edtHeight: EditText private lateinit var edtLength: EditText private lateinit var btnCalculate: Button private lateinit var tvResult: TextView Catatan: Perhatikan bagaimana cara menuliskan kodenya. Biasakan menekan  Enter  ketika mengetik supaya komponen di- import  secara otomatis, kecuali nama variabel yang Anda tentukan sendiri seperti  edtWidth  harus diketik satu per satu. Java private EditText edtWidth; private EditText edtHeight; private EditText edtLength; private Button btnCalculate; private TextView tvResult; Catatan: Perhatikan bagaimana cara menuliskan kodenya. Biasakan menekan  Enter  ketika mengetik supaya komponen di- import  secara otomatis, kecuali nama variabel yang Anda tentukan sendiri seperti  edtWidth  harus diketik satu per satu. Kemudian inisiasi variabel yang telah kita buat dengan menambahkan kode berikut di dalam metode . Layout dituliskan dalam format xml (extensible markup language). xml version=""1.0"" encoding=""utf-8""?> Baris ini mengidentifikasi bahwa berkas ini berformat xml. xmlns:android=""http://schemas.android.com/apk/res/android"" Kode di atas menandakan namespace yang digunakan dalam keseluruhan berkas xml ini. Macam View Di sini kita menggunakan beberapa komponen  user interface  yang disebut view. Di antaranya: TextView  : Komponen view untuk menampilkan teks ke layar EditText  : Komponen view   untuk memberikan input teks Button  : Komponen view   untuk melakukan sebuah aksi klik LinearLayout  : Komponen view   bertipe viewgroup   yang menjadi  parent  dari semua sub komponen view   (sub view) di dalamnya. Komponen ini bersifat sebagai kontainer untuk komponen lain dengan orientasi secara vertikal atau horizontal. Cara membaca :  <TextView     android:layout_width=""match_parent""     android:layout_height=""wrap_content""     android:text=""@string/calculate""     android:layout_marginBottom=""16dp""/> Komponen di atas adalah sebuah  TextView . Perhatikan gambar di bawah ini. Warna ungu menandakan  namespace  yang digunakan; warna biru adalah atribut dari komponen dan warna hijau adalah nilai dari atribut. Penjelasannya seperti di bawah ini:  Penjelasannya sebagai berikut: android:id=""@+id/btn_calculate"" Jika kita memberikan  id  pada sebuah view maka kita telah memberikan  identifier  untuk view   tersebut. Pemberian  id   ini dimaksudkan agar kita bisa melakukan manipulasi/pengendalian pada  level logic  di komponen seperti activity atau fragment. Id   di atas akan diciptakan di berkas  R  dan disimpan dalam bentuk  hexa  bertipe data integer   public static final int btn_calculate=0x7f0b0057 . Acuan untuk menyusun tampilan pada relativelayout akan dibahas pada modul selanjutnya. Ukuran View Dalam menentukan tinggi dan lebar suatu View, terdapat beberapa alternatif value yang bisa digunakan seperti berikut. wrap_content : ukuran menyesuaikan dengan ukuran konten di dalamnya. match_parent : ukurang menyesuaikan dengan ukuran parent (View induknya). Apabila di paling luar, berarti mengikuti ukuran layar device-nya. fixed size : Anda bisa menentukan ukuran dengan nilai tetap dengan satuan dp.   Jadi, selain dp, ternyata juga ada satuan ukuran yang lain. Apa saja itu? Mari kita simak satu per satu. sp (scale independent pixel) Digunakan untuk ukuran teks, tetapi diskalakan berdasarkan preferensi ukuran font pengguna. dp (density independent pixel) Digunakan untuk semuanya selain ukuran teks. px Sesuai dengan piksel sebenarnya di layar. Penggunaannya tidak disarankan karena dapat menghasilkan ukuran yang berbeda. Supaya dapat memahami perbedaan dari penggunaan px, perhatikan ilustrasi berikut. Perhatikan bahwa ketika menggunakan px, bisa menampilkan ukuran yang berbeda pada ukuran layar yang berbeda. Sebagai contoh di sini pada layar hdpi seperti ponsel dan xxhdpi pada tablet. Untuk itulah penggunaan px sebaiknya dihindari. Pembahasan tentang Logika Kode Kode logika dituliskan ke dalam kelas Java atau Koltin. Di sinilah semua aktifitas dari suatu aplikasi berjalan. Activity Kotlin class MainActivity :  AppCompatActivity() Java public class MainActivity extends  AppCompatActivity  Menandakan bahwa kelas Java / Kotlin di atas merupakan sebuah activity   karena  inherit  ke  superclass  bernama  AppCompatActivity .  AppCompatActivity merupakan kelas dasar yang mengatur fungsi dasar Activity supaya bisa tetap berja";Codelab ini bertujuan untuk mengimplementasikan komponen Activity dalam aplikasi pertama, dengan membuat aplikasi penghitung volume balok. Aplikasi ini melibatkan input dari pengguna melalui EditText, validasi input, dan perhitungan volume balok ketika tombol Hitung ditekan. Proyek dimulai dengan membuat aplikasi baru di Android Studio menggunakan template Empty Activity, kemudian mengubah layout menjadi LinearLayout dan menambahkan komponen seperti EditText, Button, dan TextView. Setelah itu, kode logika ditulis di MainActivity untuk menangani input, perhitungan volume, dan menampilkan hasilnya.
"Teori Intent Intent adalah mekanisme untuk melakukan sebuah  action  dan komunikasi antar komponen aplikasi misal Activity, Service, dan Broadcast Receiver. Ada tiga penggunaan umum intent   dalam aplikasi Android yaitu: Memindahkan satu activity   ke activity   lain dengan atau tidak membawa data. Menjalankan background service,   misalnya melakukan sinkronisasi ke server dan menjalankan proses berulang ( periodic / scheduler   task ). Mengirimkan obyek broadcast ke aplikasi yang membutuhkan. Misal, ketika aplikasi membutuhkan proses menjalankan sebuah background service setiap kali aplikasi selesai melakukan  booting . Aplikasi harus bisa menerima obyek  broadcast  yang dikirimkan oleh sistem Android untuk  event   booting  tersebut. Intent memiliki dua bentuk yaitu: Explicit   Intent Adalah tipe Intent   yang digunakan untuk menjalankan komponen lain dengan tujuan yang sudah jelas atau eksplisit. Umumnya Intent ini digunakan untuk berpindah ke Activity lain pada satu aplikasi. Misalnya dari MainActivity menuju ke DetailActivity. Explicit   intent   bekerja dengan memanfaatkan context dari Activity asal dan nama Activity yang dituju. Berikut adalah contoh kode dari gambaran Explicit Intent di atas: Kotlin val moveIntent = Intent(this@MainActivity, DetailActivity::class.java) startActivity(moveIntent) Java Intent moveIntent = new Intent(MainActivity.this, DetailActivity.class); startActivity(moveIntent); Dengan memanggil fungsi startActivity berisi Intent, aplikasi akan langsung membuka Activity tersebut tanpa memberikan opsi lain. Implicit Intent Adalah tipe intent   yang tidak memerlukan detail nama kelas yang ingin diaktifkan. Model ini memungkinkan komponen dari aplikasi lain bisa merespon  request  intent yang dijalankan. Penggunaan tipe Intent   ini umumnya diperuntukan untuk menjalankan fitur/fungsi dari komponen aplikasi lain. Contohnya ketika kita membutuhkan fitur untuk mengambil foto. Daripada membuat sendiri fungsi kamera, lebih baik kita menyerahkan proses tersebut pada aplikasi kamera bawaan dari peranti atau aplikasi kamera lain yang telah terinstal sebelumnya di peranti. Hal yang sama misalnya ketika kita membutuhkan fungsi berbagi konten. Kita bisa memanfaatkan intent untuk menampilkan aplikasi mana saja yang bisa menangani fitur tersebut. Implementasi implicit   intent   ini akan sangat memudahkan bagi pengembang agar tetap fokus pada proses bisnis inti dari aplikasi yang dikembangkan. Lalu mengapa disebut Implicit Intent? Hal ini karena tujuannya masih belum jelas (implicit), misalnya Anda ingin membuka gallery. Maka pilihannya yaitu Anda bisa menggunakan default gallery atau menggunakan Google Photos. Jika ada aplikasi lainnya yang bisa menangani aksi ini, maka aplikasi itu pun akan muncul. Berikut adalah contoh kode dari gambaran Implicit Intent di atas: Kotlin private val launcherIntentGallery = registerForActivityResult(    ActivityResultContracts.StartActivityForResult() ) { result ->     }  val intent = Intent(Intent.ACTION_GET_CONTENT) intent.type = ""image/*"" launcherIntentGallery.launch(Intent.createChooser(intent, ""Choose a Picture"")) Java ActivityResultLauncher<Intent> launcherIntentGallery = registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), new ActivityResultCallback<ActivityResult>() {     @Override     public void onActivityResult(ActivityResult result) {              } });  Intent intent = new Intent(Intent.ACTION_GET_CONTENT); intent.setType(""image/*""); launcherIntentGallery.launch(Intent.createChooser(intent, ""Choose a Picture"")); Baca dan pahami materi pada link berikut ini:  Developer Coaching : Navigasi Antar Halaman dengan Menggunakan Intent Intent Intent Filter";Intent dalam Android adalah mekanisme untuk berkomunikasi antar komponen aplikasi, seperti Activity, Service, dan Broadcast Receiver. Ada dua jenis Intent: Explicit Intent, yang digunakan untuk berpindah antar Activity dalam aplikasi yang sama dengan menyebutkan nama Activity tujuan secara jelas, dan Implicit Intent, yang memungkinkan aplikasi untuk berinteraksi dengan aplikasi lain tanpa menyebutkan nama komponen secara eksplisit, seperti membuka galeri atau mengambil foto dengan aplikasi lain. Intent juga digunakan untuk menjalankan background service atau mengirimkan broadcast untuk event tertentu, seperti booting perangkat.
"Latihan Explicit Intent  Tujuan Codelab  ini menitikberatkan pada implementasi intent   untuk melakukan perpindahan dari Activity   ke Activity lain, dengan atau tidak membawa data. Beberapa bagian dari  codelab  ini akan menjawab beberapa pertanyaan umum dalam pengembangan aplikasi Android sebagai berikut: Bagaimana berpindah dari satu Activity   ke Activity   lain? Bagaimana berpindah dari satu Activity   ke Activity   lain dengan membawa data? Single value  dari suatu variabel. Obyek model dengan menggunakan Parcelable. Menjalankan komponen di aplikasi lain untuk keperluan membuka  browser  atau melakukan pemanggilan melalui aplikasi telepon bawaan? Mengirimkan hasil nilai balik melalui Intent. Codelab  selanjutnya adalah dengan membuat aplikasi yang dapat menerapakan kegunaan intent. Seperti ini tampilannya: Alur Latihan Berikut alur yang akan kita pelajari dalam latihan ini:   Berpindah antar Activity menggunakan  Explicit  Intent. Mengirim data pada Intent menggunakan  putExtra . Mengirim banyak data pada Intent menggunakan  Parcelable . Berpindah antar aplikasi menggunakan  Implicit Intent . Mendapatkan hasil dari Activity tujuan menggunakan  registerForActivityResult . Codelab Explicit Intent  Ikuti alur berikut untuk mengerjakan latihan ini:  Buat Project baru di Android Studio dengan kriteria sebagai berikut: Nama Project MyIntentApp Target & Minimum Target SDK Phone and Tablet, API level 21 Tipe Activity Empty Activity Activity Name MainActivity Use AndroidX artifacts True Language Kotlin / Java Selanjutnya kita akan membangun antarmuka ( interface ) seperti ini: Kondisikan  activity_main.xml  menjadi seperti ini: <?xml version=""1.0"" encoding=""utf-8""?> < LinearLayout  xmlns:android=""http://schemas.android.com/apk/res/android""     xmlns:tools=""http://schemas.android.com/tools""     android:layout_width=""match_parent""     android:layout_height=""match_parent""      android:orientation=""vertical""       android:padding=""16dp"" >       <Button         android:id=""@+id/btn_move_activity""         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:layout_marginBottom=""16dp""         android:text=""@string/move_activity"" />  </ LinearLayout > Tambahkan juga  resource  string-nya. Tambahkan semua string yang akan digunakan di  project  ini. Buka berkas  strings.xml dan tambahkan kode berikut ini: <resources>     <string name=""app_name"">MyIntentApp</string>      <string name=""move_activity"">Pindah Activity</string>     <string name=""move_with_data"">Pindah Activity dengan Data</string>     <string name=""move_with_object"">Pindah Activity dengan Object</string>     <string name=""dial_number"">Dial a Number</string>     <string name=""move_with_result"">Pindah Activity untuk Result</string>     <string name=""result_from_activity"">Hasil dari Activity</string>     <string name=""choose_number"">Pilih angka yang kamu suka</string>     <string name=""_50"">50</string>     <string name=""_100"">100</string>     <string name=""_150"">150</string>     <string name=""_200"">200</string>     <string name=""choose"">Pilih</string>     <string name=""data_received"">Data Diterima</string>     <string name=""object_received"">Object Diterima</string>     <string name=""this_is_moveactivity"">Ini MoveActivity</string>  </resources> Kemudian masuk ke  MainActivity ,   tambahkan beberapa baris kode yang berfungsi untuk meperkenalkan  button  yang sudah ditambahkan di layout seperti ini: Kotlin override fun onCreate(savedInstanceState: Bundle?) {     super.onCreate(savedInstanceState)     setContentView(R.layout.activity_main)       val btnMoveActivity: Button = findViewById(R.id.btn_move_activity)  } Java @Override protected void onCreate(Bundle savedInstanceState) {     super.onCreate(savedInstanceState);     setContentView(R.layout.activity_main);       Button btnMoveActivity  = findViewById(R.id.btn_move_activity);  } Lalu   tambahkan beberapa baris yang berfungsi untuk menambahkan event  onClick  pada button  btnMoveActivity seperti ini: Kotlin class MainActivity : AppCompatActivity() , View.OnClickListener  {      override fun onCreate(savedInstanceState: Bundle?) {         super.onCreate(savedInstanceState)         setContentView(R.layout.activity_main)          val btnMoveActivity: Button = findViewById(R.id.btn_move_activity)          btnMoveActivity.setOnClickListener(this)      }       override fun onClick(v: View?) {         when (v?.id) {             R.id.btn_move_activity -> {             }         }     }  } Java public class MainActivity extends AppCompatActivity  implements View.OnClickListener  {      @Override     protected void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout.activity_main);          Button btnMoveActivity = findViewById(R.id.btn_move_activity);          btnMoveActivity.setOnClickListener(this);      }       @ Override       public void onClick(View v) {          if (v.getId() == R.id.btn_move_activity) {                      }     }  } Button  btnMoveActivity   akan memiliki fungsi untuk berpindah Activity   ke Activity   lain. Sekarang kita buat Activity   baru dengan cara sebagai berikut:  k lik kanan  di package utama aplikasi  package name → New → Activity → Empty Activity . Lalu isikan  MoveActivity   pada dialog. Ketika sudah klik  Finish . Catatan: Untuk bahasa menyesuaikan dengan bahasa yang digunakan ketika pertama kali membuat project. Untuk menandakan bahwa perpindahan Activity   berhasil, silakan tambahkan satu  TextView  dan kondisikan  activity_move.xml   menjadi seperti berikut: < RelativeLayout  xmlns:android=""http://schemas.android.com/apk/res/android""     xmlns:tools=""http://schemas.android.com/tools""     android:layout_width=""match_parent""     android:layout_height=""match_parent""      android:padding=""16dp""      tools:context="".MoveActivity"">       <TextView         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:text=""@string/this_is_moveactivity"" />  </ RelativeLayout >   Setelah activity   tujuan sudah berhasil diciptakan, sekarang saatnya menambahkan suatu intent   pada  method  onClick()  di  MainActivity  menjadi sebagai berikut: Kotlin override fun onClick(v: View?) {     when (v?.id) {         R.id.btn_move_activity -> {              val moveIntent = Intent(this@MainActivity, MoveActivity::class.java)             startActivity(moveIntent)          }     } } Java @Override public void onClick(View v) {     if (v.getId() == R.id.btn_move_activity) {          Intent moveIntent = new Intent(MainActivity.this, MoveActivity.class);         startActivity(moveIntent);      } } Selesai! Langkah pertama untuk memindahkan satu activity   ke activity   lain sudah selesai, sekarang silakan jalankan aplikasi Anda dengan mengklik tombol pada menu bar. Seharusnya sekarang anda sudah bisa memindahkan activity   dengan mengklik tombol  Pindah Activity . Bedah Kode Register Activity Kita telah belajar bagaimana membuat suatu activity   baru. Di materi sebelumnya, syarat suatu activity   haruslah terdaftar pada berkas  AndroidManifest.xml . Karena menggunakan Android Studio, proses pendaftaran tersebut dilakukan secara otomatis. <?xml version=""1.0"" encoding=""utf-8""?> <manifest xmlns:android=""http://schemas.android.com/apk/res/android""     package=""com.dicoding.picodiploma.myintentapp"">      <application         android:allowBackup=""true""         android:icon=""@mipmap/ic_launcher""         android:label=""@string/app_name""         android:supportsRtl=""true""         android:theme=""@style/AppTheme"">         <activity android:name="".MainActivity"">             <intent-filter>                 <action android:name=""android.intent.action.MAIN"" />                  <category android:name=""android.intent.category.LAUNCHER"" />             </intent-filter>         </activity>          <activity android:name="".MoveActivity"" />      </application>  </manifest> Perhatikan bahwa  MoveActivity  sudah teregistrasi di  AndroidManifest.xml . Sekarang sudah aman jika kita melakukan perpindahan activity   dari  MainActivity  ke  MoveActivity . Jika kita lupa meregistrasikan Activity   baru ke dalam berkas  AndroidManifest.xml , maka akan terjadi eror seperti ini  android.content.ActivityNotFoundException:Unable to find explicit activity class . Intent Filter Berikutnya, perhatikan pada kode dengan  tag   intent-filter  yang ada di dalam  AndroidManifest  pada bagian MainActivity. <activity android:name="".MainActivity"">     <intent-filter>         <action android:name=""android.intent.action.MAIN"" />         <category android:name=""android.intent.category.LAUNCHER"" />     </intent-filter> </activity> Intent-filter merupakan mekanisme untuk menentukan bagaimana suatu activity   dijalankan oleh  Android Runtime  (ART) atau  Dalvik Virtual Machine  (DVM). <action android:name=""android.intent.action.MAIN"" /> Baris di atas bermakna bahwa  MainActivity  menjadi  entry point  ke aplikasi. <category android:name=""android.intent.category.LAUNCHER"" /> Kode di atas menandakan bahwa  MainActivity  akan dikategorikan sebagai  activity   launcher .  Ini menandakan bahwa activity ini akan muncul di halaman  home screen  dalam bentuk  launcher . Pindah Activity Selanjutnya, perhatikan kode berikut: Kotlin val moveIntent = Intent(this@MainActivity, MoveActivity::class.java)  startActivity(moveIntent) Java Intent moveIntent = new Intent(MainActivity.this, MoveActivity.class);  startActivity(moveIntent); Kita membuat suatu obyek intent   dengan cara seperti di atas dengan memberikan context ( this@MainActivity )  dan kelas activity   tujuan ( MoveActivity::class.java ) pada konstruktor kelas intent. Untuk context dapat menggunakan  this   yang menandakan obyek kelas saat ini. Sedangkan kelas tujuan selalu diakhiri dengan menggunakan  class . Jika kita menggunakan  code assistant  ( tekan ctrl + spasi )   dari Android Studio, maka akan tampil rekomendasi ( code hint ) sebagai berikut: Pada konteks di atas kita memilih  packageContext:  Context  , cls:  Class<*>  sebagai inputan untuk nilai  constructor  intent. Context  adalah sebuah kelas yang digunakan untuk mengakses  resource  dari activity tersebut. anda akan sering membutuhkan context pada latihan-latihan selanjutnya, seperti saat mengambil data dari  resource , mengakses  SystemService , mendapatkan  ApplicationInfo  dan lain sebagainya. Untuk lebih jelasnya anda bisa membaca artikel berikut: Context Kemudian perhatikan baris kode berikutnya. Kotlin val moveIntent = Intent(this@MainActivity, MoveActivity::class.java)  startActivity(moveIntent) Java Intent moveIntent = new Intent(MainActivity.this, MoveActivity.class);  startActivity(moveIntent); Metode   startActivity(moveIntent)   akan menjalankan activity   baru tanpa membawa data. Obyek intent   yang diinputkan adalah obyek  moveIntent   yang ketika kode ini dijalankan maka akan membuka MoveActivity. Pada modul ini kita telah berhasil memindahkan satu Activity ke Activity lain dengan tidak membawa data. Pada bagian selanjutnya kita akan membuat suatu intent yang di dalamnya akan membawa data ke Activity tujuan.";Codelab ini mengajarkan cara menggunakan Explicit Intent untuk berpindah antar Activity di aplikasi Android, baik dengan maupun tanpa data. Langkah-langkahnya meliputi pembuatan project baru, penambahan tombol untuk berpindah Activity, pembuatan Activity baru, dan penggunaan Intent untuk memindahkan data. Dalam contoh ini, kita menggunakan Intent untuk berpindah dari MainActivity ke MoveActivity dan juga belajar cara mengirim data melalui putExtra atau objek yang dipassing menggunakan Parcelable. Selain itu, kita juga akan mempelajari cara berinteraksi dengan aplikasi lain menggunakan Implicit Intent dan mendapatkan hasil dari Activity menggunakan registerForActivityResult.
"Latihan Mengirim Data pada Intent Selanjutnya kita akan membuat sebuah Intent yang di dalamnya akan membawa data ke Activity tujuan. Siaap?  Buka   activity_main.xml , kemudian tambahkan satu tombol lagi di bawah tombol sebelumnya. Kode  activity_main.xml  akan jadi seperti ini: <?xml version=""1.0"" encoding=""utf-8""?> <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""     xmlns:tools=""http://schemas.android.com/tools""     android:layout_width=""match_parent""     android:layout_height=""match_parent""     android:orientation=""vertical""     android:padding=""16dp"">      ......       <Button         android:id=""@+id/btn_move_activity_data""         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:layout_marginBottom=""16dp""         android:text=""@string/move_with_data"" />   </LinearLayout> Setelah selesai dengan penambahan pada berkas  activity_main.xml , maka lanjutkan dengan menambahkan beberapa baris berikut di  MainActivity . Kotlin class MainActivity : AppCompatActivity(), View.OnClickListener {      override fun onCreate(savedInstanceState: Bundle?) {         super.onCreate(savedInstanceState)         setContentView(R.layout.activity_main)          ...           val btnMoveWithDataActivity: Button = findViewById(R.id.btn_move_activity_data)         btnMoveWithDataActivity.setOnClickListener(this)      }      override fun onClick(v: View) {         when (v.id) {             R.id.btn_move_activity -> {                 val moveIntent = Intent(this@MainActivity, MoveActivity::class.java)                 startActivity(moveIntent)             }               R.id.btn_move_activity_data -> {                }          }     } } Java public class MainActivity extends AppCompatActivity implements View.OnClickListener{     @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout. activity_main );         ....          Button btnMoveWithDataActivity = findViewById(R.id. btn_move_activity_data );        btnMoveWithDataActivity.setOnClickListener(this);     }     @Override    public void onClick(View v) {        if (v.getId() == R.id.btn_move_activity) {             Intent moveIntent = new Intent(MainActivity.this, MoveActivity.class);             startActivity(moveIntent);         }  else if (v.getId() == R.id.btn_move_activity_data) {                      }      } } Selanjutnya, buat Activity baru lagi seperti cara sebelumnya dan beri nama  MoveWithDataActivity . Lalu pada layout  activity_move_with_data.xml kita tambahkan sebuah TextView untuk menampilkan data yang dikirimkan dari Activity asal. <?xml version=""1.0"" encoding=""utf-8""?> <RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android""     xmlns:tools=""http://schemas.android.com/tools""     android:layout_width=""match_parent""     android:layout_height=""match_parent""     android:padding=""16dp"">      <TextView         android:id=""@+id/tv_data_received""         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:text=""@string/data_received"" />  </RelativeLayout> Selanjutnya pada  MoveWithDataActivity ,  kita inisialisasi TextView seperti berikut ini: Kotlin class MoveWithDataActivity : AppCompatActivity() {      override fun onCreate(savedInstanceState: Bundle?) {         super.onCreate(savedInstanceState)         setContentView(R.layout.activity_move_with_data)           val tvDataReceived: TextView = findViewById(R.id.tv_data_received)      } } Java public class MoveWithDataActivity extends AppCompatActivity {      @Override     protected void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout.activity_move_with_data);           TextView tvDataReceived = findViewById(R.id.tv_data_received);       } } Selanjutnya untuk menerima data dari Activity asal, ambil data dari Intent berdasarkan key dan tampilkan ke dalam TextView seperti berikut: Kotlin class MoveWithDataActivity : AppCompatActivity() {       companion object {         const val EXTRA_AGE = ""extra_age""         const val EXTRA_NAME = ""extra_name""     }       override fun onCreate(savedInstanceState: Bundle?) {         super.onCreate(savedInstanceState)         setContentView(R.layout.activity_move_with_data)          val tvDataReceived: TextView = findViewById(R.id.tv_data_received)           val name = intent.getStringExtra(EXTRA_NAME)         val age = intent.getIntExtra(EXTRA_AGE, 0)          val text = ""Name : $name, Your Age : $age""         tvDataReceived.text = text      } } Java public class MoveWithDataActivity extends AppCompatActivity {      public static final String EXTRA_AGE = ""extra_age"";     public static final String EXTRA_NAME = ""extra_name"";       @Override     protected void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout.activity_move_with_data);            TextView tvDataReceived = findViewById(R.id.tv_data_received);           String name = getIntent().getStringExtra(EXTRA_NAME);         int age = getIntent().getIntExtra(EXTRA_AGE, 0);          String text = ""Name : "" + name + "", Your Age : "" + age;         tvDataReceived.setText(text);      } } Dan sekarang saatnya kita menambahkan data pada Intent menggunakan  putExtra  di dalam  MainActivity seperti baris yang ditebalkan. Kotlin override fun onClick(v: View) {     when (v.id) {         R.id.btn_move_activity -> {             val moveIntent = Intent(this@MainActivity, MoveActivity::class.java)             startActivity(moveIntent)         }           R.id.btn_move_activity_data -> {             val moveWithDataIntent = Intent(this@MainActivity, MoveWithDataActivity::class.java)             moveWithDataIntent.putExtra(MoveWithDataActivity.EXTRA_NAME, ""DicodingAcademy Boy"")             moveWithDataIntent.putExtra(MoveWithDataActivity.EXTRA_AGE, 5)             startActivity(moveWithDataIntent)         }      } } Java @Override public void onClick(View v) {     if (v.getId() == R.id.btn_move_activity) {         Intent moveIntent = new Intent(MainActivity.this, MoveActivity.class);         startActivity(moveIntent);     } else if (v.getId() == R.id.btn_move_activity_data) {          Intent moveWithDataIntent = new Intent(MainActivity.this, MoveWithDataActivity.class);         moveWithDataIntent.putExtra(MoveWithDataActivity.EXTRA_NAME, ""DicodingAcademy Boy"");         moveWithDataIntent.putExtra(MoveWithDataActivity.EXTRA_AGE, 5);         startActivity(moveWithDataIntent);      } } Maka  MainActivity  akan jadi seperti ini: Kotlin class MainActivity : AppCompatActivity(), View.OnClickListener {      override fun onCreate(savedInstanceState: Bundle?) {         super.onCreate(savedInstanceState)         setContentView(R.layout.activity_main)          val btnMoveActivity: Button = findViewById(R.id.btn_move_activity)         btnMoveActivity.setOnClickListener(this)          val btnMoveWithDataActivity: Button = findViewById(R.id.btn_move_activity_data)         btnMoveWithDataActivity.setOnClickListener(this)     }      override fun onClick(v: View) {         when (v.id) {             R.id.btn_move_activity -> {                 val moveIntent = Intent(this@MainActivity, MoveActivity::class.java)                 startActivity(moveIntent)             }              R.id.btn_move_activity_data -> {                 val moveWithDataIntent = Intent(this@MainActivity, MoveWithDataActivity::class.java)                 moveWithDataIntent.putExtra(MoveWithDataActivity.EXTRA_NAME, ""DicodingAcademy Boy"")                 moveWithDataIntent.putExtra(MoveWithDataActivity.EXTRA_AGE, 5)                 startActivity(moveWithDataIntent)             }         }     } }   Java public class MainActivity extends AppCompatActivity implements View.OnClickListener{      @Override     protected void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout.activity_main);          Button btnMoveActivity = findViewById(R.id.btn_move_activity);         btnMoveActivity.setOnClickListener(this);          Button btnMoveWithDataActivity = findViewById(R.id.btn_move_activity_data);         btnMoveWithDataActivity.setOnClickListener(this);     }      @Override     public void onClick(View v) {         if (v.getId() == R.id.btn_move_activity) {             Intent moveIntent = new Intent(MainActivity.this, MoveActivity.class);             startActivity(moveIntent);         } else if (v.getId() == R.id.btn_move_activity_data) {             Intent moveWithDataIntent = new Intent(MainActivity.this, MoveWithDataActivity.class);             moveWithDataIntent.putExtra(MoveWithDataActivity.EXTRA_NAME, ""DicodingAcademy Boy"");             moveWithDataIntent.putExtra(MoveWithDataActivity.EXTRA_AGE, 5);             startActivity(moveWithDataIntent);         }     } } Silakan jalankan aplikasi Anda, kemudian coba klik pada tombol  Pindah Activity dengan Data . Seharusnya Anda sudah bisa berpindah dari satu activity ke activity lain dengan membawa data. Bedah Kode Pada bagian sebelumnya Anda sudah mempelajari bagaimana berpindah dari satu activity ke activity lain dengan membawa data. Dan itu sangat penting karena ketika kita mengembangkan suatu aplikasi Android yang kompleks, akan ada banyak activity yang terlibat. Untuk memberikan pengalaman yang baik kepada pengguna, perpindahan Activity dengan data, sangat krusial. Put Extra Perhatikan kode di bawah ini: Kotlin val moveWithDataIntent = Intent(this@MainActivity, MoveWithDataActivity::class.java) moveWithDataIntent.putExtra(MoveWithDataActivity.EXTRA_NAME, ""DicodingAcademy Boy"") moveWithDataIntent.putExtra(MoveWithDataActivity.EXTRA_AGE, 5) startActivity(moveWithDataIntent) Java Intent moveWithDataIntent = new Intent(MainActivity.this, MoveWithDataActivity.class); moveWithDataIntent.putExtra(MoveWithDataActivity. EXTRA_NAME , ""DicodingAcademy Boy""); moveWithDataIntent.putExtra(MoveWithDataActivity. EXTRA_AGE , 5); startActivity(moveWithDataIntent); Perbedaan mendasar antara memindahkan Activity dengan membawa data atau tidak, adalah dengan menempatkan data ke obyek Intent pada baris ini. Kotlin moveWithDataIntent.putExtra(MoveWithDataActivity.EXTRA_NAME, ""DicodingAcademy Boy"") moveWithDataIntent.putExtra(MoveWithDataActivity.EXTRA_AGE, 5) Java moveWithDataIntent.putExtra(MoveWithDataActivity.EXTRA_NAME, ""DicodingAcademy Boy""); moveWithDataIntent.putExtra(MoveWithDataActivity.EXTRA_AGE, 5); Kita memanfaatkan metode  putExtra()  untuk mengirimkan data bersamaan dengan obyek  Intent . Sedangkan metode  putExtra()  itu sendiri merupakan metode yang menampung pasangan  key-value  dan memiliki beberapa pilihan tipe  input  seperti berikut: Hampir semua tipe data untuk  input value  didukung oleh metode  putExtra() . Kotlin moveWithDataIntent.putExtra(MoveWithDataActivity.EXTRA_NAME, ""DicodingAcademy Boy"") Java moveWithDataIntent.putExtra(MoveWithDataActivity.EXTRA_NAME, ""DicodingAcademy Boy""); Name MoveWithDataActivity.EXTRA_NAME   di mana  EXTRA_NAME  adalah variabel  static  bertipe data String dan bernilai  extra_name  pada  MoveWithDataActivity . Penentuan nilai untuk  key  parameter  untuk Intent adalah bebas, di sini kami merekomendasikan format terbaik yang biasa diimplementasikan. Value DicodingAcademy Boy dengan tipe data string. Get Data Setelah data dikirimkan, selanjutnya adalah mengambil data tersebut.  Di sini kita akan mengirimkan data bertipe string ke  MoveWithDataActivity . Di dalam  MoveWithdataActivity  kita akan mengambil nilai data berdasarkan  key  yang dikirimkan dengan menggunakan metode  getIntent().getStringExtra(key) . Implementasinya sebagai berikut: Kotlin val name = intent.getStringExtra( EXTRA_NAME ) Java String name = getIntent().getStringExtra( EXTRA_NAME ); Catatan  :  Key  yang dikirimkan melalui putExtra() harus sama dengan  key  sewaktu mengambil nilai dari data yang dikirimkan melalui getStringExtra(). Dalam konteks di atas,  key  yang digunakan untuk mengirim dan mengambil nilai data adalah sama, yaitu  EXTRA_NAME  (yang bernilai “extra_name”). Nilai dari data yang dikirimkan melalui Intent disimpan ke dalam variabel  name   bertipe data string. Fungsi dari  EXTRA_NAME   sendiri yaitu sebagai  Key . Seperti yang dijelaskan pada modul, untuk mengirim data dengan intent kita perlu mengirimnya dalam format  putExtra(Key,Value) . Dengan Key bertindak sebagai kunci yang dipakai untuk mengambil data di activity tujuannya, dan value adalah data yang akan dikirimkan. Jadi kalau bahasa gampangnya dalam bentuk dialog seperti ini: Kode   : ""Aku mau ambil data  nih ?"" Sistem : ""Data yang mana? Data  kan  banyak?"" Kode   : ""Yang key-nya ' EXTRA_NAME ' sis (red: sistem)"" Sistem : ""Ohh oke deh, ini data  value -nya"" Begitu juga dengan variable  age . Kotlin val age = intent.getIntExtra(EXTRA_AGE, 0) Java int age = getIntent().getIntExtra( EXTRA_AGE , 0); Nilai dari variabel  age  yang bertipe data integer berasal dari  getIntent().getIntExtra(Key, nilai default) .   Key  yang digunakan untuk mengirimkan dan mengambil data adalah  EXTRA_AGE  (yang bernilai “extra_age”). Nilai  default  di sini merupakan nilai yang akan digunakan jika ternyata datanya kosong. Data kosong atau nilainya  null  bisa terjadi ketika datanya memang tidak ada, atau  key -nya tidak sama.   Selamat! Anda telah mempelajari dua Explicit Intent dengan atau tidak membawa data.  Sebelumnya, mengirimkan data bernilai tunggal dari satu Activity ke Activity lain adalah hal yang mudah. Bernilai tunggal karena data yang dikirimkan berasal dari satu tipe data. Misalnya pada contoh di atas, pengiriman nilai data  name  dan  age  dilakukan secara individu. Yang satu bertipe data string dan yang lainnya bertipe data integer.  Sekarang pertanyaanya bagaimana Anda bisa mengirimkan banyak data sekaligus (misal 20 data atau 200 data) dari satu Activity ke Activity lain melalui intent? Apakah harus menambahkan putExtra satu per satu? Tenang, ada cara yang lebih mudah untuk melakukannya, yaitu dengan menggunakan kelas model yang terimplementasi  parcelable . Penasaran bagaimana caranya? Yuk kita lanjut ke materi berikutnya!";Pada tutorial ini, Anda akan belajar mengirim data antar Activity menggunakan Intent di Android. Pertama, tambahkan tombol baru di activity_main.xml untuk memindahkan data ke Activity lain. Kemudian, di MainActivity, buat Intent dengan metode putExtra() untuk mengirim data seperti nama dan umur ke MoveWithDataActivity. Di MoveWithDataActivity, ambil data menggunakan getStringExtra() dan getIntExtra() untuk menampilkan data tersebut di TextView. Data yang dikirimkan dapat berupa berbagai tipe data dengan menggunakan key-value pasangan.
"Latihan Implicit Intent Anda sudah belajar bagaimana menggunakan Intent dengan tipe eksplisit. Sekarang saatnya Anda melanjutkan ke Intent dengan tipe implisit.  Buka kembali  activity_main.xml   dan   tambahkan satu tombol lagi di bagian bawah seperti berikut: <Button     android:id=""@+id/btn_dial_number""     android:layout_width=""match_parent""     android:layout_height=""wrap_content""     android:layout_marginBottom=""16dp""     android:text=""@string/dial_number"" /> Sehingga berkas  activity_main.xml  kita sekarang menjadi: <?xml version=""1.0"" encoding=""utf-8""?> <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""     xmlns:tools=""http://schemas.android.com/tools""     android:layout_width=""match_parent""     android:layout_height=""match_parent""     android:orientation=""vertical""     android:padding=""16dp"">      <Button         android:id=""@+id/btn_move_activity""         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:layout_marginBottom=""16dp""         android:text=""@string/move_activity"" />      <Button         android:id=""@+id/btn_move_activity_data""         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:layout_marginBottom=""16dp""         android:text=""@string/move_with_data"" />      <Button         android:id=""@+id/btn_move_activity_object""         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:layout_marginBottom=""16dp""         android:text=""@string/move_with_object"" />       <Button         android:id=""@+id/btn_dial_number""         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:layout_marginBottom=""16dp""         android:text=""@string/dial_number"" />   </LinearLayout> Sekarang, buka kembali  MainActivity  dan lanjutkan inisialisasi Button yang sudah ditambahkan Kotlin override fun onCreate(savedInstanceState: Bundle?) {     super.onCreate(savedInstanceState)     setContentView(R.layout.activity_main)      ...       val btnDialPhone:Button = findViewById(R.id.btn_dial_number)     btnDialPhone.setOnClickListener(this)   } Java @Override protected void onCreate(Bundle savedInstanceState) {     super.onCreate(savedInstanceState);     setContentView(R.layout.activity_main);      ...       Button  btnDialPhone = findViewById(R.id.btn_dial_number);     btnDialPhone.setOnClickListener(this);  } Selanjutnya, buat Implicit Intent dengan menambahkan  action  dan data yang dikirimkan. Kotlin override fun onClick(v: View) {     when (v.id) {                 ...           R.id.btn_dial_number -> {             val phoneNumber = ""081210841382""             val dialPhoneIntent = Intent(Intent.ACTION_DIAL, Uri.parse(""tel:$phoneNumber""))             startActivity(dialPhoneIntent)          }     } } Java @Override public void onClick(View v) {     ...     }  e lse if (v.getId() == R.id.btn_dial_number) {         String phoneNumber = ""081210841382"";         Intent dialPhoneIntent = new Intent(Intent.ACTION_DIAL, Uri.parse(""tel:"" + phoneNumber));         startActivity(dialPhoneIntent);     }  } Sehingga kode keseluruhan untuk kelas  MainActivity  saat ini adalah: Kotlin class MainActivity : AppCompatActivity(), View.OnClickListener {      override fun onCreate(savedInstanceState: Bundle?) {         super.onCreate(savedInstanceState)         setContentView(R.layout.activity_main)          val btnMoveActivity:Button = findViewById(R.id.btn_move_activity)         btnMoveActivity.setOnClickListener(this)          val btnMoveWithDataActivity:Button = findViewById(R.id.btn_move_activity_data)         btnMoveWithDataActivity.setOnClickListener(this)          val btnMoveWithObject:Button = findViewById(R.id.btn_move_activity_object)         btnMoveWithObject.setOnClickListener(this)           val btnDialPhone:Button = findViewById(R.id.btn_dial_number)         btnDialPhone.setOnClickListener(this)      }      override fun onClick(v: View) {         when (v.id) {             R.id.btn_move_activity -> {                 val moveIntent = Intent(this@MainActivity, MoveActivity::class.java)                 startActivity(moveIntent)             }              R.id.btn_move_activity_data -> {                 val moveWithDataIntent = Intent(this@MainActivity, MoveWithDataActivity::class.java)                 moveWithDataIntent.putExtra(MoveWithDataActivity.EXTRA_NAME, ""DicodingAcademy Boy"")                 moveWithDataIntent.putExtra(MoveWithDataActivity.EXTRA_AGE, 5)                 startActivity(moveWithDataIntent)             }              R.id.btn_move_activity_object -> {                 val person = Person(                         ""DicodingAcademy"",                         5,                         ""academy@dicoding.com"",                         ""Bandung""                 )                  val moveWithObjectIntent = Intent(this@MainActivity, MoveWithObjectActivity::class.java)                 moveWithObjectIntent.putExtra(MoveWithObjectActivity.EXTRA_PERSON, person)                 startActivity(moveWithObjectIntent)             }               R.id.btn_dial_number -> {                 val phoneNumber = ""081210841382""                 val dialPhoneIntent = Intent(Intent.ACTION_DIAL, Uri.parse(""tel:$phoneNumber""))                 startActivity(dialPhoneIntent)             }          }     } } Java public class MainActivity extends AppCompatActivity implements View.OnClickListener{      @Override     protected void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout.activity_main);          Button btnMoveActivity = findViewById(R.id.btn_move_activity);         btnMoveActivity.setOnClickListener(this);          Button btnMoveWithDataActivity = findViewById(R.id.btn_move_activity_data);         btnMoveWithDataActivity.setOnClickListener(this);          Button   btnMoveWithObject = findViewById(R.id.btn_move_activity_object);         btnMoveWithObject.setOnClickListener(this);           Button  btnDialPhone = findViewById(R.id.btn_dial_number);         btnDialPhone.setOnClickListener(this);      }      @Override     public void onClick(View v) {         if (v.getId() == R.id.btn_move_activity) {             Intent moveIntent = new Intent(MainActivity.this, MoveActivity.class);             startActivity(moveIntent);         } else if (v.getId() == R.id.btn_move_activity_data) {             Intent moveWithDataIntent = new Intent(MainActivity.this, MoveWithDataActivity.class);             moveWithDataIntent.putExtra(MoveWithDataActivity.EXTRA_NAME, ""DicodingAcademy Boy"");             moveWithDataIntent.putExtra(MoveWithDataActivity.EXTRA_AGE, 5);             startActivity(moveWithDataIntent);         } else if (v.getId() == R.id.btn_move_activity_object) {             Person person = new Person();             person.setName(""DicodingAcademy"");             person.setAge(5);             person.setEmail(""academy@dicoding.com"");             person.setCity(""Bandung"");              Intent moveWithObjectIntent = new Intent(MainActivity.this, MoveWithObjectActivity.class);             moveWithObjectIntent.putExtra(MoveWithObjectActivity.EXTRA_PERSON, person);             startActivity(moveWithObjectIntent);         }  else if (v.getId() == R.id.btn_dial_number) {             String phoneNumber = ""081210841382"";             Intent dialPhoneIntent = new Intent(Intent.ACTION_DIAL, Uri.parse(""tel:"" + phoneNumber));             startActivity(dialPhoneIntent);         }      } } Setelah selesai, jalankanlah kembali aplikasi Anda.  Yeay , Anda sudah bisa men- dial  sebuah nomor telepon melalui aplikasi bawaan dari peranti Anda. Selamat! Bedah Kode Implicit Intent  Kotlin val phoneNumber = ""081210841382"" val dialPhoneIntent = Intent(Intent.ACTION_DIAL, Uri.parse(""tel:$phoneNumber"")) startActivity(dialPhoneIntent) Java String phoneNumber = ""081210841382""; Intent dialPhoneIntent = new Intent(Intent. ACTION_DIAL , Uri. parse (""tel:""+phoneNumber)); startActivity(dialPhoneIntent); Baru saja kita mengimplementasikan penggunaan intent secara implicit untuk melakukan proses  dial  sebuah nomor telepon. Pada bagian  Intent(Intent.ACTION_DIAL, Uri.parse(""tel:""+phoneNumber)) ,  kita menggunakan inputan Intent(ACTION, Uri)   pada konstruktor sewaktu menciptakan objek Intent di mana: Action            : Intent.ACTION_DIAL Uri                  : Uri.parse(""tel:""+phoneNumber) Variabel  ACTION_DIAL  menentukan intent filter dari aplikasi-aplikasi yang bisa menangani  action  tersebut. Di sini aplikasi yang memiliki kemampuan untuk komunikasi akan muncul pada opsi pilihan, sebagaimana ditampilkan ke pengguna.  Selain  ACTION_DIAL , di Android sudah tersedia berbagai action yang tinggal didefinisikan sewaktu menciptakan objek Intent untuk mengakomodir berbagai tujuan.  Silakan cek tautan berikut untuk detailnya: Intent Apa itu URI (Uniform Resource Identifier) Jika Anda belum memahami apa itu Uri, berikut penjelasan singkatnya: Uri adalah sebuah untaian karakter yang digunakan untuk mengidentifikasi nama, sumber, atau layanan di internet sesuai dengan RFC 2396. Pada Uri.parse(""tel:""+phoneNumber), kita melakukan  parsing  uri dari bentuk teks string menjadi sebuah objek uri dengan menggunakan metode  static  parse(String).   Secara struktur ia terbagi menjadi: Di mana  tel  adalah sebuah skema yang disepakati untuk sumber daya telepon dan phoneNumber adalah variabel string yang bernilai  081210841382 . Skema lain dari Uri seperti  geo  untuk peta,  http  untuk browser sisanya bisa dilihat di halaman ini: Common Intents Kumpulan Kode Intent   Proses Implicit Intent Pada prosesnya, pemanggilan intent secara implicit akan berjalan sesuai dengan diagram di bawah ini: Aplikasi kita menjalankan intent untuk  ACTION_DIAL  melalui startActivity() . Sistem Android akan melakukan seleksi terhadap semua aplikasi yang memiliki kemampuan untuk menangani action tersebut. Sistem Android akan menentukan aplikasi mana saja yang bisa memproses action berdasarkan intent filter yang telah ditentukan di berkas  AndroidManifest.xml  pada masing-masing aplikasi. Sistem Android akan menampilkan opsi aplikasi-aplikasi mana saja yang bisa menangani action tersebut ke pengguna. Pengguna memilih salah satu opsi aplikasi dan kemudian sistem Android akan me- routing  ke activity pada aplikasi yang dipilih yang memiliki intent-filter untuk aksi  ACTION_DIAL . Aplikasi yang dipilih pun muncul di layar dengan nomor telepon yang sudah diatur. Anda sudah mempelajari 3 buah intent secara  explicit  dan 1 buah intent secara  implicit . Selamat! Selanjutnya, kita akan membuat sebuah Intent yang didalamnya akan membawa data dengan  ResultActivity . Tentu Anda penasaran, bukan? Yuk kita melangkah lag!";"Anda akan menambahkan tombol baru di activity_main.xml untuk melakukan panggilan telepon melalui aplikasi dialer menggunakan implicit intent. Dengan membuat Intent dengan aksi ACTION_DIAL dan mengirimkan nomor telepon melalui Uri.parse(""tel:081210841382""), aplikasi akan memicu sistem untuk memilih aplikasi yang bisa menangani aksi tersebut dan menampilkan dialer dengan nomor yang sudah ditentukan."
"Teori Pada modul ini, Anda akan mempelajari komponen View dan ViewGroup. Kedua komponen ini dapat berkolaborasi sehingga membentuk antarmuka dengan contoh seperti pada gambar di bawah ini: Keren bukan? Baik, kita mulai saja pembahasannya. Pada dasarnya semua elemen antar pengguna di aplikasi Android dibangun menggunakan dua buah komponen inti, yaitu View dan ViewGroup. View merupakan komponen dasar yang tampil di layar dan dapat digunakan untuk berinteraksi dengan pengguna. Contoh komponen turunan dari View seperti : TextView , komponen yang berguna untuk menampilkan teks ke layar. Button , komponen yang membuat pengguna dapat berinteraksi dengan cara ditekan untuk melakukan sesuatu. ImageView , Komponen untuk menampilkan gambar. RecyclerView , komponen untuk menampilkan informasi dalam bentuk list. GridView , komponen untuk menampilkan informasi dalam bentuk grid. RadioButton , komponen yang memungkinkan pengguna dapat memilih satu pilihan dari berbagai pilihan yang disediakan. Checkbox , komponen yang memungkinkan pengguna dapat memilih lebih dari satu dari pilihan yang ada. Sedangkan ViewGroup adalah sebuah View spesial yang mewadahi objek-objek View lainnya dan berguna untuk mengatur posisinya sehingga membentuk satu kesatuan tampilan aplikasi yang utuh. Contoh komponen   ViewGroup adalah: LinearLayout RelativeLayout ConstraintLayout FrameLayout TableLayout Contoh hierarki komponen View dan ViewGroup dapat digambarkan dengan diagram berikut: Jika diterjemahkan di dalam sebuah ViewGroup akan ditampung dua buah komponen View dan satu komponen ViewGroup yang terdiri dari 3 buah komponen View. Anda dapat membaca tautan berikut untuk membaca lebih lanjut mengenai materi di atas: User Interface Overview Salah satu contoh dari tampilan dalam file layout xml untuk merepresentasikan kolaborasi View dan ViewGroup seperti ini : <?xml version=""1.0"" encoding=""utf-8""?> <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""               android:layout_width=""match_parent""               android:layout_height=""match_parent""               android:orientation=""vertical"" >     <TextView android:id=""@+id/text""               android:layout_width=""wrap_content""               android:layout_height=""wrap_content""               android:text=""I am a TextView"" />     <Button android:id=""@+id/button""             android:layout_width=""wrap_content""             android:layout_height=""wrap_content""             android:text=""I am a Button"" /> </LinearLayout> Objek turunan ViewGroup   LinearLayout  menjadi kontainer untuk objek turunan View, Button, dan TextView. Beberapa komponen ViewGroup seperti LinearLayout, RelativeLayout, FrameLayout,   dan TableLayout merupakan komponen yang paling banyak digunakan untuk menjadi  parent/root  dari komponen-komponen View. Berikut adalah definisi singkat dan inti dari komponen-komponen di atas terhadap penempatan komponen View ( child ) di dalamnya: LinearLayout Akan menempatkan komponen-komponen di dalamnya secara horizontal atau vertikal. LinearLayout memiliki atribut weight untuk masing-masing  child  view yang berguna untuk menentukan porsi ukuran View dalam sebuah ruang ( space ) yang tersedia.            android:orientation=”vertical”                      android:orientation=”horizontal” Anda dapat membaca lebih lanjut mengenai LinearLayout pada tautan berikut: Linear Layout RelativeLayout Layout yang lebih fleksible daripada layout yang sudah disebutkan di atas. Hal ini dikarenakan posisi dari masing-masing komponen di dalamnya dapat mengacu secara relatif pada komponen yang lainnya dan juga dapat mengacu secara relatif ke batas layar. Misalnya komponen A di sebelah kanan komponen B atau komponen c rata bawah tengah terhadap parent-nya). Anda dapat membaca lebih lanjut mengenai   RelativeLayout   pada tautan berikut: Relative Layout ConstraintLayout Merupakan layout default dan direkomendasikan di dalam XML. Dengan ConstraintLayout, Anda dapat menyusun tampilan yang kompleks cukup dengan satu lapis hierarki saja. Hal ini akan memberikan performa dan proses rendering yang lebih baik daripada penggunaan nested layout (layout di dalam layout). Sebenarnya layout ini mirip dengan RelativeLayout, tetapi lebih fleksibel dan mudah digunakan. Selain itu, juga ada berbagai fitur tambahan yang memudahkan Anda untuk mendesain aplikasi, seperti berikut. Relative Positioning :   memposisikan komponen secara relatif terhadap komponen yang lain. Center Positioning & Bias : untuk menentukan alignment dengan menggunakan persentase, default-nya 50% atau tengah. Baseline alignment : untuk membuat text pada suatu komponen sejajar dengan teks pada komponen lain. Guideline : untuk membuat garis pembantu yang tidak terlihat oleh user. Barrier : sama seperti Guideline, tetapi posisinya dapat mengkuti komponen lainnya. Chain : mengatur sekumpulan komponen secara linear. Spread : setiap elemen akan menyebar (default style). Spread inside : tampilan pertama dan terakhir akan ditempelkan pada batasan di setiap ujung rantai. Sedangkan sisanya akan didistribusikan secara merata. Weighted : jika beberapa widget disetel ke ""match constraint"", mereka akan membagi ruang yang tersedia. Packed : elemen akan menyatu dan dikemas bersama. Untuk mempelajari lebih lanjut, Anda dapat melihatnya pada tautan berikut. Constraint Layout FrameLayout Layout ini adalah layout yang paling sederhana. Layout ini akan membuat komponen yang ada di dalamnya menjadi menumpuk atau saling menutupi satu dengan yang lainnya. Komponen yang paling pertama pada layout ini akan menjadi alas bagi komponen-komponen di atasnya. Framelayout memiliki kemampuan untuk menjadi kontainer untuk fragment-fragment di dalam sebuah activity. Berikut ilustrasi penggunaan framelayout terhadap  child  view yang dimilikinya: Anda dapat membaca lebih lanjut mengenai   FrameLayout   pada tautan berikut: Frame Layout TableLayout Susunan komponen di dalam TableLayout akan berada dalam baris dan kolom. Namun layout jenis ini tidak akan menampilkan garis pembatas untuk baris, kolom atau cell-nya. Anda dapat membaca lebih lanjut mengenai   TableLayout   pada tautan berikut: TableLayout Salah satu perbedaan mendasar dari keempat jenis layout di atas adalah bagaimana komponen View di dalamnya tersusun. Kapan saatnya menggunakan LinearLayout, RelativeLayout, FrameLayout dan TableLayout? Jawabannya tergantung pada kebutuhan dan performa. Salah satu tips performa untuk aplikasi Android adalah dengan menyusun hierarki layout dalam sebuah file layout xml secara sederhana dan  flat . Artinya, kita tidak membuat layout dengan jumlah kedalaman yang tinggi. Selain itu, penting juga bagi kita untuk memahami dasar pembangunan antarmuka, pengalaman pengguna ketika menggunakannya, dan selalu mencari pendekatan terbaik dalam penggunaan komponen antarmuka. Semua tergantung latihan dan seberapa sering kita mengubah mockup menjadi tampilan sebenarnya, terutama dengan memaksimalkan penulisan kode antarmuka di berkas xml. Untuk memahami lebih lanjut mengenai layout, Anda dapat membacanya pada tautan berikut: Declaring Layout Ketika aplikasi Anda memuat informasi yang banyak dan melebihi ukuran layar, maka Anda membutuhkan tampilan yang memungkinkan pengguna untuk membaca informasi dengan lengkap. Kita membutuhkan komponen ScrollView untuk mengatasi masalah ini. ScrollView Adalah layout yang memungkinkan komponen di dalamnya digeser (scroll) secara vertikal dan horizontal. Komponen di dalam ScrollView hanya diperbolehkan memiliki 1  parent  utama dari LinearLayout, RelativeLayout, FrameLayout, atau TableLayout. ScrollView Satuan Dimensi di Android Platform Android dikenal karena keberagamannya. Mulai ukuran perangkatnya, layar, spesifikasi, hingga level operating system-nya. Karena keberagaman tersebut, tak heran jika dibutuhkan tampilan yang konsisten agar aplikasi kita bisa berjalan dan tampil maksimal. Android sendiri memiliki satuan unit dimensi untuk ukuran tinggi dan lebar sebuah komponen View atau ViewGroup. Berikut adalah esensi dari satuan dimensi unit di android.  Ekosistem Android dikenal dengan fragmentasi spesifikasi perangkat yang sangat bervariasi. Beragam perangkat Android memiliki perbedaan dimensi layar dan kerapatan  pixel  ( density ). Untuk tampilan yang konsisten di perangkat Android, terdapat 2 jenis satuan, yaitu dip/dp ( density-independent pixel ) dan sp  (scale-independent pixels ). Satuan   dp/dip digunakan untuk satuan dari nilai dimensi misal width (attribut : layout_width) dan height (attribut : layout_height) dari sebuah komponen View atau ViewGroup. Satuan sp digunakan untuk ukuran teks. Perbedaannya dengan dp/dip adalah satuan sp android akan men- scale  ukuran teks sesuai dengan setting ukuran teks di peranti (yang biasa dapat diakses melalui menu settings) Contoh 1 : Misalkan ada dua tablet 7-inch (ukuran diagonal layar). Tablet pertama (A) memiliki resolusi layar 1200x1920px 320dpi. Tablet kedua (B) memiliki resolusi 2048x1536px 326dpi. Sebuah tombol berukuran 300x300px akan tampak normal pada tablet A. Tapi tombol tersebut akan terlihat terlalu kecil pada tablet B. Tapi akan berbeda jika kita tentukan ukuran button-nya dengan ukuran yang bergantung pada  density  layar. Bila kita menggunakan ukuran 300x300dp, maka tombol tersebut akan terlihat baik pada beragam perangkat dengan ukuran yang berbeda. Contoh 2 : Pada gambar di atas ukuran 200dp akan dikonversi pada device mdpi (device dengan  density  160dpi/ dots per inch ) menjadi 200px dan menjadi 400px pada device xhdpi ( density  420dpi) misal pada nexus 4. Sehingga ukuran tersebut tampak sama dan konsisten secara fisik untuk beragam peranti dengan ukuran layar yang berbeda. Gambar untuk Semua Jenis Layar  Supaya gambar pada aplikasi Anda tetap terlihat bagus pada semua jenis handphone dengan pixel yang berbeda-beda, maka Anda perlu menyiapkan gambar dengan berbagai versi untuk setiap jenis handphone, jika tidak maka gambar yang tampil akan terlihat kabur( blur ). Berikut ini adalah patokan (baseline) dalam menyiapkan gambar. Untuk menyiapkan gambar dengan format ini secara otomatis, Anda dapat memanfaatkan  Image Asset Studio  yang ada di dalam Android Studio. Caranya yaitu dengan  klik kanan pada folder res  dan pilih  New  →   Image Asset .  Jika Anda ingin mengganti icon aplikasi maka pada  Icon Type  pilih Launcher Icons  (Adaptive and Legacy)  dengan nama tetap yaitu  ic_launcher . Sejak rilis Android 8.0 (API level 26), ikon aplikasi dapat dibuat menjadi adaptif. Karena itulah ikon aplikasi terdiri dari dua lapisan, yakni lapisan atas (foreground) dan bawah (background). Dengan begitu, bentuk ikon bisa lebih fleksibel dan bisa diberikan efek visual yang keren seperti ini. Selanjutnya, Anda hanya cukup memilih gambar dengan klik icon folder pada  Path  yang ada di Source Asset. Anda juga dapat mengatur ukuran supaya sesuai dan mengganti background seperti ini: Hasilnya lihatlah pada folder res/mipmap maka akan tercipta file yang sesuai dengan masing-masing density. Nah, ketika aplikasi dijalankan maka ikon aplikasi akan berubah menjadi seperti berikut: Vector Asset Selain menggunakan gambar dengan format JPG, PNG, atau tipe bitmap lainnya, Android Studio juga dapat menerima gambar dengan tipe vector. Kelebihan dari penggunaan vector yaitu gambar tidak akan pecah walaupun diperbesar. Biasanya ia digunakan untuk icon di dalam aplikasi, bukan yang berupa fotografi. Untuk menambahkan vector image caranya yaitu dengan  klik kanan pada folder res  dan pilih  New  →  Vector Asset .  Anda bisa memilih beberapa icon yang sudah disediakan oleh Android Studio dengan memilih  Clip Art , atau dengan menggunakan file sendiri yang bertipe SVG / PSD. Selain itu Anda juga bisa mengubah ukuran, warna, dan opacity icon tersebut. Setelah usai Anda dapat mencoba memperbesar gambar tersebut dan lihat hasilnya, gambar tidak akan pecah. Mantap! Beberapa tautan berikut akan membantu Anda untuk lebih memahami bagaimana aplikasi Anda dapat mendukung beragam ukuran perangkat Android: Screen Density DPI Screen DP/PX Converter Video Density-independent Pixels Pada modul berikutnya, kita akan menerapkan teori di atas. Sehingga Anda dapat memiliki pemahaman yang lebih baik mengenai teori tersebut.";Pada modul ini, Anda akan mempelajari tentang komponen View dan ViewGroup dalam pengembangan antarmuka aplikasi Android. View adalah elemen dasar yang tampil di layar, seperti TextView, Button, dan ImageView, yang memungkinkan interaksi dengan pengguna. Sedangkan ViewGroup adalah kontainer untuk menampung dan mengatur posisi elemen-elemen View lainnya, contohnya LinearLayout, RelativeLayout, dan ConstraintLayout. Dalam implementasinya, ViewGroup seperti LinearLayout mengatur elemen secara vertikal atau horizontal, sementara RelativeLayout memungkinkan pengaturan posisi relatif antar elemen. ConstraintLayout adalah layout yang lebih fleksibel dan efisien untuk tampilan kompleks. Penggunaan layout yang tepat tergantung pada kebutuhan dan performa aplikasi. Selain itu, modul ini juga membahas tentang satuan dimensi di Android, seperti dp/dip untuk ukuran elemen dan sp untuk ukuran teks, serta pentingnya mendukung berbagai ukuran layar perangkat menggunakan gambar dengan resolusi yang sesuai.
"Latihan LinearLayout, RelativeLayout, FrameLayout, dan TableLayout Tujuan Pada latihan kali ini Anda akan mengembangkan sebuah halaman detail yang di dalamnya terdiri dari beberapa komponen View dan Viewgroup layout. Tampilan akhir aplikasi akan seperti ini: Logika Menjalankan Aplikasi menampilkan tampilan (tampilan akan sesuai dengan apa yang dibuat di layout editor). Codelab Views and ViewGroup Buat Project baru di Android Studio dengan kriteria sebagai berikut: Nama Project MyViewAndViewGroup Target & Minimum Target SDK Phone and Tablet, Api level 21 Tipe Activity Empty Activity Activity Name MainActivity Use AndroidX artifacts True Language Kotlin/Java Lalu buka berkas  strings.xml  di  res → values . Sesuaikan isinya dengan seperti ini: <resources>     <string name=""app_name"">MyViewAndViewGroup</string>      <string name=""content_text"">Google officially announced its much-anticipated Pixel phones; the Pixel and Pixel XL, on October 4. We attended Google’s London UK event, mirroring the main one taking place in San Francisco, US, where the firm unwrapped the new Android 7.1 Nougat devices which will apparently usurp Google’s long-standing Nexus series.</string>     <string name=""content_specs_display"">5.0 inches\n     FHD AMOLED at 441ppi\n     2.5D Corning® Gorilla® Glass 4</string>     <string name=""content_specs_size"">5.6 x 2.7 x 0.2 ~ 0.3 inches 143.8 x 69.5 x 7.3 ~ 8.5 mm</string>     <string name=""content_specs_battery"">2,770 mAh battery\n     Standby time (LTE): up to 19 days\n     Talk time (3g/WCDMA): up to 26 hours\n     Internet use time (Wi-Fi): up to 13 hours\n     Internet use time (LTE): up to 13 hours\n     Video playback: up to 13 hours\n     Audio playback (via headset): up to 110 hours\n     Fast charging: up to 7 hours of use from only 15 minutes of charging</string>     <string name=""stock"">Stock hanya 5 buah</string>     <string name=""specification"">Spesifikasi</string>     <string name=""display"">Display</string>     <string name=""size"">Size</string>     <string name=""battery"">Battery</string>     <string name=""seller"">Dijual oleh</string>     <string name=""my_name"">Narenda Wicaksono</string>     <string name=""buy"">Beli</string>     <string name=""dummy_value"">$735</string>     <string name=""dummy_photos"">6 photos</string>  </resources> Selanjutnya, unduh asset-nya di  Asset View dan ViewGroup .  Bila telah selesai, ekstrak berkas tersebut dan salin semua asset yang dibutuhkan ke dalam direktori  res → drawable . Pilih folder drawable (bukan drawable-v24) untuk mendukung semua versi Android. Catatan: Apabila Anda menggunakan asset lain, ingat bahwa nama file yang ada di dalam resource drawable harus menggunakan huruf kecil dan underscore saja. Buka berkas  activity_main.xml  dan ubah layout utama menjadi seperti ini: <? xml version=""1.0"" encoding=""utf-8"" ?>  <ScrollView  xmlns:android=""http://schemas.android.com/apk/res/android""     android:layout_width=""match_parent""     android:layout_height=""match_parent"">      </ScrollView> Kemudian tambahkan layout utama di dalam  ScrollView . <?xml version=""1.0"" encoding=""utf-8""?> <ScrollView xmlns:android=""http://schemas.android.com/apk/res/android""     android:layout_width=""match_parent""     android:layout_height=""match_parent"">       <LinearLayout         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:orientation=""vertical"">              </LinearLayout>  </ScrollView> Kemudian kita masukkan komponen di dalam  LinearLayout  yang sudah ditambahkan sebelumnya. <?xml version=""1.0"" encoding=""utf-8""?> <ScrollView xmlns:android=""http://schemas.android.com/apk/res/android""     android:layout_width=""match_parent""     android:layout_height=""match_parent"">      <LinearLayout         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:orientation=""vertical"">           <FrameLayout             android:layout_width=""match_parent""             android:layout_height=""wrap_content"">              <ImageView                 android:layout_width=""match_parent""                 android:layout_height=""wrap_content""                 android:adjustViewBounds=""true""                 android:scaleType=""fitXY""                 android:src=""@drawable/pixel_google"" />              <TextView                 android:layout_width=""wrap_content""                 android:layout_height=""wrap_content""                 android:textAppearance=""@style/TextAppearance.AppCompat.Small""                 android:textColor=""@android:color/white""                 android:layout_gravity=""bottom""                 android:layout_marginStart=""16dp""                 android:layout_marginBottom=""16dp""                 android:background=""#4D000000""                 android:drawablePadding=""4dp""                 android:gravity=""center_vertical""                 android:padding=""8dp""                 android:text=""@string/dummy_photos""                  android:drawableStart =""@drawable/ic_collections_white_18dp"" />         </FrameLayout>      </LinearLayout> </ScrollView> Tampilan saat ini adalah seperti ini: Selanjutnya, tambahkan  TextView  di bawah  FrameLayout , menjadi seperti ini: <?xml version=""1.0"" encoding=""utf-8""?> <ScrollView xmlns:android=""http://schemas.android.com/apk/res/android""     android:layout_width=""match_parent""     android:layout_height=""match_parent"">      <LinearLayout         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:orientation=""vertical"">          <FrameLayout ... >                   <TextView             android:layout_width=""match_parent""             android:layout_height=""wrap_content""             android:layout_marginLeft=""16dp""             android:layout_marginRight=""16dp""             android:layout_marginTop=""16dp""             android:layout_marginBottom=""8dp""             android:text=""@string/dummy_value""             android:textSize=""32sp"" />          <TextView             android:layout_width=""match_parent""             android:layout_height=""wrap_content""             android:textSize=""12sp""             android:layout_marginLeft=""16dp""             android:layout_marginRight=""16dp""             android:layout_marginBottom=""16dp""             android:text=""@string/stock"" />          <TextView             android:layout_width=""match_parent""             android:layout_height=""wrap_content""             android:layout_marginLeft=""16dp""             android:layout_marginRight=""16dp""             android:layout_marginBottom=""16dp""             android:lineSpacingMultiplier=""1""             android:text=""@string/content_text"" />       </LinearLayout> </ScrollView> Tampilan saat ini adalah: Setelah menambahkan beberapa  TextView , selanjutnya kita akan menambahkan  TableLayout . <?xml version=""1.0"" encoding=""utf-8""?> <ScrollView xmlns:android=""http://schemas.android.com/apk/res/android""     android:layout_width=""match_parent""     android:layout_height=""match_parent"">      <LinearLayout         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:orientation=""vertical"">          <FrameLayout ...>         <TextView ...>         <TextView ...>         <TextView ...>           <TextView             android:layout_width=""match_parent""             android:layout_height=""wrap_content""             android:textSize=""12sp""             android:layout_marginLeft=""16dp""             android:layout_marginRight=""16dp""             android:layout_marginBottom=""8dp""             android:text=""@string/specification"" />            <TableLayout             android:layout_width=""match_parent""             android:layout_height=""wrap_content""             android:layout_marginLeft=""16dp""             android:layout_marginRight=""16dp""             android:layout_marginBottom=""16dp"">              <TableRow                 android:layout_width=""match_parent""                 android:layout_height=""wrap_content""                 android:layout_marginBottom=""8dp"">                  <TextView                     android:layout_width=""wrap_content""                     android:layout_height=""wrap_content""                     android:textSize=""14sp""                     android:layout_marginEnd=""16dp""                     android:text=""@string/display"" />                  <TextView                     android:layout_width=""match_parent""                     android:layout_height=""wrap_content""                     android:textSize=""14sp""                     android:layout_weight=""1""                     android:text=""@string/content_specs_display"" />             </TableRow>              <TableRow                 android:layout_width=""match_parent""                 android:layout_height=""wrap_content""                 android:layout_marginBottom=""8dp"">                  <TextView                     android:layout_width=""wrap_content""                     android:layout_height=""wrap_content""                     android:layout_marginEnd=""16dp""                     android:textSize=""14sp""                     android:text=""@string/size"" />                  <TextView                     android:layout_width=""match_parent""                     android:layout_height=""wrap_content""                     android:layout_weight=""1""                     android:textSize=""14sp""                     android:text=""@string/content_specs_size"" />             </TableRow>              <TableRow                 android:layout_width=""match_parent""                 android:layout_height=""wrap_content""                 android:layout_marginBottom=""8dp"">                  <TextView                     android:layout_width=""wrap_content""                     android:layout_height=""wrap_content""                     android:layout_marginEnd=""16dp""                     android:textSize=""14sp""                     android:text=""@string/battery"" />                  <TextView                     android:layout_width=""match_parent""                     android:layout_height=""wrap_content""                     android:layout_weight=""1""                     android:textSize=""14sp""                     android:text=""@string/content_specs_battery"" />             </TableRow>         </TableLayout>       </LinearLayout> </ScrollView> Tampilan saat ini adalah seperti berikut: Kemudian setelah menambahkan  TableLayout , kita masukkan ViewGroup lagi. Tambahkan  RelativeLayout  dan  Button  di bawah  TableLayout  menjadi seperti ini. <?xml version=""1.0"" encoding=""utf-8""?> <ScrollView xmlns:android=""http://schemas.android.com/apk/res/android""     xmlns:app=""http://schemas.android.com/apk/res-auto""     android:layout_width=""match_parent""     android:layout_height=""match_parent"">      <LinearLayout         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:orientation=""vertical"">          <FrameLayout ...>         <TextView ...>         <TextView ...>         <TextView ...>         <TableLayout...>           <RelativeLayout             android:layout_width=""match_parent""             android:layout_height=""wrap_content""             android:layout_marginLeft=""16dp""             android:layout_marginRight=""16dp""             android:layout_marginBottom=""16dp"">              <ImageView                 android:id=""@+id/profile_image""                 android:layout_width=""56dp""                 android:layout_height=""56dp""                 android:layout_centerVertical=""true""                 android:layout_marginEnd=""16dp""                 android:src=""@drawable/photo_2"" />              <TextView                 android:layout_width=""match_parent""                 android:layout_height=""wrap_content""                 android:layout_centerVertical=""true""                 android:layout_toEndOf=""@+id/profile_image""                 android:text=""@string/my_name"" />         </RelativeLayout>          <Button             android:text=""@string/buy""             android:layout_width=""match_parent""             android:layout_height=""wrap_content""             android:layout_marginLeft=""16dp""             android:layout_marginRight=""16dp""             android:layout_marginBottom=""16dp"" />      </LinearLayout> </ScrollView> Maka hasil akhir kode pada  activity_main.xml  menjadi seperti ini: <?xml version=""1.0"" encoding=""utf-8""?> <ScrollView xmlns:android=""http://schemas.android.com/apk/res/android""     xmlns:app=""http://schemas.android.com/apk/res-auto""     android:layout_width=""match_parent""     android:layout_height=""match_parent"">      <LinearLayout         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:orientation=""vertical"">          <FrameLayout             android:layout_width=""match_parent""             android:layout_height=""wrap_content"">              <ImageView                 android:layout_width=""match_parent""                 android:layout_height=""wrap_content""                 android:adjustViewBounds=""true""                 android:scaleType=""fitXY""                 android:src=""@drawable/pixel_google"" />              <TextView                 android:layout_width=""wrap_content""                 android:layout_height=""wrap_content""                 android:textAppearance=""@style/TextAppearance.AppCompat.Small""                 android:textColor=""@android:color/white""                 android:layout_gravity=""bottom""                 android:layout_marginStart=""16dp""                 android:layout_marginBottom=""16dp""                 android:background=""#4D000000""                 android:drawablePadding=""4dp""                 android:gravity=""center_vertical""                 android:padding=""8dp""                 android:text=""@string/dummy_photos""                 android:drawableStart=""@drawable/ic_collections_white_18dp"" />         </FrameLayout>          <TextView             android:layout_width=""match_parent""             android:layout_height=""wrap_content""             android:layout_marginLeft=""16dp""             android:layout_marginRight=""16dp""             android:layout_marginTop=""16dp""             android:layout_marginBottom=""8dp""             android:text=""@string/dummy_value""             android:textSize=""32sp"" />          <TextView             android:layout_width=""match_parent""             android:layout_height=""wrap_content""             android:textSize=""12sp""             android:layout_marginLeft=""16dp""             android:layout_marginRight=""16dp""             android:layout_marginBottom=""16dp""             android:text=""@string/stock"" />          <TextView             android:layout_width=""match_parent""             android:layout_height=""wrap_content""             android:layout_marginLeft=""16dp""             android:layout_marginRight=""16dp""             android:layout_marginBottom=""16dp""             android:lineSpacingMultiplier=""1""             android:text=""@string/content_text"" />          <TextView             android:layout_width=""match_parent""             android:layout_height=""wrap_content""             android:textSize=""12sp""             android:layout_marginLeft=""16dp""             android:layout_marginRight=""16dp""             android:layout_marginBottom=""8dp""             android:text=""@string/specification"" />          <TableLayout             android:layout_width=""match_parent""             android:layout_height=""wrap_content""             android:layout_marginLeft=""16dp""             android:layout_marginRight=""16dp""             android:layout_marginBottom=""16dp"">              <TableRow                 android:layout_width=""match_parent""                 android:layout_height=""wrap_content""                 android:layout_marginBottom=""8dp"">                  <TextView                     android:layout_width=""wrap_content""                     android:layout_height=""wrap_content""                     android:textSize=""14sp""                     android:layout_marginEnd=""16dp""                     android:text=""@string/display"" />                  <TextView                     android:layout_width=""match_parent""                     android:layout_height=""wrap_content""                     android:textSize=""14sp""                     android:layout_weight=""1""                     android:text=""@string/content_specs_display"" />             </TableRow>              <TableRow                 android:layout_width=""match_parent""                 android:layout_height=""wrap_content""                 android:layout_marginBottom=""8dp"">                  <TextView                     android:layout_width=""wrap_content""                     android:layout_height=""wrap_content""                     android:layout_marginEnd=""16dp""                     android:textSize=""14sp""                     android:text=""@string/size"" />                  <TextView                     android:layout_width=""match_parent""                     android:layout_height=""wrap_content""                     android:layout_weight=""1""                     android:textSize=""14sp""                     android:text=""@string/content_specs_size"" />             </TableRow>              <TableRow                 android:layout_width=""match_parent""                 android:layout_height=""wrap_content""                 android:layout_marginBottom=""8dp"">                  <TextView                     android:layout_width=""wrap_content""                     android:layout_height=""wrap_content""                     android:layout_marginEnd=""16dp""                     android:textSize=""14sp""                     android:text=""@string/battery"" />                  <TextView                     android:layout_width=""match_parent""                     android:layout_height=""wrap_content""                     android:layout_weight=""1""                     android:textSize=""14sp""                     android:text=""@string/content_specs_battery"" />             </TableRow>         </TableLayout>          <TextView             android:layout_width=""match_parent""             android:layout_height=""wrap_content""             android:textSize=""12sp""             android:layout_marginLeft=""16dp""             android:layout_marginRight=""16dp""             android:layout_marginBottom=""8dp""             android:text=""@string/seller"" />          <RelativeLayout             android:layout_width=""match_parent""             android:layout_height=""wrap_content""             android:layout_marginLeft=""16dp""             android:layout_marginRight=""16dp""             android:layout_marginBottom=""16dp"">              <ImageView                 android:id=""@+id/profile_image""                 android:layout_width=""56dp""                 android:layout_height=""56dp""                 android:layout_centerVertical=""true""                 android:layout_marginEnd=""16dp""                 android:src=""@drawable/photo_2"" />              <TextView                 android:layout_width=""match_parent""                 android:layout_height=""wrap_content""                 android:layout_centerVertical=""true""                 android:layout_toEndOf=""@+id/profile_image""                 android:text=""@string/my_name"" />         </RelativeLayout>          <Button             android:text=""@string/buy""             android:layout_width=""match_parent""             android:layout_height=""wrap_content""             android:layout_marginLeft=""16dp""             android:layout_marginRight=""16dp""             android:layout_marginBottom=""16dp"" />     </LinearLayout> </ScrollView> Terakhir, pada  MainActivity  tambahkan beberapa baris kode berikut untuk mengubah judul aplikasi pada Action Bar: Kotlin class MainActivity : AppCompatActivity() {      override fun onCreate(savedInstanceState: Bundle?) {         super.onCreate(savedInstanceState)         setContentView(R.layout.activity_main)                  supportActionBar?.title = ""Google Pixel""      } } Java public class MainActivity extends AppCompatActivity {      @Override     protected void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout.activity_main);            if (getSupportActionBar() != null) {             getSupportActionBar().setTitle(""Google Pixel"");         }      } } Sekarang silakan jalankan aplikasinya. Seharusnya hasilnya seperti ini: Bedah Kode Tidak ada yang rumit di bagian ini karena Anda hanya berhadapan dengan cara membentuk sebuah tampilan aplikasi Android yang bagus di berkas layout xml. Strings.xml Di sini kita akan menambahkan variabel-variabel konstan berupa String yang ditulis di dalam berkas  strings.xml . Tujuannya agar teks yang sama tidak ditulis dua kali, baik itu di berkas  Activity  maupun berkas xml. <resources>     <string name=""app_name"">MyViewAndViewGroup</string>     <string name=""content_text"">Google officially announced its much-anticipated Pixel phones; the Pixel and Pixel XL, on October 4. We attended Google’s London UK event, mirroring the main one taking place in San Francisco, US, where the firm unwrapped the new Android 7.1 Nougat devices which will apparently usurp Google’s long-standing Nexus series.</string>     <string name=""content_specs_display"">5.0 inches\n         FHD AMOLED at 441ppi\n         2.5D Corning® Gorilla® Glass 4</string>     <string name=""content_specs_size"">5.6 x 2.7 x 0.2 ~ 0.3 inches 143.8 x 69.5 x 7.3 ~ 8.5 mm</string>     <string name=""content_specs_battery"">2,770 mAh battery\n         Standby time (LTE): up to 19 days\n         Talk time (3g/WCDMA): up to 26 hours\n         Internet use time (Wi-Fi): up to 13 hours\n         Internet use time (LTE): up to 13 hours\n         Video playback: up to 13 hours\n         Audio playback (via headset): up to 110 hours\n         Fast charging: up to 7 hours of use from only 15 minutes of charging</string>     <string name=""stock"">Stock hanya 5 buah</string>     <string name=""specification"">Spesifikasi</string>     <string name=""display"">Display</string>     <string name=""size"">Size</string>     <string name=""battery"">Battery</string>     <string name=""seller"">Dijual oleh</string>     <string name=""my_name"">Narenda Wicaksono</string>     <string name=""buy"">Beli</string>     <string name=""dummy_value"">$735</string>     <string name=""dummy_photos"">6 photos</string> </resources> Bila diperhatikan, jika kita ingin menampilkan teks ‘ content_specs_size ’, kita hanya perlu menuliskan nama atribut di dalam obyek  TextView  yang diinginkan.  <TextView     android:layout_width=""match_parent""     android:layout_height=""wrap_content""     android:textSize=""14sp""     android:layout_weight=""1""      android:text=""@string/content_specs_size""  /> Dengan memanfaatkan  strings.xml , Anda akan lebih mudah membuat aplikasi yang mendukung lebih dari satu bahasa. View dan ViewGroup Pembahasan mengenai Activity sebelumnya akan memudahkan Anda untuk memahami atribut dan  namespace  yang digunakan pada berkas layout xml. Anda dapat membaca kembali topik activity bila ada bagian yang Anda lupa. <ScrollView xmlns:android=""http://schemas.android.com/apk/res/android""     android:layout_width=""match_parent""     android:layout_height=""match_parent"">      ... </ScrollView> Ingat, semua komponen view dan viewgroup memiliki dua buah atribut penting yang harus selalu diberikan nilai untuk mengatur posisi dirinya di dalam sebuat layout, yaitu: layout_width layout_height Kita akan menggunakan sebuah obyek  ScrollView  yang akan menjadi  root  untuk tampilan halaman aplikasi. Kita menggunakan  ScrollView  sebagai  root  karena kita ingin halaman aplikasi bisa di- scroll  ke bawah dan ke atas. Hal ini akan memudahkan pengguna untuk melihat tampilan secara menyeluruh. <ScrollView xmlns:android=""http://schemas.android.com/apk/res/android""     android:layout_width=""match_parent""     android:layout_height=""match_parent"">      <LinearLayout         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:orientation=""vertical"">          ...      </LinearLayout> </ScrollView> Seperti telah dijelaskan sebelumnya,  ScrollView  hanya dapat memiliki satu layout Viewgroup sebagai  root  untuk obyek View di dalamnya. Di sini susunan komponen View akan berorientasi vertikal. <FrameLayout     android:layout_width=""match_parent""     android:layout_height=""wrap_content"">      <ImageView         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:adjustViewBounds=""true""         android:scaleType=""fitXY""         android:src=""@drawable/pixel_google"" />      <TextView         android:layout_width=""wrap_content""         android:layout_height=""wrap_content""         android:textAppearance=""@style/TextAppearance.AppCompat.Small""         android:textColor=""@android:color/white""         android:layout_gravity=""bottom""         android:layout_marginStart=""16dp""         android:layout_marginBottom=""16dp""         android:background=""#4D000000""         android:drawablePadding=""4dp""         android:gravity=""center_vertical""         android:padding=""8dp""         android:text=""@string/dummy_photos""         android:drawableStart=""@drawable/ic_collections_white_18dp"" /> </FrameLayout> Gambar  pixel_google  yang tampil akan menjadi alas bagi obyek  TextView  yang berada di atasnya. Ini seperti sifat dari komponen  FrameLayout  itu sendiri. <TableLayout     android:layout_width=""match_parent""     android:layout_height=""wrap_content""     android:layout_marginLeft=""16dp""     android:layout_marginRight=""16dp""     android:layout_marginBottom=""16dp"">      <TableRow         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:layout_marginBottom=""8dp"">          <TextView             android:layout_width=""wrap_content""             android:layout_height=""wrap_content""             android:textSize=""14sp""             android:layout_marginEnd=""16dp""             android:text=""@string/display"" />          <TextView             android:layout_width=""match_parent""             android:layout_height=""wrap_content""             android:textSize=""14sp""             android:layout_weight=""1""             android:text=""@string/content_specs_display"" />     </TableRow>      <TableRow         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:layout_marginBottom=""8dp"">          <TextView             android:layout_width=""wrap_content""             android:layout_height=""wrap_content""             android:layout_marginEnd=""16dp""             android:textSize=""14sp""             android:text=""@string/size"" />          <TextView             android:layout_width=""match_parent""             android:layout_height=""wrap_content""             android:layout_weight=""1""             android:textSize=""14sp""             android:text=""@string/content_specs_size"" />     </TableRow>      <TableRow         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:layout_marginBottom=""8dp"">          <TextView             android:layout_width=""wrap_content""             android:layout_height=""wrap_content""             android:layout_marginEnd=""16dp""             android:textSize=""14sp""             android:text=""@string/battery"" />          <TextView             android:layout_width=""match_parent""             android:layout_height=""wrap_content""             android:layout_weight=""1""             android:textSize=""14sp""             android:text=""@string/content_specs_battery"" />     </TableRow> </TableLayout> Kita menggunakan  TableLayout   untuk menampilkan informasi spesifikasi dari perangkat Google Pixel.  TableLayout  yang kita gunakan sangatlah sederhana. Tidak ada garis pembatas untuk kolom dan baris bahkan cell-nya. Hanya dengan menggunakan  TableRow   kita bisa menambahkan sebuah baris baru di dalam sebuah  TableLayout .  <RelativeLayout     android:layout_width=""match_parent""     android:layout_height=""wrap_content""     android:layout_marginLeft=""16dp""     android:layout_marginRight=""16dp""     android:layout_marginBottom=""16dp"">      <ImageView         android:id=""@+id/profile_image""         android:layout_width=""56dp""         android:layout_height=""56dp""         android:layout_centerVertical=""true""         android:layout_marginEnd=""16dp""         android:src=""@drawable/photo_2"" />      <TextView         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:layout_centerVertical=""true""         android:layout_toEndOf=""@+id/profile_image""         android:text=""@string/my_name"" /> </RelativeLayout> Selanjutnya, kita menggunakan sebuah  RelativeLayout  untuk menampilkan sebuah gambar dan teks. Posisi dari teks mengacu ke sebelah kanan dari image dan posisi keduanya disesuaikan untuk berada di tengah secara vertikal. Kotlin supportActionBar?.title = ""Google Pixel"" Baris di atas akan mengganti nilai dari judul halaman pada  ActionBar  di dalam  MainActivity . Kita menggunakan  supportActionBar  karena kelas  MainActivity   inherit  kepada  AppCompatActivity , yang merupakan kelas turunan  Activity . Kelas tersebut sudah menyediakan fasilitas komponen  ActionBar  dan mendukung semua versi OS Android. Java if (getSupportActionBar() != null) {     getSupportActionBar().setTitle(""Google Pixel""); } Baris di atas akan mengganti nilai dari judul halaman pada  ActionBar  di dalam  MainActivity . Kita menggunakan  getSupportActionBar()  karena kelas  MainActivity   inherit  kepada  AppCompatActivity , yang merupakan kelas turunan  Activity . Kelas tersebut sudah menyediakan fasilitas komponen  ActionBar  dan mendukung semua versi OS Android. Selamat! Anda sudah mempelajari Layout, View, dan Viewgroup. Semakin sering Anda berlatih untuk mentransformasikan sebuah desain menjadi sebuah berkas layout xml, kemampuan Anda akan semakin meningkat. Anda dapat mengunjungi tautan berikut untuk berbagai contoh UI yang menarik pada Android. Resource UI dari Uplabs Mobile design inspiration from Dribbble  Source code bisa Anda dapatkan pada tautan berikut: Source Code Latihan ViewAndViewGroup";"Latihan ini bertujuan untuk mengembangkan halaman detail aplikasi Android menggunakan berbagai komponen View dan ViewGroup seperti LinearLayout, RelativeLayout, FrameLayout, dan TableLayout. Anda akan membuat proyek baru di Android Studio dengan nama ""MyViewAndViewGroup"" dan mengatur target SDK. Setelah menyiapkan berkas strings.xml dengan konten yang relevan, Anda akan mengunduh dan menyalin aset ke direktori drawable. Kemudian, Anda akan mengatur layout utama di activity_main.xml menggunakan ScrollView dan LinearLayout, serta menambahkan berbagai komponen seperti ImageView, TextView, dan TableLayout untuk menampilkan spesifikasi perangkat Google Pixel. Terakhir, Anda akan menambahkan RelativeLayout dan Button, serta mengubah judul aplikasi di Action Bar. Dengan latihan ini, Anda akan memahami cara membangun tampilan aplikasi Android yang menarik dan fungsional."
"Teori Style dan Theme Pada bagian ini, Anda akan mempelajari prinsip desain yang ada di android. Anda juga akan mempelajari bagaimana menerapkan struktur dan tampilan  view   dalam sebuah berkas  style .  Prinsip dasar dalam merancang antarmuka aplikasi Android harus mematuhi kaidah yang ditetapkan oleh  Design Guideline .  Guideline  ini dibuat oleh tim android di Google. Beberapa prinsipnya adalah: Menampilkan informasi yang hanya dibutuhkan. Jika aplikasi meminta izin pengguna untuk melakukan sebuah aksi, maka pengembang harus menyediakan mekanisme untuk membatalkan izin tersebut. Lakukan interupsi jika diperlukan. Menggunakan teks secara singkat. Gunakan gambar untuk menjelaskan informasi secara lebih deskriptif. Jaga data pengguna. Permudah pengguna untuk melakukan sesuatu yang penting secara cepat. Jika terlihat sama, maka perilaku haruslah sama. Bantu pengguna untuk membuat keputusan tapi tetap biarkan pengguna menentukan keputusannya. Best Practice Terdapat beberapa langkah terbaik ( best practice ) yang harus diperhatikan ketika mengembangkan sebuah aplikasi android, di antaranya: Desain yang baik untuk performa aplikasi Aplikasi yang dirancang dengan baik harus dapat dijalankan dengan cepat dan jika terdapat proses yang memakan waktu, maka jalankan di  background  dan  asynchronous. Desain yang baik agar aplikasi dapat bersifat responsif Berikan  feedback  ke pengguna terhadap aksi yang dilakukannya. Contohnya, jika pengguna menekan sebuah tombol, maka aplikasi harus menampilkan efek tekan. Desain yang mengakomodasi kebutuhan informasi pengguna Aplikasi Anda harus menampilkan informasi yang dibutuhkan pengguna. Bila diperlukan, aplikasi perlu menampilkan informasi terakhir yang diperoleh, sehingga pengguna tidak perlu lagi menunggu aplikasi memuat  data  dari  server . Desain untuk optimasi pengunaan baterai Usahakan agar aplikasi menggunakan daya baterai yang kecil. Minimalisir penggunaan  background service  yang tidak perlu. Berhentikan semua  listener  jika aplikasi tidak sedang dijalankan. Manfaatkan alarmmanager dan jobscheduler jika memang terdapat  task  yang harus dilakukan secara berkala. Desain untuk efisiensi pengunaan koneksi jaringan Aplikasi yang baik adalah yang efisien dalam memanfaatkan koneksi ke jaringan internet. Ia memilah-milah  task  mana yang perlu dijalankan saat perangkat pengguna terhubung ke wifi  ( unmetered network)  atau pun  network  lain. Penggunaan koneksi jaringan yang baik akan menjadi hal wajib jika aplikasi Anda ingin tetap digunakan oleh pengguna. Nilai yang bagus pada poin tampilan akan mendukung kualitas fungsi aplikasi yang dibuat. Pengguna akan mempertahankan aplikasi Anda dan tetap menggunakannya selama aplikasi dibutuhkan dan memenuhi poin-poin di atas. Style Kembali pada topik  style  dan  theme . Jika anda pernah mengembangkan sebuah aplikasi berbasis web, Anda sudah tidak asing lagi dengan CSS  ( Cascading Style Sheet ) . Ia mengatur tampilan dari sebuah halaman  website . Pendekatan yang serupa juga berlaku di Android. Inilah yang dinamakan  style . Style merupakan sebuah kumpulan properti yang dibutuhkan untuk mendefinisikan bagaimana sebuah komponen  view  dan layar jendela (bisa activity maupun fragment) ditampilkan. Contoh properti ini adalah  height, width, background_color . Pemusatan style cocok digunakan untuk mengumpulkan attribute yang berulang-ulang digunakan di banyak komponen. Sehingga jika ada perubahan, Anda cukup mengubahnya di satu tempat saja. Style terdefinisi dalam file xml sendiri. Anda bisa menemukannya di  res → values → themes.xml . Sebagai contoh, Anda memiliki sebuah TextView yang berisi berbagai atribut seperti contoh kode di bawah ini.  <TextView     android:layout_width=""match_parent""     android:layout_height=""wrap_content""     android:textColor=""#00FF00""     android:typeface=""monospace""     android:text=""@string/hello"" /> TextView di atas berguna untuk menampilkan konten dari detail informasi yang terdapat di keseluruhan aplikasi. Sangat tidak efektif jika kita melakukan  copy paste  dari satu  layout  xml ke  layout  xml lainnya. Kita dapat menyederhanakan hal tersebut menjadi: <TextView     style=""@style/CodeFont""     android:text=""@string/hello"" /> Attribute  layout_width ,  layout_height ,  textcolor , dan  typeface  bisa kita pindahkan menjadi sebuah  style  sendiri untuk textview tersebut dan dapat digunakan kembali untuk semua obyek textview sejenis. <? xml version=""1.0"" encoding=""utf-8"" ?>  <resources>     <style name=""CodeFont"" parent=""@android:style/TextAppearance.Medium"">         <item name=""android:layout_width"">match_parent</item>         <item name=""android:layout_height"">wrap_content</item>         <item name=""android:textcolor"">#00FF00</item>         <item name=""android:typeface"">monospace</item>     </style> </resources> Beberapa aturan yang harus diperhatikan ketika kita menggunakan  styles  yaitu: Semua  style  yang dibuat harus berada dalam tag  resources . Semua  style  yang ingin didefinisikan harus berada dalam tag  style . <style name=""CodeFont"" parent=""@android:style/TextAppearance.Medium""> name   : Nama dari  style  yang Anda buat. parent  : Nilai  style  yang akan mewarisi  style  (termasuk  attribute  di dalamnya) yang telah ada, umumnya bawaan dari sdk ataupun  platform . Style  yang diwarisi akan dapat diubah dan ditambahkan atributnya dalam  style  baru yang Anda buat. Android sudah menyediakan beragam  style  yang bisa Anda gunakan untuk beragam tampilan. Semua atribut yang didefinisikan dalam sebuah  style  harus berada dalam tag  item . <item name=""android:layout_width"">match_parent</item> name  : Nama atribut yang ingin didefinisikan. match_parent  : Nilai dari atribut tersebut. Andaikan dalam satu kasus Anda ingin membuat turunan dari  style  yang telah Anda buat. Misalnya Anda ingin membuat  style   CodeFont  berwarna merah, Anda dapat melakukannya dengan cara berikut ini: <style name=""CodeFont.Red"">     <item name=""android:textColor"">#FF0000</item> </style> Selain itu, Anda juga dapat mengubah ukuran teks menjadi lebih besar dengan kode ini: < style  name= ""CodeFont.Red"">     <item name=""android:textColor"">#FF0000</item>       <item name=""android:textSize"">30sp</item>  </style> Mudah bukan?  Anda baru saja belajar tentang bagaimana sebuah  style  dibuat dan diimplementasikan. Selanjutnya Anda akan mempelajari  theme . Theme Theme atau tema itu sendiri merupakan sebuah  style  yang diterapkan khusus untuk activity dan  application  pada berkas  AndroidManifest.xml . Pada proyek sebelumnya, kita mendefinisikannya dengan cara berikut ini: android:theme=""@style/Theme.MyViewAndViews"" Di mana  Theme.MyViewAndViews  pada  themes .xml  berisi: <resources>       <style name=""Theme.MyViewAndViews"" parent=""Theme.MaterialComponents.DayNight.DarkActionBar"">         <!-- Primary brand color. -->         <item name=""colorPrimary"">@color/purple_500</item>         <item name=""colorPrimaryVariant"">@color/purple_700</item>         <item name=""colorOnPrimary"">@color/white</item>         <!-- Secondary brand color. -->         <item name=""colorSecondary"">@color/teal_200</item>         <item name=""colorSecondaryVariant"">@color/teal_700</item>         <item name=""colorOnSecondary"">@color/black</item>         <!-- Status bar color. -->         <item name=""android:statusBarColor"" tools:targetApi=""l"">?attr/colorPrimaryVariant</item>         <!-- Customize your theme here. -->     </style> </resources> Sebuah  styles  yang  inherit  ke tema  MaterialComponents  untuk varian  DayNight   dan memiliki  DarkActionBar . Semua nilai pada atribut terdapat pada berkas  colors.xml  yang berisi. <?xml version=""1.0"" encoding=""utf-8""?> <resources>     <color name=""purple_200"">#FFBB86FC</color>     <color name=""purple_500"">#FF6200EE</color>     <color name=""purple_700"">#FF3700B3</color>     <color name=""teal_200"">#FF03DAC5</color>     <color name=""teal_700"">#FF018786</color>     <color name=""black"">#FF000000</color>     <color name=""white"">#FFFFFFFF</color> </resources> Saat ini, pengembangan aplikasi Android mengacu pada implementasi prinsip  material design  untuk merancang  user interface  dan  us er  experience . Anda bisa mempelajari lebih lanjut tentang  material  design  pada tautan berikut: Material Design Semenjak  material design  ditetapkan sebagai acuan utama untuk pengembangan  user interface  dan  user experience , terdapat penyederhanaan komponen inti yang digunakan. Pada gambar di atas, terlihat titik-titik mana saja yang hanya kita gunakan untuk menjadi fondasi dasar  style  aplikasi yang dibuat. Bila Anda tertarik untuk mengetahui prinsip sebelum  material design , Anda dapat melihat video berikut ini: Video From Holo to Material Pada modul berikutnya, Anda akan menerapkan teori yang telah kita pelajari pada modul ini.";Pada bagian ini, Anda akan mempelajari prinsip desain dalam pengembangan aplikasi Android, termasuk penerapan struktur dan tampilan view melalui berkas style. Prinsip dasar merancang antarmuka harus mengikuti Design Guideline dari Google, yang mencakup menampilkan informasi yang diperlukan, menggunakan teks singkat, menjaga data pengguna, dan memudahkan pengguna dalam melakukan tindakan penting. Best practices dalam pengembangan aplikasi meliputi desain untuk performa, responsivitas, efisiensi penggunaan baterai dan koneksi jaringan. Style di Android mirip dengan CSS di web, berfungsi untuk mendefinisikan tampilan komponen view. Anda dapat mengelompokkan atribut yang sering digunakan dalam style untuk menghindari pengulangan. Style didefinisikan dalam berkas XML di res → values → themes.xml. Selain itu, tema adalah style yang diterapkan pada activity dan aplikasi, yang didefinisikan dalam AndroidManifest.xml. Tema dapat mengatur warna dan elemen UI sesuai dengan prinsip material design, yang menjadi acuan utama dalam pengembangan antarmuka dan pengalaman pengguna. Anda akan menerapkan teori ini dalam modul berikutnya.
"Latihan Style and Theme  Tujuan Pada  codelab  kali ini kita akan menerapkan  style  dan  theme  pada contoh aplikasi yang telah kita buat sebelumnya pada modul views dan viewgroup. Beberapa poin yang didapatkan pada materi ini adalah: Bagaimana memanfaatkan  style  pada aplikasi? Bagaimana memanfaatkan  theme  pada aplikasi?  Hasil dari aplikasi yang dibuat akan jadi seperti ini. Alur Latihan Berikut alur yang akan kita pelajari dalam latihan ini:  Mengubah warna color pada theme light dan night. Membuat custom style baru. Mengimplementasikan custom style baru. Codelab Style dan Theme Ikuti alur berikut untuk mengerjakan latihan ini:  Buka kembali proyek sebelumnya ( MyViewAndViewGroup ) atau unduh di  Latihan View dan ViewGroup . Kemudian buka berkas  colors.xml  di  res → values → colors.xml . Ubah setiap nilai yang ada saat ini dengan nilai-nilai berikut: <?xml version=""1.0"" encoding=""utf-8""?> <resources>     <color name=""gray"">#607D8B</color>     <color name=""gray_light"">#B0BEC5</color>     <color name=""gray_dark"">#455A64</color>     <color name=""orange"">#FF5722</color>     <color name=""orange_light"">#FFAB91</color>     <color name=""orange_dark"">#E64A19</color>     <color name=""black"">#FF000000</color>     <color name=""white"">#FFFFFFFF</color>     <color name=""colorSubtitle"">#757575</color> </resources> Selanjutnya, buka berkas  themes .xml  di  res → values → themes.xml  dan tambahkan beberapa  style  seperti di bawah ini: <?xml version=""1.0"" encoding=""utf-8""?> <resources xmlns:tools=""http://schemas.android.com/tools"">     <!-- Base application theme. -->     <style name=""Theme.MyViewAndViews"" parent=""Theme.MaterialComponents.DayNight.DarkActionBar"">         <!-- Primary brand color. -->         <item name=""colorPrimary"">@color/ gray </item>         <item name=""colorPrimaryVariant"">@color/ gray_dark </item>         <item name=""colorOnPrimary"">@color/white</item>         <!-- Secondary brand color. -->         <item name=""colorSecondary"">@color/ orange_light </item>         <item name=""colorSecondaryVariant"">@color/ orange_dark </item>         <item name=""colorOnSecondary"">@color/black</item>          <!-- Status bar color. -->         <item name=""android:statusBarColor"" tools:targetApi=""l"">?attr/colorPrimaryVariant</item>         <!-- Customize your theme here. -->     </style>       <style name=""TextContent"">         <item name=""android:layout_width"">wrap_content</item>         <item name=""android:layout_height"">wrap_content</item>         <item name=""android:layout_marginLeft"">16dp</item>         <item name=""android:layout_marginRight"">16dp</item>     </style>      <style name=""TextContent.Small"">         <item name=""android:textAppearance"">@style/TextAppearance.MaterialComponents.Subtitle1</item>     </style>      <style name=""TextContent.Small.White"">         <item name=""android:textColor"">@android:color/white</item>     </style>      <style name=""TextContent.Subtitle"">         <item name=""android:textColor"">@color/colorSubtitle</item>         <item name=""android:textSize"">12sp</item>     </style>      <style name=""TextSpec"">         <item name=""android:textSize"">14sp</item>     </style>      <style name=""TextSpec.Field"">         <item name=""android:layout_width"">wrap_content</item>         <item name=""android:layout_height"">wrap_content</item>         <item name=""android:layout_marginRight"">16dp</item>         <item name=""android:textColor"">@color/colorSubtitle</item>      </style>      <style name=""TextSpec.Value"">         <item name=""android:layout_width"">match_parent</item>         <item name=""android:layout_height"">wrap_content</item>         <item name=""android:layout_weight"">1</item>     </style>  </resources> Pada file  themes.xml (night) : <?xml version=""1.0"" encoding=""utf-8""?> <resources xmlns:tools=""http://schemas.android.com/tools"">     <!-- Base application theme. -->     <style name=""Theme.MyViewAndViews"" parent=""Theme.MaterialComponents.DayNight.DarkActionBar"">         <!-- Primary brand color. -->         <item name=""colorPrimary"">@color/ gray_light </item>         <item name=""colorPrimaryVariant"">@color / gray </item>         <item name=""colorOnPrimary"">@color/black</item>         <!-- Secondary brand color. -->         <item name=""colorSecondary"">@color/ orange_light </item>         <item name=""colorSecondaryVariant"">@color/ orange_light </item>         <item name=""colorOnSecondary"">@color/black</item>         <!-- Status bar color. -->         <item name=""android:statusBarColor"" tools:targetApi=""l"">?attr/colorPrimaryVariant</item>         <!-- Customize your theme here. -->     </style> </resources> Jika selesai, kita akan implementasikan beberapa  style  yang baru saja dibuat ke dalam berkas  activity_main.xml  dan kondisikan seperti ini: <ScrollView xmlns:android=""http://schemas.android.com/apk/res/android""     xmlns:tools=""http://schemas.android.com/tools""     android:id=""@+id/activity_main""     android:layout_width=""match_parent""     android:layout_height=""match_parent""     android:background=""@android:color/white""     tools:context=""com.dicoding.picodiploma.myviewandviews.MainActivity"">     <LinearLayout         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:orientation=""vertical"">          <FrameLayout             android:layout_width=""match_parent""             android:layout_height=""wrap_content"">              <ImageView                 android:layout_width=""match_parent""                 android:layout_height=""wrap_content""                 android:adjustViewBounds=""true""                 android:scaleType=""fitXY""                 android:src=""@drawable/pixel_google"" />              <TextView                  style=""@style/TextContent.Small.White""                  android:padding=""8dp""                 android:text=""@string/dummy_photos""                 android:gravity=""center_vertical""                 android:drawableStart=""@drawable/ic_collections_white_18dp""                 android:drawablePadding=""4dp""                 android:textAppearance=""@style/TextAppearance.AppCompat.Small""                 android:background=""#4D000000""                 android:layout_marginStart=""16dp""                 android:layout_marginBottom=""16dp""                 android:layout_gravity=""bottom"" />         </FrameLayout>          <TextView              style=""@style/TextContent""              android:textSize=""32sp""             android:text=""@string/dummy_value""             android:layout_marginTop=""16dp""/>          <TextView              style=""@style/TextContent.Subtitle""              android:text=""@string/stock""             android:layout_marginBottom=""16dp""/>         <TextView              style=""@style/TextContent""              android:layout_marginBottom=""16dp""             android:lineSpacingMultiplier=""1""             android:text=""@string/content_text""             android:textColor=""@android:color/black"" />          <TextView              style=""@style/TextContent.Subtitle""              android:text=""@string/specification""             android:layout_marginBottom=""8dp""/>         <TableLayout             android:layout_width=""match_parent""             android:layout_height=""wrap_content""             android:layout_marginBottom=""16dp""             android:layout_marginLeft=""16dp""             android:layout_marginRight=""16dp"">              <TableRow                 android:layout_width=""match_parent""                 android:layout_height=""wrap_content""                 android:layout_marginBottom=""8dp"">                  <TextView                      style=""@style/TextSpec.Field""                      android:text=""@string/display"" />                  <TextView                      style=""@style/TextSpec.Value""                      android:text=""@string/content_specs_display"" />             </TableRow>              <TableRow                 android:layout_width=""match_parent""                 android:layout_height=""wrap_content""                 android:layout_marginBottom=""8dp"">                  <TextView                      style=""@style/TextSpec.Field""                      android:text=""@string/size"" />                  <TextView                      style=""@style/TextSpec.Value""                      android:text=""@string/content_specs_size"" />             </TableRow>              <TableRow                 android:layout_width=""match_parent""                 android:layout_height=""wrap_content""                 android:layout_marginBottom=""8dp"">                  <TextView                      style=""@style/TextSpec.Field""                      android:text=""@string/battery"" />                  <TextView                      style=""@style/TextSpec.Value""                      android:text=""@string/content_specs_battery"" />             </TableRow>         </TableLayout>          <TextView              style=""@style/TextContent.Subtitle""              android:text=""@string/seller""             android:layout_marginBottom=""8dp""/>          <RelativeLayout             android:layout_width=""match_parent""             android:layout_height=""wrap_content""             android:layout_marginBottom=""16dp""             android:layout_marginLeft=""16dp""             android:layout_marginRight=""16dp"">              <ImageView                 android:id=""@+id/profile_image""                 android:layout_width=""56dp""                 android:layout_height=""56dp""                 android:layout_centerVertical=""true""                 android:layout_marginEnd=""16dp""                 android:src=""@drawable/photo_2"" />              <TextView                  style=""@style/TextContent""                  android:layout_toEndOf=""@id/profile_image""                 android:text=""@string/my_name""                 android:layout_centerVertical=""true""/>         </RelativeLayout>          <Button             android:layout_width=""match_parent""             android:layout_height=""wrap_content""             android:layout_marginLeft=""16dp""             android:layout_marginRight=""16dp""             android:layout_marginBottom=""16dp""             android:text=""@string/buy"" />     </LinearLayout> </ScrollView> Jika selesai coba jalankan aplikasi Anda. Seharusnya hasilnya seperti ini: Perhatikan bagaimana penulisan di setiap objek  TextView menjadi lebih sederhana: <TextView      style=""@style/TextContent.Subtitle""      android:layout_marginBottom=""8dp""     android:text=""@string/seller"" /> Masih ada yang perlu kita perbaiki. Tombol masih berada dalam kondisi  default  (berwarna abu-abu). Yuk coba ubah agar lebih menyatu dengan tema aplikasi. Buka kembali  themes.xml  dan tambahkan kode berikut di atas  tag   </resources> . <style name=""ButtonGeneral"">     <item name=""android:backgroundTint"">@color/orange</item>     <item name=""android:layout_width"">match_parent</item>     <item name=""android:layout_height"">wrap_content</item>     <item name=""android:layout_marginRight"">16dp</item>     <item name=""android:layout_marginLeft"">16dp</item>     <item name=""android:layout_marginBottom"">16dp</item> </style> Pada  activity_main.xml  kondisikan bagian objek button menjadi seperti ini: <Button      style=""@style/ButtonGeneral""      android:text=""@string/buy"" /> Jalankan aplikasi Anda. Seharusnya tampilannya akan menjadi seperti ini: Sekarang coba Anda klik dan tahan tombolnya. Bila perangkat Android Anda berada di bawah Lollipop (API level 21), seharusnya tombol akan berwarna lebih gelap. Sedangkan jika di atas Lollipop, akan ada efek air ( ripple ) ketika tombol Anda tekan.  Sistem akan secara otomatis mengambil nilai accentColor sebagai nilai warna indikator aktif untuk Button dan nilai pada atribut colorButtonNormal sebagai nilai gelap ketika objek button ditekan. Bedah Kode Theme Pada file  themes.xml : <resources xmlns:tools=""http://schemas.android.com/tools"">     <!-- Base application theme. -->     <style name="" Theme.MyViewAndViews "" parent="" Theme.MaterialComponents.DayNight.DarkActionBar "">         <!-- Primary brand color. -->         <item name="" colorPrimary "">@color/gray</item>         <item name="" colorPrimaryVariant "">@color/gray_dark</item>         <item name="" colorOnPrimary "">@color/white</item>         <!-- Secondary brand color. -->         <item name="" colorSecondary "">@color/orange_light</item>         <item name="" colorSecondaryVariant "">@color/orange_dark</item>         <item name="" colorOnSecondary "">@color/black</item>          <!-- Status bar color. -->         <item name=""android:statusBarColor"" tools:targetApi=""l"">?attr/colorPrimaryVariant</item>         <!-- Customize your theme here. -->     </style>      ...  </resources> Berkas ini menentukan tema dari keseluruhan aplikasi. Dapat dilihat tema yang digunakan di sini, yaitu  Theme.MaterialComponents.DayNight.DarkActionBar   yang merupakan tema  Material Design Component  dengan background putih dan action bar berwarna gelap. Beberapa atribut yang dapat dikustomisasi di dalamnya yaitu: colorPrimary  : warna utama aplikasi yang tampil pada Action Bar dan komponen Button. colorPrimaryVariant  : variasi dari warna utama yang biasanya digunakan pada Status Bar. colorOnPrimary  : warna yang digunakan ketika ada text/icon di atas warna primary. colorSecondary  : warna utama sekunder yang tampil pada Action Bar dan komponen EditText. colorSecondaryVariant  : variasi dari warna sekunder. colorOnSecondary  : warna yang digunakan ketika ada teks/icon di atas warna sekunder. android:statusBarColor  : warna yang digunakan untuk status bar. Jika dilihat,  value  pada masing-masing  attribute  menggunakan awalan  @color/ , yang artinya mengarah ke berkas  color.xml . Mari kita lihat berkas tersebut: <resources>     <color name=""gray"">#607D8B</color>     <color name=""gray_light"">#B0BEC5</color>     <color name=""gray_dark"">#455A64</color>     <color name=""orange"">#FF5722</color>     <color name=""orange_light"">#FFAB91</color>     <color name=""orange_dark"">#E64A19</color>     <color name=""black"">#FF000000</color>     <color name=""white"">#FFFFFFFF</color>     <color name=""colorSubtitle"">#757575</color>   </resources> Berkas ini digunakan untuk menyimpan segala macam  resource  warna yang diperlukan. Sehingga ketika Anda ingin mengubah suatu warna yang digunakan di banyak tempat, Anda dapat mengubahnya di berkas ini saja. Untuk memilih dan mencoba warna yang tepat, Anda dapat mengeksplorasinya di tautan berikut: Material Pallete Material Color Style Selesai! Saat ini Anda sudah memahami bagaimana  Theme  dan  Style  diterapkan dalam membangun sebuah aplikasi di Android. Pengelompokan atribut untuk  view  yang sama akan lebih memudahkan Anda dalam menentukan dan menyeragamkan format  view  yang akan ditampilkan ke dalam layar. Contohnya lihat kode berikut: <TextView      style=""@style/TextContent.Subtitle""      android:layout_marginBottom=""8dp""     android:text=""@string/seller"" /> Anda bisa menyusun  View  menjadi lebih rapi dan cepat bila memiliki komponen yang sama. Anda bisa memanggil style tersebut di setiap halaman yang Anda butuhkan.  Anda dapat mendalami lebih lanjut materi modul ini dengan membaca tautan berikut: Ui Theme Material Design Source code dapat diunduh pada tautan berikut: Source Code Latihan Style and Theme Selamat! Satu langkah besar sudah anda lalui, sekarang ayo kita lanjut ke materi yang lebih seru!";Pada codelab kali ini, kita akan menerapkan style dan theme pada aplikasi yang telah dibuat sebelumnya, dengan fokus pada pemanfaatan style dan theme dalam aplikasi Android. Proses latihan mencakup pengubahan warna pada theme light dan night, pembuatan custom style baru, serta implementasinya dalam berkas activity_main.xml. Langkah-langkahnya meliputi pengeditan berkas colors.xml dan themes.xml untuk mendefinisikan warna dan style yang digunakan, serta penyesuaian layout pada activity_main.xml agar sesuai dengan tema yang telah ditentukan. Setelah selesai, aplikasi akan memiliki tampilan yang lebih seragam dan menarik, dengan penggunaan style yang menyederhanakan penulisan kode untuk komponen TextView dan penyesuaian pada tombol agar sesuai dengan tema aplikasi. Dengan memahami penerapan theme dan style, pengguna dapat lebih mudah mengelola dan menyusun tampilan aplikasi yang konsisten.
Teori Sangat sederhana tapi sangat berarti. Mengapa? Pada dasarnya interaksi umum antara pengguna dengan aplikasi dalam menampilkan data dengan jumlah yang banyak adalah dengan menggunakan list yang bisa di- scroll  ke atas dan ke bawah. Nah, untuk membuat list tersebut, Anda dapat menggunakan komponen RecyclerView. RecyclerView adalah sebuah komponen tampilan  ( widget )  yang lebih canggih ketimbang pendahulunya, yakni ListView. Gambar di bawah menunjukkan perbedaan ListView dan RecyclerView, jika Anda menggunakan ListView objek dari tiap item akan dibuat semuanya dari awal sampai akhir. Sedangkan jika Anda menggunakan RecyclerView, objek yang dibuat hanya sebatas ukuran layar dan beberapa di atas dan di bawahnya saja. Selanjutnya ia menggunakan kembali item yang sudah tidak terlihat.  Apa dampaknya? Mungkin jika datanya sedikit tidak terasa, tetapi bagaimana jika datanya 1000? Tentu dengan menggunakan RecyclerView aplikasi akan menjadi lebih efisien dan tidak menghabiskan memori.  Sebenarnya masalah pada ListView dapat diatasi dengan menggunakan ViewHolder  pattern , namun penggunaannya belum diharuskan di ListView. Berbeda dengan RecyclerView yang mewajibkan menggunakan ViewHolder. Berikut ini adalah beberapa kelebihan ketika kita menggunakan RecyclerView. Memiliki memori yang ringan dan performa yang baik. Secara default memiliki ViewHolder. Mudah untuk memberikan animasi ketika menambahkan, memperbarui, atau menghapus item dengan ItemAnimator. Mendukung LayoutManager untuk mengubah tata letak. Mendukung pengguliran (scrolling) secara vertikal dan horizontal. Dapat digunakan bersama dengan DiffUtil. Selanjutnya lihatlah gambar penerapan RecyclerView berikut ini: Berikut adalah beberapa bagian yang perlu Anda ketahui untuk menampilkan data dengan RecyclerView. RecyclerView : merupakan komponen ViewGroup yang perlu ditambahkan ke dalam berkas XML. LayoutManager : digunakan untuk mengatur tata letak item di dalam RecyclerView. Berikut beberapa opsi yang bisa Anda pilih. LinearLayoutManager : tampilan satu kolom secara linear. GridLayoutManager : tampilan lebih dari satu kolom atau grid. StaggeredLayoutManager : tampilan menyesuaikan tinggi setiap item. Data source : sumber data yang akan ditampilkan ke dalam RecyclerView, biasanya berupa List/ArrayList. Layout item : berkas tampilan XML untuk setiap baris item. RecyclerView.Adapter : class yang digunakan untuk menghubungkan data source dengan RecyclerView. Di dalamnya terdapat beberapa fungsi berikut. onCreateViewHolder() : digunakan untuk membuat ViewHolder baru yang terhubung dengan layout item. onBindViewHolder() : digunakan untuk menetapkan data source ke dalam ViewHolder sesuai dengan posisinya. getItemCount() : digunakan untuk menetapkan ukuran dari jumlah data yang ingin ditampilkan. RecyclerView.ViewHolder : digunakan untuk menentukan bagaimana data ditampilkan ke dalam Layout Item   Okay, Anda sudah paham dengan komponen-kompenennya. Nah, sekarang kita perlu tahu langkah-langkah mengimplementasikan RecyclerView dari awal sampai data bisa tampil: Menambahkan RecyclerView ke dalam layout. Membuat berkas XML untuk layout item. Membuat class baru dan menambahkan pewarisan RecyclerView.Adapter. Membuat inner class dan menambahkan pewarisan RecyclerView.ViewHolder. Di method onCreate() dalam Activity, buatlah RecyclerView dengan adapter dan layout manager. Anda juga dapat memahami lebih dalam materi RecyclerView   dengan membaca tautan berikut ini: Developer Coaching : Membuat List Pertamamu di Android dengan ListView dan RecyclerView Dicoding Blog : Tips RecyclerView – FAQ Create a List with RecyclerView Documentation : RecyclerView;RecyclerView adalah komponen tampilan yang lebih efisien dibandingkan ListView untuk menampilkan data dalam jumlah besar, karena hanya membuat objek item yang terlihat di layar dan menggunakan kembali item yang tidak terlihat, sehingga menghemat memori dan meningkatkan performa aplikasi. Meskipun ListView dapat dioptimalkan dengan pola ViewHolder, RecyclerView mewajibkan penggunaannya dan menawarkan berbagai kelebihan, seperti memori yang lebih ringan, dukungan untuk animasi saat menambah atau menghapus item, serta fleksibilitas dalam tata letak melalui LayoutManager. Untuk menggunakan RecyclerView, Anda perlu menambahkannya ke layout XML, membuat layout item dalam berkas XML, dan membuat class yang mewarisi RecyclerView.Adapter dan RecyclerView.ViewHolder. Proses implementasi meliputi pengaturan RecyclerView dengan adapter dan layout manager di dalam Activity. Dengan memahami komponen dan langkah-langkah ini, Anda dapat dengan mudah menampilkan data menggunakan RecyclerView.
"Latihan RecyclerView Tujuan Pada  codelab   kali ini kalian akan mempelajari cara menampilkan data Pahlawan ke dalam sebuah RecyclerView. Beberapa poin yang akan diulas dalam materi ini adalah: Mengerti cara menggunakan RecyclerView. Mengerti berbagai macam RecyclerView seperti  list  dan  grid . Membuat onClick pada Recyclerview. Contoh dari RecyclerView yang akan kita buat dalam dalam bentuk  list  dan  grid  dengan bentuk kartu menggunakan cardview, di mana semuanya berada dalam satu halaman saja. Alur Latihan Berikut alur yang akan kita pelajari dalam latihan ini:  Menambahkan RecyclerView. Membuat item layout. Membuat Data Class. Membuat Adapter RecyclerView. Mengatur Layout Manager dan Adapter. Menambahkan OnClick pada Adapter. Membuat callback untuk OnClick pada Adapter. Mengubah tampilan list menjadi grid menggunakan Layout Manager. Codelab Latihan RecyclerView Buat Project baru di Android Studio dengan kriteria sebagai berikut: Nama Project MyRecyclerView Target & Minimum Target SDK Phone and Tablet, API level 21 Tipe Activity Empty Activity Activity Name MainActivity Use AndroidX Artifacts True Language Kotlin/Java Jika project menggunakan  Kotlin , Anda perlu menambahkan plugin  kotlin-parcelize  untuk menggunakan fitur  @Parcelize . Untuk menerapkan fitur ini, Anda harus menggunakan  Kotlin 1.4.20 ke atas . Cek pada  build.gradle (module: app) . plugins {     id 'com.android.application'     id 'kotlin-android'      id 'kotlin-parcelize'  } Sambil menunggu proses sync, mari kita unduh terlebih dahulu asset yang dibutuhkan dalam latihan kali ini dalam  Kumpulan Gambar Pahlawan . Setelah proses  sync project  selesai, ekstraklah berkas zip tersebut, kemudian masukkan ke dalam folder  drawable . Setelah itu Anda diminta untuk menentukan spesifikasi lokasi untuk berkas tersebut. Silakan klik Refactor untuk menyetujuinya. Ketika berhasil, hasilnya akan jadi seperti ini: Oke, lanjut pada  activity_main.xml.  Untuk menambahkan RecyclerView, silakan drag item RecyclerView ke dalam screen. Perhatikan, selain menambahkan RecyclerView, kita juga perlu mengatur posisi dari Constraint Layout, serta menambahkan  id  dari RecyclerView yakni  rv_heroes . Setelah menambahkan RecyclerView ke dalam screen, Anda bisa melihat kodenya akan menjadi seperti ini: <?xml version=""1.0"" encoding=""utf-8""?> <androidx.constraintlayout.widget.ConstraintLayout      xmlns:android=""http://schemas.android.com/apk/res/android""     xmlns:app=""http://schemas.android.com/apk/res-auto""     android:layout_width=""match_parent""     android:layout_height=""match_parent"">       <androidx.recyclerview.widget.RecyclerView         android:id=""@+id/rv_heroes""         android:layout_width=""0dp""         android:layout_height=""0dp""         app:layout_constraintBottom_toBottomOf=""parent""         app:layout_constraintEnd_toEndOf=""parent""         app:layout_constraintStart_toStartOf=""parent""         app:layout_constraintTop_toTopOf=""parent"" />   </androidx.constraintlayout.widget.ConstraintLayout> Oke, komponen RecyclerView sudah ditambahkan, kini saatnya kita membuat sebuah item tampilan dalam bentuk berkas  layout  xml yang akan ditampilkan di RecyclerView. Karena data pertama kali akan ditampilkan dalam bentuk  list , maka kita buat  layout  dengan cara klik kanan pada direktori  layout → new → layout resource file  dan kemudian beri nama  item_row_hero . Pastikan  Root  element  menggunakan  Constraint Layout  terlebih dahulu. Setelah terbentuk, silakan buat desain untuk layout item seperti ini: <?xml version=""1.0"" encoding=""utf-8""?> <androidx.cardview.widget.CardView xmlns:android=""http://schemas.android.com/apk/res/android""     xmlns:card_view=""http://schemas.android.com/apk/res-auto""     xmlns:tools=""http://schemas.android.com/tools""     android:id=""@+id/card_view""     android:layout_width=""match_parent""     android:layout_height=""wrap_content""     android:layout_gravity=""center""     android:layout_marginStart=""8dp""     android:layout_marginTop=""4dp""     android:layout_marginEnd=""8dp""     android:layout_marginBottom=""4dp""     card_view:cardCornerRadius=""4dp"">      <androidx.constraintlayout.widget.ConstraintLayout         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:padding=""8dp"">          <ImageView             android:id=""@+id/img_item_photo""             android:layout_width=""70dp""             android:layout_height=""100dp""             android:scaleType=""centerCrop""             card_view:layout_constraintBottom_toBottomOf=""parent""             card_view:layout_constraintStart_toStartOf=""parent""             card_view:layout_constraintTop_toTopOf=""parent""             tools:src=""@tools:sample/avatars"" />          <TextView             android:id=""@+id/tv_item_name""             android:layout_width=""0dp""             android:layout_height=""wrap_content""             android:layout_marginStart=""8dp""             android:layout_marginEnd=""8dp""             android:layout_toEndOf=""@id/img_item_photo""             android:textSize=""16sp""             android:textStyle=""bold""             card_view:layout_constraintEnd_toEndOf=""parent""             card_view:layout_constraintStart_toEndOf=""@+id/img_item_photo""             card_view:layout_constraintTop_toTopOf=""@+id/img_item_photo""             tools:text=""@string/heroes_name"" />          <TextView             android:id=""@+id/tv_item_description""             android:layout_width=""0dp""             android:layout_height=""0dp""             android:layout_marginTop=""8dp""             android:ellipsize=""end""             android:maxLines=""5""             card_view:layout_constraintBottom_toBottomOf=""@+id/img_item_photo""             card_view:layout_constraintEnd_toEndOf=""@+id/tv_item_name""             card_view:layout_constraintStart_toStartOf=""@+id/tv_item_name""             card_view:layout_constraintTop_toBottomOf=""@+id/tv_item_name""             card_view:layout_constraintVertical_bias=""0.0""             tools:text=""@string/description"" />     </androidx.constraintlayout.widget.ConstraintLayout> </androidx.cardview.widget.CardView> tools:text  bisa kita gunakan untuk  placeholder  di dalam editor  layout . Atribut ini tidak akan terbawa saat  run-time  dan hanya akan nampak di dalam  preview  editor saja. Akan ada yang eror pada bagian  @string/heroes_name . Seperti pada modul sebelumnya, Anda perlu masuk ke dalam  res → values  → strings.xml . Tambahkan kode seperti berikut. <resources>     <string name=""app_name"">MyRecyclerView</string>       <string name=""heroes_name"">Nama Pahlawan</string>     <string name=""description"">Deskripsi</string>      <string-array name=""data_name"">         <item>Ahmad Dahlan</item>         <item>Ahmad Yani</item>         <item>Sutomo</item>         <item>Gatot Soebroto</item>         <item>Ki Hadjar Dewantara</item>         <item>Mohammad Hatta</item>         <item>Soedirman</item>         <item>Soekarno</item>         <item>Soepomo</item>     </string-array>      <string-array name=""data_description"">         <item>Salah seorang ulama dan khatib terkemuka di Masjid Besar Kasultanan Yogyakarta pada masa itu, dan ibu dari K.H. Ahmad Dahlan adalah puteri dari H. Ibrahim yang juga menjabat penghulu Kesultanan Ngayogyakarta Hadiningrat pada masa itu. KH. Ahmad Dahlan telah mempelopori kebangkitan ummat Islam untuk menyadari nasibnya sebagai bangsa terjajah yang masih harus belajar dan berbuat. </item>         <item>Jenderal TNI Anumerta Ahmad Yani (juga dieja Achmad Yani; lahir di Purworejo, Jawa Tengah, 19 Juni 1922 – meninggal di Lubang Buaya, Jakarta, 1 Oktober 1965 pada umur 43 tahun) adalah komandan Tentara Nasional Indonesia Angkatan Darat, dan dibunuh oleh anggota Gerakan 30 September saat mencoba untuk menculik dia dari rumahnya.</item>         <item>Sutomo (lahir di Surabaya, Jawa Timur, 3 Oktober 1920 – meninggal di Padang Arafah, Arab Saudi, 7 Oktober 1981 pada umur 61 tahun) lebih dikenal dengan sapaan akrab oleh rakyat sebagai Bung Tomo, adalah pahlawan yang terkenal karena peranannya dalam membangkitkan semangat rakyat untuk melawan kembalinya penjajah Belanda melalui tentara NICA, yang berakhir dengan pertempuran 10 November 1945 yang hingga kini diperingati sebagai Hari Pahlawan.</item>         <item>Jenderal TNI (Purn.) Gatot Soebroto (lahir di Sumpiuh, Banyumas, Jawa Tengah, 10 Oktober 1907 – meninggal di Jakarta, 11 Juni 1962 pada umur 54 tahun) adalah tokoh perjuangan militer Indonesia dalam merebut kemerdekaan dan juga pahlawan nasional Indonesia. Ia dimakamkan di Ungaran, kabupaten Semarang.</item>         <item>Raden Mas Soewardi Soerjaningrat (EBI: Suwardi Suryaningrat, sejak 1922 menjadi Ki Hadjar Dewantara, EBI: Ki Hajar Dewantara, beberapa menuliskan bunyi bahasa Jawanya dengan Ki Hajar Dewantoro; lahir di Pakualaman, 2 Mei 1889 – meninggal di Yogyakarta, 26 April 1959 pada umur 69 tahun; selanjutnya disingkat sebagai ""Soewardi"" atau ""KHD"") adalah aktivis pergerakan kemerdekaan Indonesia, kolumnis, politisi, dan pelopor pendidikan bagi kaum pribumi Indonesia dari zaman penjajahan Belanda. Ia adalah pendiri Perguruan Taman Siswa, suatu lembaga pendidikan yang memberikan kesempatan bagi para pribumi untuk bisa memperoleh hak pendidikan seperti halnya para priyayi maupun orang-orang Belanda.</item>         <item>Dr.(HC) Drs. H. Mohammad Hatta (lahir dengan nama Mohammad Athar, dikenal sebagai Bung Hatta; lahir di Fort de Kock (sekarang Bukittinggi, Sumatera Barat), Hindia Belanda, 12 Agustus 1902 – meninggal di Jakarta, 14 Maret 1980 pada umur 77 tahun) adalah tokoh pejuang, negarawan, ekonom, dan juga Wakil Presiden Indonesia yang pertama. Ia bersama Soekarno memainkan peranan penting untuk memerdekakan bangsa Indonesia dari penjajahan Belanda sekaligus memproklamirkannya pada 17 Agustus 1945. Ia juga pernah menjabat sebagai Perdana Menteri dalam Kabinet Hatta I, Hatta II, dan RIS. Ia mundur dari jabatan wakil presiden pada tahun 1956, karena berselisih dengan Presiden Soekarno. Hatta juga dikenal sebagai Bapak Koperasi Indonesia.</item>         <item>Jenderal Besar Raden Soedirman (EYD: Sudirman; lahir 24 Januari 1916 – meninggal 29 Januari 1950 pada umur 34 tahun) adalah seorang perwira tinggi Indonesia pada masa Revolusi Nasional Indonesia. Menjadi panglima besar Tentara Nasional Indonesia pertama, ia secara luas terus dihormati di Indonesia. Terlahir dari pasangan rakyat biasa di Purbalingga, Hindia Belanda, Soedirman diadopsi oleh pamannya yang seorang priyayi. Setelah keluarganya pindah ke Cilacap pada tahun 1916, Soedirman tumbuh menjadi seorang siswa rajin; ia sangat aktif dalam kegiatan ekstrakurikuler, termasuk mengikuti program kepanduan yang dijalankan oleh organisasi Islam Muhammadiyah. Saat di sekolah menengah, Soedirman mulai menunjukkan kemampuannya dalam memimpin dan berorganisasi, dan dihormati oleh masyarakat karena ketaatannya pada Islam. Setelah berhenti kuliah keguruan, pada 1936 ia mulai bekerja sebagai seorang guru, dan kemudian menjadi kepala sekolah, di sekolah dasar Muhammadiyah; ia juga aktif dalam kegiatan Muhammadiyah lainnya dan menjadi pemimpin Kelompok Pemuda Muhammadiyah pada tahun 1937. Setelah Jepang menduduki Hindia Belanda pada 1942, Soedirman tetap mengajar. Pada tahun 1944, ia bergabung dengan tentara Pembela Tanah Air (PETA) yang disponsori Jepang, menjabat sebagai komandan batalion di Banyumas. Selama menjabat, Soedirman bersama rekannya sesama prajurit melakukan pemberontakan, namun kemudian diasingkan ke Bogor.</item>         <item>Dr.(H.C.) Ir. H. Soekarno (ER, EYD: Sukarno, nama lahir: Koesno Sosrodihardjo) (lahir di Surabaya, Jawa Timur, 6 Juni 1901 – meninggal di Jakarta, 21 Juni 1970 pada umur 69 tahun) adalah Presiden pertama Republik Indonesia yang menjabat pada periode 1945–1967. Ia memainkan peranan penting dalam memerdekakan bangsa Indonesia dari penjajahan Belanda. Ia adalah Proklamator Kemerdekaan Indonesia (bersama dengan Mohammad Hatta) yang terjadi pada tanggal 17 Agustus 1945. Soekarno adalah yang pertama kali mencetuskan konsep mengenai Pancasila sebagai dasar negara Indonesia dan ia sendiri yang menamainya.</item>         <item>Prof. Mr. Dr. Soepomo (Ejaan Soewandi: Supomo; lahir di Sukoharjo, Jawa Tengah, 22 Januari 1903 – meninggal di Jakarta, 12 September 1958 pada umur 55 tahun) adalah seorang pahlawan nasional Indonesia. Soepomo dikenal sebagai arsitek Undang-undang Dasar 1945, bersama dengan Muhammad Yamin dan Soekarno.</item>     </string-array>       <integer-array name=""data_photo"">         <item>@drawable/ahmad_dahlan</item>         <item>@drawable/ahmad_yani</item>         <item>@drawable/bung_tomo</item>         <item>@drawable/gatot_subroto</item>         <item>@drawable/ki_hadjar_dewantara</item>         <item>@drawable/mohammad_hatta</item>         <item>@drawable/sudirman</item>         <item>@drawable/sukarno</item>         <item>@drawable/supomo</item>     </integer-array>  </resources> Hasil jadi desain dapat dilihat menggunakan tab Split atau Design seperti ini. Kemudian buat sebuah kelas model data bernama  Hero  dengan cara  klik kanan pada nama package  → new → Java/Kotlin class . Class ini nantinya digunakan untuk menampung property data yang akan ditampilkan. Beri nama  Hero  dan pilih  Data  Class . Kemudian tekan  Enter . Setelah itu, kita bisa menambahkan property data yang akan ditampilkan, seperti nama, deskripsi, dan photo. Kotlin data  class Hero(      val name: String,     val description: String,     val photo: Int  ) Java public class Hero {       private String name;     private String description;     private Integer photo;   } Untuk kelas Java, ada cara otomatis untuk membuat  setter  &  getter . Caranya,   klik kanan  pada  text editor   lalu pilih  Generate  dan pilih  Getter and Setter.  Pilih semua variabel. Maka  setter and getter  akan ter- generate  secara otomatis. public class Hero {     private String name;     private String description;     private String photo;       public String getName() {         return name;     }      public void setName(String name) {         this.name = name;     }      public String getDescription() {         return description;     }      public void setDescription(String description) {         this.description = description;     }      public Integer getPhoto() {         return photo;     }      public void setPhoto(Integer photo) {         this.photo = photo;     }  } Jangan lupa untuk menambahkan implementasi parcelable ke kelas  Hero  seperti pada Modul  Intent Explicit dengan Parcelable . Kotlin @Parcelize  data class Hero(     val name: String,     val description: String,     val photo: Int )  : Parcelable Java public class Hero  implements Parcelable  {     private String name;     private String description;     private Integer photo;      public String getName() {         return name;     }      public void setName(String name) {         this.name = name;     }      public String getDescription() {         return description;     }      public void setDescription(String description) {         this.description = description;     }      public Integer getPhoto() {         return photo;     }      public void setPhoto(Integer photo) {         this.photo = photo;     }       @Override     public int describeContents() {         return 0;     }      @Override     public void writeToParcel(Parcel dest, int flags) {         dest.writeString(this.name);         dest.writeString(this.description);         dest.writeInt(this.photo);     }      Hero() {     }      private Hero(Parcel in) {         this.name = in.readString();         this.description = in.readString();         this.photo = in.readInt();     }      public static final Parcelable.Creator<Hero> CREATOR = new Parcelable.Creator<Hero>() {         @Override         public Hero createFromParcel(Parcel source) {             return new Hero(source);         }          @Override         public Hero[] newArray(int size) {             return new Hero[size];         }     };  } Untuk Kotlin menggunakan  Kotlin Parcelize , sedangkan untuk Java menggunakan  Add Parcelable Impementation. Sekarang kita akan membuat sebuah adapter yang akan memformat bagaimana tiap elemen dari koleksi data ditampilkan. Buat kelas adapter secara manual dengan klik kanan pada  package utama → new → Kotlin/Java Class  dan beri nama  ListHeroAdapter . Setelah kelas adapter berhasil dibuat, lengkapi kodenya menjadi seperti berikut: Kotlin class ListHeroAdapter :  RecyclerView.Adapter<ListHeroAdapter.ListViewHolder>()  {  } Java public class ListHeroAdapter  extends RecyclerView.Adapter<ListHeroAdapter.ListViewHolder> {       } Kemudian muncul garis merah pada kode, begitu pun pada  ListViewHolder . Kita resolve satu per satu. Pertama adalah kita tekan  alt+enter / klik tombol  merah  pada  ListViewHolder  dan pilih  Create class ListViewHolder , kemudian pilih  ListHeroAdapter   karena kita akan membuat sebuah  inner class : Kemudian  pilih  ListHeroAdapter   untuk membuat kelas ListViewHolder di dalam ListHeroAdapter. Sehingga, kini kodenya menjadi seperti berikut: Kotlin class ListHeroAdapter : RecyclerView.Adapter<ListHeroAdapter.ListViewHolder>() {      class ListViewHolder {      }  } Java public class ListHeroAdapter extends RecyclerView.Adapter<ListHeroAdapter.ListViewHolder> {      public class ListViewHolder {     }  } Masih ada garis merah,  arahkan kursor ke teks  class ListHeroAdapter  kita lakukan lagi  alt+enter / klik tombol merah  dan pilih  implement members (Kotlin)  atau  implement methods(Java). Kotlin Java Kemudian pilih ketiga metode dari RecyclerView.Adapter. Maka kode saat ini menjadi seperti ini: Kotlin class ListHeroAdapter : RecyclerView.Adapter<ListHeroAdapter.ListViewHolder>() {      override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ListViewHolder {         TODO(""not implemented"") //To change body of created functions use File | Settings | File Templates.     }      override fun getItemCount(): Int {         TODO(""not implemented"") //To change body of created functions use File | Settings | File Templates.     }      override fun onBindViewHolder(holder: ListViewHolder, position: Int) {         TODO(""not implemented"") //To change body of created functions use File | Settings | File Templates.     }       class ListViewHolder {      } } Java public class ListHeroAdapter extends RecyclerView.Adapter<ListHeroAdapter.ListViewHolder> {       @NonNull     @Override     public ListViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {         return null;     }      @Override     public void onBindViewHolder(@NonNull ListViewHolder listViewHolder, int position) {      }      @Override     public int getItemCount() {         return 0;     }       public class ListViewHolder {     } } Masih ada garis merah, hal ini karena  ListViewHolder  seharusnya inherit ke RecyclerView.ViewHolder, maka ubah kodenya menjadi seperti ini : Kotlin class ListHeroAdapter : RecyclerView.Adapter<ListHeroAdapter.ListViewHolder>() {     ...      class ListViewHolder : RecyclerView.ViewHolder  {      } } Java public class ListHeroAdapter extends RecyclerView.Adapter<ListHeroAdapter.ListViewHolder> {     ...      public class ListViewHolder  extends RecyclerView.ViewHolder  {     } } Untuk Java bisa juga dilakukan dengan cara  alt+enter / klik tombol merah  dan pilih  Make ListViewHolder extend RecyclerView.ViewHolder . Masih ada garis merah kita lakukan lagi  alt+enter  /  klik  tombol merah  dan  pilih Add constructor paremeter from ViewHolder(View)  atau  Create constructor matching super(Java). Kotlin Java Sehingga, kini kodenya menjadi seperti berikut: Kotlin class ListHeroAdapter : RecyclerView.Adapter<ListHeroAdapter.ListViewHolder>() {     ...       class ListViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {           }  } Java public class ListHeroAdapter extends RecyclerView.Adapter<ListHeroAdapter.ListViewHolder> {     ...      class ListViewHolder extends RecyclerView.ViewHolder {          public ListViewHolder(@NonNull View itemView) {             super(itemView);         }      } } Kemudian buatlah  constructor  untuk  list  seperti ini: Kotlin class ListHeroAdapter (private val listHero: ArrayList<Hero>)  : RecyclerView.Adapter<ListHeroAdapter.ListViewHolder>() {     ... } Java public class ListHeroAdapter extends RecyclerView.Adapter<ListHeroAdapter.ListViewHolder> {      private ArrayList<Hero> listHero;      public ListHeroAdapter(ArrayList<Hero> list) {         this.listHero = list;     }       ... } Setelah itu kita bisa melengkapi kode kode hasil dari turunan RecyclerView.Adapter. Maka kode lengkap dari kelas  ListHeroAdapter  sebagai berikut: Kotlin class ListHeroAdapter(private val listHero: ArrayList<Hero>) : RecyclerView.Adapter<ListHeroAdapter.ListViewHolder>() {      override fun onCreateViewHolder( parent : ViewGroup, viewType: Int): ListViewHolder {          val view: View = LayoutInflater.from(parent.context).inflate(R.layout.item_row_hero, parent, false)           return ListViewHolder(view)      }      override fun onBindViewHolder(holder: ListViewHolder, position: Int) {          val (name, description, photo) = listHero[position]         holder.imgPhoto.setImageResource(photo)         holder.tvName.text = name         holder.tvDescription.text = description      }      override fun getItemCount(): Int =  listHero.size       class ListViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {          val imgPhoto: ImageView = itemView.findViewById(R.id.img_item_photo)         val tvName: TextView = itemView.findViewById(R.id.tv_item_name)         val tvDescription: TextView = itemView.findViewById(R.id.tv_item_description)      } } Java public class ListHeroAdapter extends RecyclerView.Adapter<ListHeroAdapter.ListViewHolder> {     private ArrayList<Hero> listHero;      public ListHeroAdapter(ArrayList<Hero> list) {         this.listHero = list;     }      @NonNull     @Override     public ListViewHolder onCreateViewHolder(@NonNull ViewGroup  parent , int viewType) {          View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_row_hero, parent, false);         return new ListViewHolder(view);      }      @Override     public void onBindViewHolder(@NonNull final ListViewHolder holder, int position) {          Hero hero = listHero.get(position);         holder.imgPhoto.setImageResource(hero.getPhoto());         holder.tvName.setText(hero.getName());         holder.tvDescription.setText(hero.getDescription());      }      @Override     public int getItemCount() {          return listHero.size();      }      class ListViewHolder extends RecyclerView.ViewHolder {          ImageView imgPhoto;         TextView tvName, tvDescription;           ListViewHolder(View itemView) {             super(itemView);              imgPhoto = itemView.findViewById(R.id.img_item_photo);             tvName = itemView.findViewById(R.id.tv_item_name);             tvDescription = itemView.findViewById(R.id.tv_item_description);          }     } } Catatan:  Variabel parent didapat dari parameter yang ada pada fungsi onCreateViewHolder. Apabila hasil generate pada Android Studio Anda berbeda (misal viewGroup, bukan parent). Silakan sesuaikan saja dengan parameternya atau nama variabelnya. Kemudian kita modifikasi berkas kelas  MainActivity  dan atur   fixed  size RecyclerView yang sudah dibuat di  activity_main . Kotlin class MainActivity : AppCompatActivity() {      private lateinit var rvHeroes: RecyclerView       override fun onCreate(savedInstanceState: Bundle?) {         super.onCreate(savedInstanceState)         setContentView(R.layout.activity_main)           rvHeroes = findViewById(R.id.rv_heroes)         rvHeroes.setHasFixedSize(true)      } } Java public class MainActivity extends AppCompatActivity {      private   RecyclerView rvHeroes;       @Override     protected void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout. activity_main );           rvHeroes  = findViewById(R.id.rv_heroes);         rvHeroes.setHasFixedSize(true);      } } Selanjutnya setelah diinisiasikan, kita akan panggil data yang sudah kita buat di  resource  strings.xml . Kotlin class MainActivity : AppCompatActivity() {     private lateinit var rvHeroes: RecyclerView      private val list = ArrayList<Hero>()       override fun onCreate(savedInstanceState: Bundle?) {         super.onCreate(savedInstanceState)         setContentView(R.layout.activity_main)          rvHeroes = findViewById(R.id.rv_heroes)         rvHeroes.setHasFixedSize(true)           list.addAll(getListHeroes())         showRecyclerList()      }       private fun getListHeroes(): ArrayList<Hero> {         val dataName = resources.getStringArray(R.array.data_name)         val dataDescription = resources.getStringArray(R.array.data_description)         val dataPhoto = resources.obtainTypedArray(R.array.data_photo)         val listHero = ArrayList<Hero>()         for (i in dataName.indices) {             val hero = Hero(dataName[i], dataDescription[i], dataPhoto.getResourceId(i, -1))             listHero.add(hero)         }         return listHero     }        private fun showRecyclerList() {         rvHeroes.layoutManager = LinearLayoutManager(this)         val listHeroAdapter = ListHeroAdapter(list)         rvHeroes.adapter = listHeroAdapter     }  } Java public class MainActivity extends AppCompatActivity {     private RecyclerView rvHeroes;      private ArrayList<Hero> list = new ArrayList<>();       @Override     protected void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout.activity_main);          rvHeroes = findViewById(R.id.rv_heroes);         rvHeroes.setHasFixedSize(true);           list.addAll(getListHeroes() );         showRecyclerList();      }       public ArrayList<Hero> getListHeroes() {         String[] dataName = getResources().getStringArray(R.array.data_name);         String[] dataDescription = getResources().getStringArray(R.array.data_description);          TypedArray dataPhoto = getResources().obtainTypedArray(R.array.data_photo);           ArrayList<Hero> listHero = new ArrayList<>();         for (int i = 0; i < dataName.length; i++) {             Hero hero = new Hero();             hero.setName(dataName[i]);             hero.setDescription(dataDescription[i]);              hero.setPhoto(dataPhoto.getResourceId(i, -1));               listHero.add(hero);         }         return listHero;     }        private void showRecyclerList(){         rvHeroes.setLayoutManager(new LinearLayoutManager(this));         ListHeroAdapter listHeroAdapter = new ListHeroAdapter(list);         rvHeroes.setAdapter(listHeroAdapter);     }  } Jalankan aplikasi yang dibuat. Hasilnya kurang lebih akan seperti gambar di bawah ini: Mantap! Pertanyaannya, bagaimana cara menambahkan aksi pada item tersebut? Oke mari kita tambahkan. Codelab Latihan OnClick pada Item RecyclerView Pertanyaannya, bagaimana menambahkan aksi onClick pada item tersebut? Apakah ada modifier/fungsi untuk onItemClick dalam RecyclerView? Tentu tidak ada. Namun, kita bisa mengaturnya pada bagian itemnya. Penasaran? Yuk, ikut beberapa langkah berikut: Bukalah kelas  ListHeroAdapter  dan perhatikan kode berikut: Kotlin override fun onBindViewHolder(holder: ListViewHolder, position: Int) {     val (name, description, photo) = listHero[position]     holder.imgPhoto.setImageResource(photo)     holder.tvName.text = name     holder.tvDescription.text = description } Java @Override public void onBindViewHolder(@NonNull final ListViewHolder holder, int position) {     Hero hero = listHero.get(position);     holder.imgPhoto.setImageResource(hero.getPhoto());     holder.tvName.setText(hero.getName());     holder.tvDescription.setText(hero.getDescription()); } Pada bagian ini, kita bisa menambahkan fungsi onclick setiap itemnya ditekan. Tambahkan kode baris berikut ke dalam fungsi onBindViewHolder. Kotlin holder.itemView.setOnClickListener {     Toast.makeText(holder.itemView.context, ""Kamu memilih "" + listHero[holder.adapterPosition].name, Toast.LENGTH_SHORT).show() } Java holder.itemView.setOnClickListener(v -> {     Toast.makeText(holder.itemView.getContext(), ""Kamu memilih "" + listHero.get(holder.getAdapterPosition()).getName(), Toast.LENGTH_SHORT).show(); }); Maka hasilnya jadi seperti ini: Kotlin override fun onBindViewHolder(holder: ListViewHolder, position: Int) {     val (name, description, photo) = listHero[position]     holder.imgPhoto.setImageResource(photo)     holder.tvName.text = name     holder.tvDescription.text = description      holder.itemView.setOnClickListener {          Toast.makeText(holder.itemView.context, ""Kamu memilih "" + listHero[holder.adapterPosition].name, Toast.LENGTH_SHORT).show()      }  } Java @Override public void onBindViewHolder(@NonNull final ListViewHolder holder, int position) {     Hero hero = listHero.get(position);     holder.imgPhoto.setImageResource(hero.getPhoto());     holder.tvName.setText(hero.getName());     holder.tvDescription.setText(hero.getDescription());       holder.itemView.setOnClickListener(v -> {         Toast.makeText(holder.itemView.getContext(), ""Kamu memilih "" + listHero.get(holder.getAdapterPosition()).getName(), Toast.LENGTH_SHORT).show();     });  } Setelah itu, jalankan kembali dan pilih salah satu item. Pertanyaan selanjutnya, bagaimana jika kita ingin agar fungsi  onClick  dapat dipicu atau di- trigger  dari kelas MainActivity? Silakan hapus fungsi onClick yang telah Anda buat sebelumnya, kemudian tambahkan  interface  berikut dan implementasikan  onClick ke kelas interface berikut: Kotlin class ListHeroAdapter(val listHero: ArrayList<Hero>) : RecyclerView.Adapter<ListHeroAdapter.ListViewHolder>() {      private lateinit var onItemClickCallback: OnItemClickCallback        fun setOnItemClickCallback(onItemClickCallback: OnItemClickCallback) {          this.onItemClickCallback = onItemClickCallback      }       ...      override fun onBindViewHolder(holder: ListViewHolder, position: Int) {         ...           holder.itemView.setOnClickListener { onItemClickCallback.onItemClicked(listHero[holder.adapterPosition]) }      }      ...       interface OnItemClickCallback {         fun onItemClicked(data: Hero)     }  } Java public class ListHeroAdapter extends RecyclerView.Adapter<ListHeroAdapter.ListViewHolder> {     ...       private OnItemClickCallback onItemClickCallback;      public void setOnItemClickCallback(OnItemClickCallback onItemClickCallback) {         this.onItemClickCallback = onItemClickCallback;     }       ...      @Override     public void onBindViewHolder(@NonNull  final  ListViewHolder holder, int position) {         ...           holder.itemView.setOnClickListener(v -> onItemClickCallback.onItemClicked(listHero.get(holder.getAdapterPosition())));       }      ...       public interface OnItemClickCallback {         void onItemClicked(Hero data);     }  } Kemudian bukalah  MainActivity  dan tambahkan satu metode ini untuk menandakan item mana yang dipilih. Kotlin private fun showSelectedHero(hero: Hero) {     Toast.makeText(this, ""Kamu memilih "" + hero.name, Toast.LENGTH_SHORT).show() } Java private void showSelectedHero(Hero hero) {     Toast.makeText(this, ""Kamu memilih "" + hero.getName(), Toast.LENGTH_SHORT).show(); } Kemudian tambahkan pada masing-masing metode di  list  seperti berikut: Kotlin private fun showRecyclerList() {     rvHeroes.layoutManager = LinearLayoutManager(this)     val listHeroAdapter = ListHeroAdapter(list)     rvHeroes.adapter = listHeroAdapter        listHeroAdapter.setOnItemClickCallback(object : ListHeroAdapter.OnItemClickCallback {         override fun onItemClicked(data: Hero) {             showSelectedHero(data)         }     })  } Java private void showRecyclerList() {     rvHeroes.setLayoutManager(new LinearLayoutManager(this));     ListHeroAdapter listHeroAdapter = new ListHeroAdapter(list);     rvHeroes.setAdapter(listHeroAdapter);       listHeroAdapter.setOnItemClickCallback(data -> showSelectedHero(data));  } Sekarang jalankan kembali aplikasinya. Klik salah satu item pada RecyclerView. Seharusnya Toast masih bisa tampil ketika salah satu item ditekan.  Secara tampilan memang tidak ada bedanya, namun secara kode Anda akan menemukan beberapa skenario tersebut. Codelab Latihan Mengubah Tampilan pada RecyclerView Anda juga bisa mengubah tampilan  List  menjadi mode  Grid . Namun sebelum itu, buat terlebih dahulu menu untuk menampilkan opsi tampilan pada App Bar. Ikut beberapa langkah berikut untuk melakukannya: Langkah pertama adalah dengan membuat resource directory terkait. Resource directory menu secara bawaan tidak disediakan. Kita harus membuatnya t";Pada codelab kali ini, Anda akan belajar cara menampilkan data Pahlawan dalam RecyclerView dengan berbagai tampilan, termasuk list dan grid, serta menambahkan aksi onClick pada item. Proses latihan dimulai dengan membuat proyek baru di Android Studio, menambahkan RecyclerView ke dalam layout, dan membuat item layout untuk setiap elemen yang akan ditampilkan. Anda juga akan membuat kelas data Hero untuk menyimpan informasi pahlawan, serta adapter ListHeroAdapter untuk menghubungkan data dengan RecyclerView. Selain itu, Anda akan menerapkan fungsi onClick pada item RecyclerView dan memodifikasi tampilan dari list menjadi grid menggunakan LayoutManager. Dengan mengikuti langkah-langkah ini, Anda akan mendapatkan pemahaman yang lebih baik tentang cara kerja RecyclerView, cara menampilkan data secara efisien, serta cara menangani interaksi pengguna dengan item yang ditampilkan. Setelah semua langkah selesai, Anda dapat menjalankan aplikasi dan melihat hasilnya, termasuk kemampuan untuk beralih antara tampilan list dan grid serta menampilkan informasi pahlawan saat item diklik.
Modul kelas Belajar Membuat Aplikasi Android untuk Pemula dalam bentuk cetak (buku) maupun elektronik sudah didaftarkan ke Dirjen HKI, Kemenkumham RI. Segala bentuk penggandaan dan atau komersialisasi, sebagian atau seluruh bagian, baik cetak maupun elektronik terhadap modul kelas Belajar Membuat Aplikasi Android untuk Pemula tanpa izin formal tertulis kepada pemilik hak cipta akan diproses melalui jalur hukum. Hak cipta dilindungi oleh Undang-undang © Dicoding 2017 - 2023. Dengan lanjut ke materi berikutnya,   Anda menyetujui adanya informasi hak cipta di atas terhadap modul dalam kelas ini.;"Dengan melanjutkan ke materi berikutnya, Anda menyetujui dan memahami bahwa modul kelas ""Belajar Membuat Aplikasi Android untuk Pemula"" dilindungi oleh hak cipta yang terdaftar di Dirjen HKI, Kemenkumham RI. Segala bentuk penggandaan atau komersialisasi, baik secara cetak maupun elektronik, tanpa izin tertulis dari pemilik hak cipta, akan dikenakan sanksi hukum sesuai dengan peraturan yang berlaku. Hak cipta ini melindungi materi yang telah disusun oleh Dicoding dari tahun 2017 hingga 2023. Pastikan untuk menghormati dan mematuhi ketentuan ini saat menggunakan materi pembelajaran. Selamat belajar!"
Mekanisme Belajar Selamat datang di Dicoding Academy. Sebelum memulai belajar di kelas ini, Anda perlu tahu tahapan dan cara belajar beserta fasilitas yang tersedia agar proses belajar lebih efektif. Materi Pembelajaran Materi Bacaan Elektronik Materi yang ada dalam kelas ini mayoritas berupa teks atau tulisan. Mengapa demikian? Karena kami menemukan bahwa dalam proses belajar di bidang pemrograman, bentuk materi pembelajaran yang paling efektif untuk diingat, dimengerti, dan yang terpenting, dipraktikkan, adalah dalam bentuk teks. Forum Diskusi Setiap kelas memiliki sebuah forum diskusi yang dapat Anda gunakan untuk bertanya (dan menjawab) mengenai materi kelas. Instruktur kami yang terdiri dari Curriculum Developer dan Academy Code Reviewer siap membantu Anda melalui forum diskusi ini. Tak hanya kami, Anda pun dapat berpartisipasi. Untuk meningkatkan retensi ilmu yang Anda punya, berbagi adalah salah satu kuncinya. Jadi, silakan aktif dan saling membantu di dalam forum. Jika Anda menemui kendala perihal situs Dicoding dan administrasi kelas, tanyakan kepada kami melalui tombol chat di kanan bawah layar Anda ketika membuka situs Dicoding. Jangan gunakan forum diskusi ya karena itu salah alamat. Evaluasi Pembelajaran Ujian (Kuis, Ujian Akhir Kelas, Knowledge Check) Terdapat berbagai jenis ujian di kelas guna mengecek pemahaman Anda pada materi pembelajaran. Ketersediaan ujian beserta jenis ujian yang tersedia pada setiap kelas dapat berbeda-beda. Setiap pertanyaan dalam ujian pasti mencakup materi yang telah dibahas. Sehingga jika ada pertanyaan yang tidak dapat Anda jawab, pastikan Anda mengulang kembali pembelajaran.;Selamat datang di Dicoding Academy! Sebelum memulai, penting untuk memahami tahapan belajar dan fasilitas yang tersedia untuk meningkatkan efektivitas pembelajaran Anda. Materi pembelajaran di kelas ini sebagian besar berupa teks, karena penelitian menunjukkan bahwa format ini lebih mudah diingat dan dipraktikkan dalam pemrograman. Selain itu, setiap kelas dilengkapi dengan forum diskusi yang memungkinkan Anda untuk bertanya dan berbagi pengetahuan dengan instruktur dan peserta lainnya. Aktif di forum dapat membantu meningkatkan pemahaman Anda. Jika Anda mengalami kendala terkait situs atau administrasi kelas, gunakan tombol chat di sudut kanan bawah layar, bukan forum. Untuk mengevaluasi pemahaman Anda, terdapat berbagai jenis ujian, seperti kuis dan ujian akhir, yang mencakup materi yang telah dipelajari. Jika menemui pertanyaan yang sulit, disarankan untuk mengulang materi terkait. Selamat belajar!
Forum Diskusi Ekspektasi Dengan banyaknya jumlah siswa Dicoding Academy, kami tidak mengharapkan siswa untuk membaca semua diskusi atau komentar pada forum diskusi. Sebaliknya, bacalah hal-hal yang menurut Anda menarik dan dapat membantu Anda dalam menyelesaikan kelas. Lebih baik lagi, jika Anda dapat membantu siswa lainnya dengan memberikan jawaban di bidang yang Anda pahami. Berbagi dalam forum diskusi ini dapat pula membantu meningkatkan retensi ilmu Anda. Peraturan paling penting adalah bersikap sopan dan memperlakukan semua siswa lain dan instruktur, dengan hormat. Pelanggaran etika ini dapat berakibat pada dikeluarkannya Anda dari kelas.  Anda akan memiliki akses ke forum diskusi kelas selama Anda aktif terdaftar ke kelas ini. Saat masa belajar Anda sudah habis, maka forum diskusi tidak akan dapat diakses. Namun jika Anda sukses menyelesaikan kelas (lulus dan sampai mendapatkan sertifikat kompetensi dari Dicoding), maka Anda tetap dapat mengakses forum diskusi kelas ini walau masa belajar Anda untuk kelas ini telah habis. Sebelum Memulai Bertanya Sebelum membuat diskusi baru, gunakan fitur pencarian untuk cek diskusi lama terlebih dahulu. Problem Anda mungkin pernah dibahas dan dijawab solusinya, dalam forum. Dengan begitu, Anda pun tidak perlu menghabiskan waktu untuk bertanya dan untuk menunggu jawaban kembali.  Namun jika tidak menemukan diskusi lama dengan topik yang sama dengan masalah Anda, silakan membuat diskusi baru. Simak cara dan langkah berikut ini:  https://help.dicoding.com/academy-dicoding/aturan-membuat-pertanyaan-di-forum-diskusi-kelas/ . Fitur Bermanfaat Mencari Posting Anda dapat mencari topik atau diskusi menggunakan tiga cara yang tersedia pada halaman utama forum diskusi. Gunakan fitur “Cari Judul Diskusi” untuk mencari topik berdasarkan judul atau pertanyaannya. Gunakan fitur “Pilih Berdasarkan Modul” untuk melihat diskusi berdasarkan modul kelasnya. Gunakan fitur “Keyword Populer” untuk melihat diskusi berdasarkan  Keyword  yang paling sering ditanyakan. Upvote dan Downvote Komentar pada Diskusi Saat membuka sebuah diskusi, Anda akan menemukan komentar beserta jawaban dari siswa dan instruktur di bagian bawah. Pada setiap komentar terdapat tombol panah atas (˄) dan panah bawah (˅). Klik tombol panah atas (˄) jika Anda merasa komentar atau jawaban tersebut bijaksana, menarik, dan bermanfaat. Gunakan tombol panah bawah (˅) jika Anda merasa komentar atau jawaban tersebut tidak sopan, tidak membantu, atau bahkan tidak tepat. Gunakan Fitur Upvote dan Downvote ini seperti arahan di atas, sehingga kualitas komentar dan jawaban pada forum diskusi dapat terjaga dengan baik. Approved Answer Jika terdapat komentar/tanggapan berupa solusi terbaik dari permasalahan yang Anda tanyakan, maka tandai komentar tersebut sebagai jawaban terpilih. Caranya dengan menekan tombol “Jawaban Terpilih” di sisi kanan atas komentar. Fitur ini juga akan mempermudah siswa lainnya dengan pertanyaan yang sama untuk menemukan titik terang solusinya.   Mengenal Teman Sekelas Anda Berhubungan baik dengan teman sekelas dan instruktur merupakan bagian penting dari kelas ini karena mereka dapat membantu jika Anda mengalami kendala dalam pemahaman materi.  Oleh karena itu, kami ingin Anda meluangkan waktu untuk mencairkan suasana dan saling mengenal. Membangun interaksi dengan siswa lain akan membuat pengalaman belajar Anda jauh lebih menyenangkan dan menarik.  Beberapa hal yang dapat Anda tulis pada perkenalan diri: Siapa Anda dan dari mana Anda berasal? Apa pekerjaan atau pendidikan Anda saat ini? Kenapa Anda mengambil pelatihan ini? Apakah mungkin karena Anda sedang mengejar perubahan dalam karir, atau lainnya? Ayo aktif di forum diskusi kelas ini! Yuk mulai dengan memperkenalkan diri Anda pada thread  Perkenalan Diri  berikut: https://www.dicoding.com/academies/51/discussions/89580;"Di forum diskusi Dicoding Academy, siswa tidak diharapkan untuk membaca semua komentar, tetapi disarankan untuk fokus pada topik yang menarik dan bermanfaat untuk menyelesaikan kelas, serta membantu siswa lain dengan menjawab pertanyaan di bidang yang dipahami. Penting untuk bersikap sopan dan menghormati semua peserta, karena pelanggaran etika dapat berakibat dikeluarkannya dari kelas. Akses forum tersedia selama terdaftar, dan setelah lulus, siswa tetap dapat mengakses forum. Sebelum bertanya, gunakan fitur pencarian untuk menemukan diskusi yang relevan. Gunakan fitur pencarian, upvote dan downvote untuk menjaga kualitas diskusi, serta tandai jawaban terbaik sebagai ""Jawaban Terpilih"". Membangun hubungan baik dengan teman sekelas dan instruktur juga penting untuk mendukung proses belajar. Mulailah dengan memperkenalkan diri di thread Perkenalan Diri."
Glosarium Ini adalah glosarium dengan istilah umum yang digunakan di dalam kelas. Anda dapat membaca sekilas materi ini untuk mengenali istilah-istilah umum yang ada di modul kelas ini. Selain itu, Anda juga dapat mengunjungi kembali halaman ini setiap kali menemukan istilah yang belum dimengerti. Carilah istilah tersebut pada laman glosarium ini untuk mengidentifikasi makna atau definisinya. Jika masih terdapat kosakata yang tidak Anda pahami dan belum masuk di daftar ini, Anda dapat memberikan saran melalui fitur Laporan Materi. A Abstract Class Sebuah class yang ditandai dengan keyword “abstract”, yang mempunyai beberapa properti dan atau fungsi yang belum terdapat implementasinya. Class ini harus diimplementasi terlebih dahulu oleh class lainnya agar bisa diinisiasi. Abstraction/Abstraksi Proses representasi data menjadi lebih umum, dengan menyembunyikan rincian/detail implementasi dan hanya fokus pada yang penting saja. Annotation Tanda yang diberikan untuk memasukkan metadata pada suatu class maupun variable pada saat compile time dengan memanfaatkan reflection. API (Application Programming Interface) Sebuah interface yang dapat menghubungkan suatu aplikasi dengan aplikasi lainnya, baik dalam satu platform yang sama maupun berbeda. Architecture Gambaran umum secara high-level tentang bagaimana suatu aplikasi dibangun. Argument Sebuah nilai yang akan disematkan atau diteruskan ke dalam parameter sebuah fungsi. Asynchronous Proses yang berjalan tidak berurutan, bersamaan/berbarengan dalam suatu waktu. Attribute Merepresentasikan karakteristik dari suatu objek atau properti dari sebuah objek. B Best Practice Suatu cara paling efisien (upaya paling sedikit) dan efektif (hasil terbaik) untuk menyelesaikan suatu tugas, berdasarkan suatu prosedur yang dapat diulangi yang telah terbukti manjur untuk banyak orang dalam jangka waktu yang cukup lama. Boilerplate Code  Penulisan baris kode berulang di banyak tempat tanpa adanya perubahan. Bug Segala bentuk kecacatan dalam suatu aplikasi. Business Logic/Domain Logic Kode yang berisi logika utama dari suatu aplikasi yang merepresentasikan proses bisnis di dunia nyata.   C Callback Fungsi yang akan diteruskan sebagai argumen ke kode lain yang diharapkan untuk dieksekusi sebagai argumen pada waktu yang tepat. Class Class merupakan blueprint atau definisi struktur dari sebuah objek yang belum diinisiasi. Di dalamnya terdapat kumpulan properti dan fungsi yang mencerminkan kegunaan dari class. Clean Code Aturan dalam penulisan kode saat pengembangan aplikasi yang digagas oleh Robert C.Martin, di mana menerapkan beberapa teknik tertentu agar kode yang dituliskan bisa dengan mudah dibaca, ditulis, maupun diperbaiki. Code Isolation Pemisahan kode berdasarkan fungsinya supaya tidak saling terikat dan mudah dipelihara. Collection Objek yang dapat digunakan untuk menyimpan sekumpulan objek. Compiler Perangkat lunak yang digunakan untuk menerjemahkan bahasa pemrograman menjadi program system. Configuration Change Perubahan konfigurasi yang terjadi pada device yang menyebabkan Activity di-destroy/dihapus dari memori lalu dibuat lagi dari awal, misalnya saat screen rotation (perubahan orientasi layar dari potrait ke landscape dan sebaliknya). Constant (Konstanta) Tidak berubah-ubah nilainya. Constructor Method yang secara default sudah terbentuk ketika kelas dibuat. Ketika suatu kelas dibuat (instansiasi) maka konstruktor akan terpanggil juga. Console Tool yang dapat digunakan untuk menjalankan perintah atau melihat pesan log. Converter Aplikasi yang berfungsi untuk mengubah suatu data dari satu data ke bentuk data lainnya. Coupling Ukuran kuatnya keterikatan/ketergantungan antara suatu modul dengan modul lainnya. Sehingga apabila suatu modul diubah, modul lain juga harus diubah. Crash Keadaan dari suatu sistem (aplikasi atau sistem operasi), di mana sistem tersebut tidak berfungsi dengan normal dan terpaksa mengakhiri berjalannya sistem tersebut. D Data Classes Kelas sederhana yang bisa berperan sebagai data container pada kotlin. Di dalamnya terdapat beberapa fungsi yang sudah disediakan untuk menghandle beberapa operasi data seperti equals(), toString(), hashCode(), & copy(). Debug Proses mengidentifikasi atau menghapus error pada sebuah perangkat keras atau perangkat lunak. Dependency Dalam Android, ini biasanya merujuk pada library tambahan atau komponen yang dibutuhkan oleh aplikasi untuk dapat melakukan fungsi tertentu yang tidak bisa dilakukan secara fedault. Design Pattern Pola dasar atau template dari sebuah cara untuk menyelesaikan suatu permasalahan dalam situasi yang berbeda-beda. E Encapsulation Konsep fundamental dalam pemrograman berbasis objek yang membungkus data dengan beberapa method/fungsi yang mengelola data, dan membatasi akses data secara langsung dari luar unit (class). Endpoint Bagian akhir pada API yang digunakan untuk menentukan data apa yang diambil. Enum Fitur yang bisa digunakan untuk menyimpan kumpulan objek yang telah didefinisikan menjadi tipe data konstanta. Exception Kesalahan yang muncul saat aplikasi dijalankan. Expression Kombinasi dari data, variabel, dan atau operator yang mengembalikan suatu nilai. Extends Kata kunci yang digunakan untuk mengimplementasikan konsep inheritance. F Field Bagian dari class yang berisi nilai khusus untuk object. Filter Proses penyaringan terhadap sebuah kumpulan object. Framework Kerangka kerja yang sudah disediakan untuk mengembangkan aplikasi. Kerangka kerja di sini sangat membantu developer dalam menuliskan sebuah kode dengan lebih terstruktur dan tersusun rapi. G Generic Menggambarkan karakteristik (gambaran umum) dari sebuah jenis atau kelompok tetapi tidak spesifik. Getter Fungsi yang digunakan untuk membaca nilai sebuah variabel yang terenkapsulasi. I Immutable Objek yang nilainya tidak bisa diubah saat runtime. Implementation Realisasi dari suatu spesifikasi aplikasi, misalnya seperti mengimplementasikan interface atau membuat real class dari abstract class. Index Indikator dalam bentuk angka yang merepresentasikan posisi dari sebuah item di dalam sebuah list atau daftar (daftar karakter, array, dsb). Inisialisasi Sebuah proses pemberian nilai awal setelah deklarasi sebuah variabel. Inner Class Kelas yang dideklarasikan di dalam sebuah kelas. Instance Perwujudan dari sebuah class (kelas). Interface Kontrak yang digunakan untuk berkomunikasi antara satu pihak dengan pihak yang lain. Di mana semua method di dalamnya harus diimplementasikan oleh class yang memakainya (mengimplementasikannya) J JSON (JavaScript Object Notation) Format data yang menyajikan pasangan key dan value yang digunakan dalam pertukaran data antar program aplikasi dan juga bisa digunakan sebagai tempat penyimpanan dari suatu data. K Keyword Dalam pemrograman, keyword adalah susunan huruf atau frasa yang sudah disediakan oleh bahasa program tertentu dan mempunyai arti spesial pada compiler. L Lifecycle Siklus hidup atau tahapan-tahapan suatu proses dalam aplikasi mulai dari awal sampai akhir. M Mapping Proses perubahan dari satu jenis model data ke jenis model lainnya. Method Bagian dari class yang menjalankan suatu aksi tertentu. Mutable Tipe variable yang bisa diubah nilainya. N Native Asli atau murni. Networking Proses untuk mengambil data dari network/server. Null Tidak memiliki nilai/value. Nullable Kondisi dari sebuah variabel yang dapat menampung nilai null. O Object/Objek Merupakan instance atau wujud nyata dari suatu kelas. Observable Objek yang bisa diamati/di-observe dalam jangka waktu tertentu. Operator Fungsi tertentu yang digunakan untuk menjalankan sebuah proses untuk menentukan hasil. Override Kata kunci yang digunakan untuk mengambil alih fungsi yang diwariskan. P Package Cara yang digunakan untuk mengelompokkan kumpulan kelas. Parameter Nilai inputan berupa variabel pada saat fungsi itu didefinisikan. Parenthesis Tanda kurung/( ) yang berada pada sebuah function atau constructor. Parsing Proses penguraian suatu data dari satu data ke bentuk data lainnya. Plugins Kode dengan fungsi tertentu yang memungkinkan aplikasi atau program untuk menjalankan fitur tambahan di aplikasi atau program tersebut. Properties Atribut yang menjadi anggota dari suatu kelas. Properti digunakan untuk menyimpan data yang relevan dengan kelas. Seperti yang sudah disebutkan sebelumnya seperti tinggi, berat, dan umur adalah properti dari suatu kelas. Q Query Syntax atau perintah yang dipakai untuk mengakses dan menampilkan data pada sistem database SQL. R Read-Only Adalah kondisi di mana kita hanya dapat menjalankan proses membaca namun tidak dapat menjalankan proses menulis. Refactor Proses menulis ulang suatu kode menjadi lebih baik. Reference Suatu value yang mempunyai akses secara tidak langsung ke data atau objek lain. Reliability Probabilitas konsistensi suatu komponen atau sistem untuk melakukan fungsi yang ditentukan dalam periode waktu tertentu di bawah kondisi yang dirancang untuk beroperasi. Return Type Tipe kembalian dari sebuah function. S Statement Sebuah instruksi dalam bentuk kode yang digunakan oleh komputer untuk menjalankan aksi tertentu. T Thread Sekumpulan instruksi yang dapat dijalankan pada CPU. Tipe Data Primitif Tipe data primitif adalah tipe data yang hanya menyimpan satu nilai pada setiap satu variabel, seperti integer, string, dan boolean. V Variable Dalam konteks pemrograman, variable adalah tempat yang digunakan untuk menyimpan suatu data. Visibility Modifier Keyword yang mengatur aksesibilitas dari suatu class, objek, interface, fungsi, dan properti. Contohnya seperti public, private, protected, dan internal.;Glosarium ini mencakup istilah-istilah umum yang digunakan dalam kelas, yang dapat membantu Anda memahami materi dengan lebih baik. Anda dapat merujuk kembali ke glosarium ini untuk mencari makna istilah yang belum dimengerti, dan jika ada kosakata yang tidak ada dalam daftar, Anda dapat memberikan saran melalui fitur Laporan Materi. Beberapa istilah penting termasuk: Abstract Class (kelas dengan implementasi yang belum lengkap), API (interface yang menghubungkan aplikasi), Best Practice (metode efisien untuk menyelesaikan tugas), Clean Code (aturan penulisan kode yang mudah dibaca), Encapsulation (pembungkusan data dengan method), dan JSON (format data untuk pertukaran informasi). Istilah lain seperti Dependency, Method, Object, dan Variable juga dijelaskan, mencakup berbagai konsep dari pemrograman hingga struktur data, yang semuanya bertujuan untuk memberikan pemahaman yang lebih baik tentang pengembangan perangkat lunak.
"Daftar Referensi  [1] Android Developers Channel. “Google Keynote (Google I/O ‘21)”. youtube.com.  https://youtu.be/XFFrahd05OM  (diakses pada 20 Mei 2021). [2] Statista. “Mobile operating systems' market share worldwide from January 2012 to January 2021”. statista.com.  https://www.statista.com/statistics/272698/global-market-share-held-by-mobile-operating-systems-since-2009/  (diakses pada 11 Apr 2021). [3] Statista. “Number of available applications in the Google Play Store from December 2009 to December 2020”. statista.com.  https://www.statista.com/statistics/266210/number-of-available-applications-in-the-google-play-store/  (diakses pada 11 Apr 2021). [4] M. Shafirov. “Kotlin on Android. Now official”. blog.jetbrains.com.  https://blog.jetbrains.com/kotlin/2017/05/kotlin-on-android-now-official/  (diakses pada 11 Apr 2021). [5] X. Ducrohet; T. Norbye; K.Chou. “Android Studio: An IDE built for Android”. android-developers.googleblog.com.  https://android-developers.googleblog.com/2013/05/android-studio-ide-built-for-android.html  (diakses pada 12 Apr 2021).";"Daftar Referensi  [1] Android Developers Channel. “Google Keynote (Google I/O ‘21)”. youtube.com.  https://youtu.be/XFFrahd05OM  (diakses pada 20 Mei 2021). [2] Statista. “Mobile operating systems' market share worldwide from January 2012 to January 2021”. statista.com.  https://www.statista.com/statistics/272698/global-market-share-held-by-mobile-operating-systems-since-2009/  (diakses pada 11 Apr 2021). [3] Statista. “Number of available applications in the Google Play Store from December 2009 to December 2020”. statista.com.  https://www.statista.com/statistics/266210/number-of-available-applications-in-the-google-play-store/  (diakses pada 11 Apr 2021). [4] M. Shafirov. “Kotlin on Android. Now official”. blog.jetbrains.com.  https://blog.jetbrains.com/kotlin/2017/05/kotlin-on-android-now-official/  (diakses pada 11 Apr 2021). [5] X. Ducrohet; T. Norbye; K.Chou. “Android Studio: An IDE built for Android”. android-developers.googleblog.com.  https://android-developers.googleblog.com/2013/05/android-studio-ide-built-for-android.html  (diakses pada 12 Apr 2021)."
"Latihan Mengirim Data dengan Parcelable Bagi yang belum mengenal apa itu Data Class ,  berikut penjelasan singkatnya. Data Class adalah sebuah kelas biasa yang tidak bergantung pada kelas lainnya. Class ini berfungsi untuk menyimpan model data (attribute) suatu objek.  Class  ini sama seperti POJO ( Plain Old Java Object ) pada Java yang memiliki properti/variabel dan metode  setter-getter . Namun di Kotlin semua itu sudah tergenerate otomatis dan tidak terlihat, sehingga kode menjadi lebih ringkas. Sebagai contoh kelas Kotlin dan Java di bawah ini memiliki fungsi yang sama: Kotlin data class MyBean(val someProperty: String) Java public class MyBean {      private String someProperty;          public MyBean(){     }      public String getSomeProperty() {          return someProperty;     }      public void setSomeProperty(String someProperty) {         this.someProperty = someProperty;     } } Lalu apa kegunaan Data Class? Data class akan membantu kita saat aplikasi semakin kompleks. Contohnya, data class berisi banyak field bisa kita gunakan untuk melakukan koneksi ke server untuk request API atau akses ke database lokal dengan SQLite. Untuk lebih lengkapnya Anda bisa membaca lebih lanjut tentang Data Class  di sini . Codelab Data Class Sebelum membuat objek parcelable, kita buat kelas Java POJO terlebih dahulu. Caranya, klik kanan pada  package utama  → New → Kotlin File/Class (untuk Kotlin)  atau  package utama  → New → Java Class (untuk Java) Pada dialog isikan nama kelas dengan  Person  dan pilih  Data Class  (Kotlin) /  Class  (Java). Lalu klik  Enter Setelah selesai terbentuk kelas  Person , tambahkan parameter sesuai dengan data yang ingin kita tambahkan seperti ini: Kotlin data  class Person (     val name: String?,     val age: Int?,     val email: String?,     val city: String? ) Java public class Person{      private String name;     private int age;     private String email;     private String city;      public Person(){     }      public String getName() {         return name;     }      public void setName(String name) {         this.name = name;     }      public int getAge() {         return age;     }      public void setAge(int age) {         this.age = age;     }      public String getEmail() {         return email;     }      public void setEmail(String email) {         this.email = email;     }      public String getCity() {         return city;     }      public void setCity(String city) {         this.city = city;     } } Untuk yang menggunakan Java, Anda tak perlu menulis satu demi satu metode  setter-getter  nya. Android Studio sudah menyediakan fasilitas  generator  untuk hal tersebut. Caranya, setelah Anda menentukan variabel apa saja yang akan digunakan, lakukan beberapa langkah sebagai berikut: Klik kanan pada  workspace , pilih   Generate (Alt+Insert) →  Pilih  Getter and Setter. Pilih semua variabel dengan cara  C trl+A  pada windows atau  C ommand+A  pada mac. Codelab Intent Explicit dengan Parcelable Seperti yang diketahui bahwa di dalam Intent kita dapat menyisipkan data dengan tipe-tipe tertentu seperti String, Int, Double pada Intent .  Tetapi tidak dengan tipe kompleks seperti objek, ArrayList, dll. Di sinilah peran besar Parcelable .  Parcelable adalah suatu interface yang memungkinkan kita melakukan pengiriman satu objek sekaligus dari suatu Activity ke Activity lain. Objek yang diimplementasikan dengan Parcelable akan memudahkan Anda dalam mengirimkan data dari satu Activity ke Activity lainnya. Kali ini Anda akan mengubah kelas  Person  untuk mengimplementasikan Parcelable. Implementasikan Parcelable di kelas  Person . Kotlin data class Person(     val name: String?,     val age: Int?,     val email: String?,     val city: String? )  : Parcelable Java public class Person  implements Parcelable  {     private String name;     private int age;     private String email;     private String city;      ...  } Akan muncul tanda merah, namun jangan khawatir, Anda hanya perlu arahkan kursor ke bagian nama kelas  Person , kemudian tekan  Alt+Enter  atau bisa juga  klik pada lampu merah , kemudian pilih  Add Parcelable Implementation . Sekarang Anda bisa menemukan beragam metode parcelable untuk kelas  Person . Sekarang kelas  Person  sudah sah menjadi kelas Parcelable dan dapat dikirimkan ke Activity lain melalui Intent. Maka, kelas  Person  menjadi seperti ini: Kotlin data class Person(     val name: String?,     val age: Int?,     val email: String?,     val city: String? ) : Parcelable  {     constructor(parcel: Parcel) : this(             parcel.readString(),             parcel.readValue(Int::class.java.classLoader) as? Int,             parcel.readString(),             parcel.readString()) {     }      override fun writeToParcel(parcel: Parcel, flags: Int) {         parcel.writeString(name)         parcel.writeValue(age)         parcel.writeString(email)         parcel.writeString(city)     }      override fun describeContents(): Int {         return 0     }      companion object CREATOR : Parcelable.Creator<Person> {         override fun createFromParcel(parcel: Parcel): Person {             return Person(parcel)         }          override fun newArray(size: Int): Array<Person?> {             return arrayOfNulls(size)         }     } } Java public class Person implements Parcelable {      private String name;     private int age;     private String email;     private String city;      public Person(){     }      public String getName() {         return name;     }      public void setName(String name) {         this.name = name;     }      public int getAge() {         return age;     }      public void setAge(int age) {         this.age = age;     }      public String getEmail() {         return email;     }      public void setEmail(String email) {         this.email = email;     }      public String getCity() {         return city;     }      public void setCity(String city) {         this.city = city;     }           protected Person(Parcel in) {         name = in.readString();         age = in.readInt();         email = in.readString();         city = in.readString();     }      @Override     public void writeToParcel(Parcel dest, int flags) {         dest.writeString(name);         dest.writeInt(age);         dest.writeString(email);         dest.writeString(city);     }      @Override     public int describeContents() {         return 0;     }      public static final Creator<Person> CREATOR = new Creator<Person>() {         @Override         public Person createFromParcel(Parcel in) {             return new Person(in);         }          @Override         public Person[] newArray(int size) {             return new Person[size];         }     }; } Sekarang waktunya kita implementasikan pada Intent. Namun sebelumnya, tambahkan satu tombol lagi pada  activity_main.xml  sebagai berikut: <Button     android:id=""@+id/btn_move_activity_object""     android:layout_width=""match_parent""     android:layout_height=""wrap_content""     android:layout_marginBottom=""16dp""     android:text=""@string/move_with_object"" /> Sehingga  activity_main.xml  kita menjadi sebagai berikut: <?xml version=""1.0"" encoding=""utf-8""?> <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""     xmlns:tools=""http://schemas.android.com/tools""     android:layout_width=""match_parent""     android:layout_height=""match_parent""     android:orientation=""vertical""     android:padding=""16dp"">      <Button         android:id=""@+id/btn_move_activity""         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:layout_marginBottom=""16dp""         android:text=""@string/move_activity"" />      <Button         android:id=""@+id/btn_move_activity_data""         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:layout_marginBottom=""16dp""         android:text=""@string/move_with_data"" />       <Button         android:id=""@+id/btn_move_activity_object""         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:layout_marginBottom=""16dp""         android:text=""@string/move_with_object"" />   </LinearLayout> Setelah selesai dengan layout, kini kita kenalkan Button tersebut di kelas  MainActivity . Kotlin ... override fun onCreate(savedInstanceState: Bundle?) {     super.onCreate(savedInstanceState)     setContentView(R.layout.activity_main)      ...       val btnMoveWithObject:Button = findViewById(R.id.btn_move_activity_object)     btnMoveWithObject.setOnClickListener(this)  } ... Java ... @Override protected void onCreate(Bundle savedInstanceState) {     super.onCreate(savedInstanceState);     setContentView(R.layout.activity_main);      ...       Button btnMoveWithObject = findViewById(R.id.btn_move_activity_object);     btnMoveWithObject.setOnClickListener(this);  } ... Buat Activity baru dengan nama  MoveWithObjectActivity . Kemudian pada layout  activity_move_with_object.xml  tambahkan satu TextView untuk menampilkan data yang dikirimkan. <?xml version=""1.0"" encoding=""utf-8""?> <RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android""     xmlns:tools=""http://schemas.android.com/tools""     android:layout_width=""match_parent""     android:layout_height=""match_parent""      android:padding=""16dp"" >       <TextView         android:id=""@+id/tv_object_received""         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:text=""@string/object_received"" />  </RelativeLayout> Sekarang kita kenalkan TextView pada  MoveWithObjectActivity  sehingga menjadi sebagai berikut: Kotlin class MoveWithObjectActivity : AppCompatActivity() {     override fun onCreate(savedInstanceState: Bundle?) {         super.onCreate(savedInstanceState)         setContentView(R.layout.activity_move_with_object)           val tvObject:TextView = findViewById(R.id.tv_object_received)      } } Java public class MoveWithObjectActivity extends AppCompatActivity {     @Override     protected void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout.activity_move_with_object);           TextView tvObject = findViewById(R.id.tv_object_received);      } } Selanjutnya pada kelas  MoveWithObjectActivity ,   kita gunakan getParcelableExtra untuk menerima objek dari Activity asal. Kotlin class MoveWithObjectActivity : AppCompatActivity() {       companion object {         const val EXTRA_PERSON = ""extra_person""     }           override fun onCreate(savedInstanceState: Bundle?) {         super.onCreate(savedInstanceState)         setContentView(R.layout.activity_move_with_object)          val tvObject:TextView = findViewById(R.id.tv_object_received)           val person = if (Build.VERSION.SDK_INT >= 33) {             intent.getParcelableExtra<Person>(EXTRA_PERSON, Person::class.java)         } else {             @Suppress(""DEPRECATION"")             intent.getParcelableExtra<Person>(EXTRA_PERSON)         }          if (person != null) {             val text = ""Name : ${person.name.toString()},\nEmail : ${person.email},\nAge : ${person.age},\nLocation : ${person.city}""             tvObject.text = text         }      } } Java public class MoveWithObjectActivity extends AppCompatActivity {      public static final String EXTRA_PERSON = ""extra_person"";       @Override     protected void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout.activity_move_with_object);         TextView tvObject = findViewById(R.id.tv_object_received);           Person person;         if (android.os.Build.VERSION.SDK_INT >= 33) {             person = getIntent().getParcelableExtra(EXTRA_PERSON, Person.class);         } else {             person = getIntent().getParcelableExtra(EXTRA_PERSON);         }          String text = ""Name : "" + person.getName() + "",\nEmail : "" + person.getEmail() + "",\nAge : "" + person.getAge() + "",\nLocation : "" + person.getCity();         tvObject.setText(text);      } } Catatan: Karena kesamaan naman, pastikan untuk meng-import kelas Person dari package aplikasi kita, bukan dari library lain seperti  android.app . Setelah kita membuat Activity tujuan, kini saatnya tambahkan Intent beserta datanya pada bagian  onClick   di  MainActivity . Kotlin override fun onClick(v: View) {     when (v.id) {                 ...          R.id.btn_move_activity_object -> {             val person = Person(                     ""DicodingAcademy"",                     5,                     ""academy@dicoding.com"",                     ""Bandung""             )              val moveWithObjectIntent = Intent(this@MainActivity, MoveWithObjectActivity::class.java)             moveWithObjectIntent.putExtra(MoveWithObjectActivity.EXTRA_PERSON, person)             startActivity(moveWithObjectIntent)         }      } } Java @Override public void onClick(View v) {     ...     }  else if (v.getId() == R.id.btn_move_activity_object) {         Person person = new Person();         person.setName(""DicodingAcademy"");         person.setAge(5);         person.setEmail(""academy@dicoding.com"");         person.setCity(""Bandung"");          Intent moveWithObjectIntent = new Intent(MainActivity.this, MoveWithObjectActivity.class);         moveWithObjectIntent.putExtra(MoveWithObjectActivity.EXTRA_PERSON, person);         startActivity(moveWithObjectIntent);     }  } Sehingga kode  MainActivity  kita menjadi sebagai berikut: Kotlin class MainActivity : AppCompatActivity(), View.OnClickListener {      override fun onCreate(savedInstanceState: Bundle?) {         super.onCreate(savedInstanceState)         setContentView(R.layout.activity_main)          val btnMoveActivity:Button = findViewById(R.id.btn_move_activity)         btnMoveActivity.setOnClickListener(this)          val btnMoveWithDataActivity:Button = findViewById(R.id.btn_move_activity_data)         btnMoveWithDataActivity.setOnClickListener(this)          val btnMoveWithObject:Button = findViewById(R.id.btn_move_activity_object)         btnMoveWithObject.setOnClickListener(this)     }      override fun onClick(v: View) {         when (v.id) {             R.id.btn_move_activity -> {                 val moveIntent = Intent(this@MainActivity, MoveActivity::class.java)                 startActivity(moveIntent)             }              R.id.btn_move_activity_data -> {                 val moveWithDataIntent = Intent(this@MainActivity, MoveWithDataActivity::class.java)                 moveWithDataIntent.putExtra(MoveWithDataActivity.EXTRA_NAME, ""DicodingAcademy Boy"")                 moveWithDataIntent.putExtra(MoveWithDataActivity.EXTRA_AGE, 5)                 startActivity(moveWithDataIntent)             }              R.id.btn_move_activity_object -> {                 val person = Person(                         ""DicodingAcademy"",                         5,                         ""academy@dicoding.com"",                         ""Bandung""                 )                  val moveWithObjectIntent = Intent(this@MainActivity, MoveWithObjectActivity::class.java)                 moveWithObjectIntent.putExtra(MoveWithObjectActivity.EXTRA_PERSON, person)                 startActivity(moveWithObjectIntent)             }         }     } } Java public class MainActivity extends AppCompatActivity implements View.OnClickListener{     @Override     protected void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout. activity_main );          Button btnMoveActivity = findViewById(R.id. btn_move_activity );         btnMoveActivity.setOnClickListener(this);         Button btnMoveWithDataActivity = findViewById(R.id. btn_move_activity_data );         btnMoveWithDataActivity.setOnClickListener(this);         Button btnMoveWithObject = findViewById(R.id. btn_move_activity_object );         btnMoveWithObject.setOnClickListener(this);     }      @Override     public void onClick(View v) {         if (v.getId() == R.id.btn_move_activity) {             Intent moveIntent = new Intent(MainActivity.this, MoveActivity.class);             startActivity(moveIntent);         } else if (v.getId() == R.id.btn_move_activity_data) {             Intent moveWithDataIntent = new Intent(MainActivity.this, MoveWithDataActivity.class);             moveWithDataIntent.putExtra(MoveWithDataActivity.EXTRA_NAME, ""DicodingAcademy Boy"");             moveWithDataIntent.putExtra(MoveWithDataActivity.EXTRA_AGE, 5);             startActivity(moveWithDataIntent);         } else if (v.getId() == R.id.btn_move_activity_object) {             Person person = new Person();             person.setName(""DicodingAcademy"");             person.setAge(5);             person.setEmail(""academy@dicoding.com"");             person.setCity(""Bandung"");              Intent moveWithObjectIntent = new Intent(MainActivity.this, MoveWithObjectActivity.class);             moveWithObjectIntent.putExtra(MoveWithObjectActivity.EXTRA_PERSON, person);             startActivity(moveWithObjectIntent);         }     } } Setelah semua komponen selesai dibuat, saatnya menjalankan kembali aplikasinya. Cobalah menakan tombol  Pindah Activity dengan Object .  Sekarang Anda sudah berhasil memindahkan satu objek secara utuh, Selamat! Jika anda menggunakan bahasa Kotlin, ada fitur untuk membuat kelas Parcelable dengan lebih simpel dan tidak terlalu banyak kode hasil dari   Add Implementation Parcelable , yaitu dengan menggunakan anotasi  Parcelize . Untuk menambahkan parcelize Anda perlu mengikuti langkah-langkah berikut: Tambahkan kode berikut di  build.gradle (module: app)  di bawah apply plugin sebelum tag Android, sesuaikan juga urutan apply plugin di atasnya. plugins{   id 'com.android.application'   id 'kotlin-android'    id 'kotlin-parcelize'  }  android {     ... } Jangan lupa untuk unduh plugin dengan cara klik  Sync Now  yang muncul di pojok kanan atas ketika terjadi perubahan kode pada build.gradle. Kemudian Anda hanya perlu menambahkan anotasi  @Parcelize di atas kelas model yang sudah diimplementasikan Parcelable, maka hasil dan perbedaannya dapat Anda lihat pada kode berikut: Dengan Parcelize ...  import kotlinx.parcelize.Parcelize    @Parcelize  data class Person(     val name: String?,     val age: Int?,     val email: String?,     val city: String? ) : Parcelable Catatan: Pastikan Anda menggunakan versi Kotlin terbaru (1.4.30 ke atas) supaya tidak terdapat error Tanpa Parcelize data class Person(     val name: String?,     val age: Int?,     val email: String?,     val city: String? ) : Parcelable {     constructor(parcel: Parcel) : this(             parcel.readString(),             parcel.readValue(Int::class.java.classLoader) as? Int,             parcel.readString(),             parcel.readString()) {     }      override fun writeToParcel(parcel: Parcel, flags: Int) {         parcel.writeString(name)         parcel.writeValue(age)         parcel.writeString(email)         parcel.writeString(city)     }      override fun describeContents(): Int {         return 0     }      companion object CREATOR : Parcelable.Creator<Person> {         override fun createFromParcel(parcel: Parcel): Person {             return Person(parcel)         }          override fun newArray(size: Int): Array<Person?> {             return arrayOfNulls(size)         }     } } Keren kan? Dengan menggunakan Parcelize, Anda dapat menyederhanakan kode yang sebelumnya panjang menjadi lebih simpel dan bersih.  Untuk tutorial yang selanjutnya kita akan terus menggunakan parcelize untuk mengimplementasi parcelable. Bedah Kode Akhirnya Anda sudah berhasil menerapkan 3 tipe perpindahan Activity secara eksplisit melalui intent. Sekarang, mari kita dalami penjelasannya satu per satu. Put Parcelable Kotlin val person = Person(         ""DicodingAcademy"",         5,         ""academy@dicoding.com"",         ""Bandung"" ) Java Person person = new Person(); person.setName(""DicodingAcademy""); person.setAge(5); person.setEmail(""academy@dicoding.com""); person.setCity(""Bandung""); Di atas kita menciptakan sebuah objek  Person  bernama  person  yang mana kelas tersebut adalah Parcelable. Kita atur semua data sesuai dengan propertinya. Kemudian kita akan mengirimkan objek tersebut ke  MoveWithObjectActivity  melalui sebuah Intent di bawah ini: Kotlin val moveWithObjectIntent = Intent(this@MainActivity, MoveWithObjectActivity::class.java) moveWithObjectIntent.putExtra(MoveWithObjectActivity.EXTRA_PERSON, person) startActivity(moveWithObjectIntent) Java Intent moveWithObjectIntent = new Intent(MainActivity.this, MoveWithObjectActivity.class); moveWithObjectIntent.putExtra(MoveWithObjectActivity. EXTRA_PERSON , person); startActivity(moveWithObjectIntent); Metode  putExtra()  yang kita pilih saat ini adalah  putExtra(String name, Parcelable value) . Get Parcelable EXTRA_PERSON  merupakan variabel  static  bertipe data string dan bernilai “ extra_person ”. Berfungsi sebagai  k ey  untuk mendapatkan  v alue  data yang dikirim Selanjutnya pada  MoveWithObjectActivity  kita akan mengambil nilai seperti berikut: Kotlin val person = if (Build.VERSION.SDK_INT >= 33) {     intent.getParcelableExtra<Person>(EXTRA_PERSON, Person::class.java) } else {     @Suppress(""DEPRECATION"")     intent.getParcelableExtra<Person>(EXTRA_PERSON) } Java Person person; if (Build.VERSION.SDK_INT >= 33) {     person = getIntent().getParcelableExtra(EXTRA_PERSON, Person.class); } else {     person = getIntent().getParcelableExtra(EXTRA_PERSON); } Dan ini yang seru. Karena objek ini terdiri dari beragam tipe data pada atribut atau propertinya, kita hanya cukup membungkus itu semua ke dalam objek Parcelable. Melalui  getIntent().getParcelableExtra(Key) ,  Anda dapat mengambil nilai objek person yang sebelumnya telah dikirim hanya dengan satu variabel, bayangkan jika kita tidak menggunakan Parcelable, maka kita harus mengirim data satu per satu. Jika datanya sedikit mungkin tidak masalah tapi jika datanya puluhan, tentu akan merepotkan kan?  Selanjutnya kita dapat menampilkan data objek yang sudah diterima seperti ini: Kotlin if (person != null) {     val text = ""Name : ${person.name.toString()},\nEmail : ${person.email},\nAge : ${person.age},\nLocation : ${person.city}""     tvObject.text = text } Java String text = ""Name : ""+person.getName()+"", Email : ""+person.getEmail()+"", Age : ""+person.getAge() + "", Location : ""+person.getCity(); tvObject.setText(text); Lalu, bagaimana jika kita ingin mengirimkan kumpulan objek Parcelable ke activity lain? Untuk mengirimkan kumpulan data, kita bisa memanfaatkan ArrayList dan metode  putParcelableArrayListExtra . Contoh kode ketika membuat Intent adalah seperti ini: Kotlin var persons = ArrayList<Person>()  ...  moveWithObjectIntent.putParcelableArrayListExtra(KEY,persons) Java ArrayList<Person> persons = new ArrayList<>();  ...  moveWithObjectIntent.putParcelableArrayListExtra(KEY,persons); Dan ketika mengambil kumpulan datanya, kita bisa menggunakan kode  getParcelableArrayListExtra : Kotlin intent.getParcelableArrayListExtra(EXTRA_PERSON, Person::class.java) Java ArrayList<Person> persons = getIntent().getParcelableArrayListExtra(KEY, Person.class); Parcelize (Khusus Kotlin) apply plugin: 'com.android.application' apply plugin: 'kotlin-android'  apply plugin: 'kotlin-parcelize'  Parcelize adalah fitur yang dapat digunakan untuk membuat implementasi Parcelable secara otomatis, untuk menggunakannya Anda harus menambahkan plugin   di  build.gradle(module: app)  supaya bisa menggunakan fitur ini: ... import kotlinx.parcelize.Parcelize   @Parcelize  data class Person(     val name: String?,     val age: Int?,     val email: String?,     val city: String? ) : Parcelable Anotasi  @Parcelize  di atas nama kelas, digunakan untuk memberi tanda bahwa kelas ini yang dipilih untuk menjadi parcelable.  @Parcelize  juga otomatis men- generate  semua kode yang digunakan untuk implemetasi parcelize sebelumnya. Selamat, Anda sudah bisa mengirim objek antar Activity! Selanjutnya, kita akan membuat sebuah contoh aplikasi dengan menggunakan jenis Intent yang lain, yakni Intent Implicit. Tetap semangat!";Latihan ini menjelaskan tentang penggunaan Data Class dan Parcelable dalam pengembangan aplikasi Android menggunakan Kotlin dan Java. Data Class berfungsi untuk menyimpan model data suatu objek dengan kode yang lebih ringkas dibandingkan dengan POJO di Java, di mana setter dan getter otomatis dihasilkan. Dalam konteks pengiriman data antar Activity, Parcelable memungkinkan objek dikirim dengan mudah melalui Intent. Contoh implementasi dimulai dengan membuat kelas Person sebagai Data Class yang mengimplementasikan Parcelable, diikuti dengan pengaturan layout dan penanganan klik pada tombol untuk memindahkan data. Setelah itu, dibuatlah Activity baru untuk menerima objek dan menampilkannya. Kotlin juga menawarkan kemudahan dengan anotasi @Parcelize, yang menyederhanakan implementasi Parcelable. Latihan ini mengajarkan cara mengirim objek dan kumpulan objek antar Activity dengan efisien, serta memperkenalkan konsep Intent Implicit untuk penggunaan selanjutnya.
"Latihan Mendapatkan Nilai Balik dari Intent Pada modul ini kita akan membedah hubungan Activity dan Intent dalam menerima nilai balik. Kadang kala ketika kita menjalankan sebuah Activity dari Activity lain, kita mengharapkan ada nilai hasil balik dari Activity yang dijalankan ketika ia ditutup. Contohnya kita memiliki Activity A yang menjalankan Activity B untuk melakukan sebuah proses. Lalu nilai hasil dari proses tersebut dikirimkan kembali ke Activity A sebelum Activity B ditutup dengan pemanggilan metode finish(). Itulah yang dinamakan sebuah Activity menerima nilai hasil balik dari Activity yang dia jalankan. Supaya lebih jelas, ayo kita lanjutkan lagi proses  ngoding -nya. Sekarang untuk menerapkan konsep di atas, buat sebuah Activity baru dengan nama  MoveForResultActivity . Kemudian pada  activity_move_for_result.xml  silakan kondisikan layout kita dengan   1 buah TextView, 1 buah RadioGroup, 4 buah RadioButton, dan 1 buah Button sebagai berikut: <?xml version=""1.0"" encoding=""utf-8""?> <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""     xmlns:tools=""http://schemas.android.com/tools""     android:layout_width=""match_parent""     android:layout_height=""match_parent""      android:orientation=""vertical""     android:padding=""16dp"" >       <TextView         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:layout_marginBottom=""16dp""         android:text=""@string/choose_number"" />      <RadioGroup         android:id=""@+id/rg_number""         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:orientation=""vertical"">          <RadioButton             android:id=""@+id/rb_50""             android:layout_width=""match_parent""             android:layout_height=""wrap_content""             android:layout_marginBottom=""16dp""             android:text=""@string/_50"" />          <RadioButton             android:id=""@+id/rb_100""             android:layout_width=""match_parent""             android:layout_height=""wrap_content""             android:layout_marginBottom=""16dp""             android:text=""@string/_100"" />          <RadioButton             android:id=""@+id/rb_150""             android:layout_width=""match_parent""             android:layout_height=""wrap_content""             android:layout_marginBottom=""16dp""             android:text=""@string/_150"" />          <RadioButton             android:id=""@+id/rb_200""             android:layout_width=""match_parent""             android:layout_height=""wrap_content""             android:layout_marginBottom=""16dp""             android:text=""@string/_200"" />     </RadioGroup>      <Button         android:id=""@+id/btn_choose""         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:text=""@string/choose"" />  </LinearLayout> Tampilannya adalah seperti ini: Setelah selesai, lanjutkan ke berkas  MoveForResultActivity  dengan mengenalkan komponen yang sudah ditambahkan. Kotlin private lateinit var btnChoose: Button private lateinit var rgNumber: RadioGroup  companion object {     const val EXTRA_SELECTED_VALUE = ""extra_selected_value""     const val RESULT_CODE = 110 }   override fun onCreate(savedInstanceState: Bundle?) {     super.onCreate(savedInstanceState)     setContentView(R.layout.activity_move_for_result)       btnChoose = findViewById(R.id.btn_choose)     rgNumber = findViewById(R.id.rg_number)     } Java public class MoveForResultActivity extends AppCompatActivity {      private Button btnChoose;     private RadioGroup rgNumber;      public static final String EXTRA_SELECTED_VALUE = ""extra_selected_value"";     public static final int RESULT_CODE = 110;        @Override     protected void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout.activity_move_for_result);           btnChoose = findViewById(R.id.btn_choose);         rgNumber = findViewById(R.id.rg_number);      } } Kemudian kita beri aksi pada Button dengan menuliskan kode sebagai berikut: Kotlin class MoveForResultActivity : AppCompatActivity() , View.OnClickListener  {     ...     override fun onCreate(savedInstanceState: Bundle?) {         super.onCreate(savedInstanceState)         setContentView(R.layout.activity_move_for_result)          btnChoose = findViewById(R.id.btn_choose)         rgNumber = findViewById(R.id.rg_number)           btnChoose.setOnClickListener(this)      }       override fun onClick(v: View) {         if (v.id == R.id.btn_choose) {             if (rgNumber.checkedRadioButtonId > 0) {                 var value = 0                 when (rgNumber.checkedRadioButtonId) {                     R.id.rb_50 -> value = 50                      R.id.rb_100 -> value = 100                      R.id.rb_150 -> value = 150                      R.id.rb_200 -> value = 200                 }                  val resultIntent = Intent()                 resultIntent.putExtra(EXTRA_SELECTED_VALUE, value)                 setResult(RESULT_CODE, resultIntent)                 finish()             }         }     }  } Java public class MoveForResultActivity extends AppCompatActivity  implements View.OnClickListener  {     ...     @Override     protected void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout.activity_move_for_result);         ...         btnChoose.setOnClickListener(this);     }       @Override     public void onClick(View v) {         if (v.getId() == R.id.btn_choose) {             if (rgNumber.getCheckedRadioButtonId() != 0) {                 int value = 0;                 int id = rgNumber.getCheckedRadioButtonId();                 if (id == R.id.rb_50) {                     value = 50;                 } else if (id == R.id.rb_100) {                     value = 100;                 } else if (id == R.id.rb_150) {                     value = 150;                 } else if (id == R.id.rb_200) {                     value = 200;                 }                  Intent resultIntent = new Intent();                 resultIntent.putExtra(EXTRA_SELECTED_VALUE, value);                 setResult(RESULT_CODE, resultIntent);                 finish();             }         }     }  } Pada  activity_main.xml ,   tambahkan lagi satu Button dan satu TextView yang akan kita gunakan untuk menjalankan  MoveForResultActivity  seperti berikut: <Button     android:id=""@+id/btn_move_for_result""     android:layout_width=""match_parent""     android:layout_height=""wrap_content""     android:layout_marginBottom=""16dp""     android:text=""@string/move_with_result"" />  <TextView     android:id=""@+id/tv_result""     android:layout_width=""match_parent""     android:layout_height=""wrap_content""     android:gravity=""center""     android:text=""@string/result_from_activity""     android:textSize=""24sp"" /> Sehingga layout  activity_main.xml  yang kita punya menjadi seperti ini: <?xml version=""1.0"" encoding=""utf-8""?> <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""     xmlns:tools=""http://schemas.android.com/tools""     android:layout_width=""match_parent""     android:layout_height=""match_parent""     android:orientation=""vertical""     android:padding=""16dp"">      <Button         android:id=""@+id/btn_move_activity""         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:layout_marginBottom=""16dp""         android:text=""@string/move_activity"" />      <Button         android:id=""@+id/btn_move_activity_data""         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:layout_marginBottom=""16dp""         android:text=""@string/move_with_data"" />      <Button         android:id=""@+id/btn_move_activity_object""         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:layout_marginBottom=""16dp""         android:text=""@string/move_with_object"" />      <Button         android:id=""@+id/btn_dial_number""         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:layout_marginBottom=""16dp""         android:text=""@string/dial_number"" />       <Button         android:id=""@+id/btn_move_for_result""         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:layout_marginBottom=""16dp""         android:text=""@string/move_with_result"" />      <TextView         android:id=""@+id/tv_result""         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:gravity=""center""         android:text=""@string/result_from_activity""         android:textSize=""24sp"" />  </LinearLayout> Setelah selesai, kita lanjut menginisialisasi TextView dan Button ke dalam berkas  MainActivity . Kotlin class MainActivity : AppCompatActivity(), View.OnClickListener {       private lateinit var tvResult: TextView       override fun onCreate(savedInstanceState: Bundle?) {         super.onCreate(savedInstanceState)         setContentView(R.layout.activity_main)          ...           val btnMoveForResult:Button = findViewById(R.id.btn_move_for_result)         btnMoveForResult.setOnClickListener(this)          tvResult = findViewById(R.id.tv_result)      } } Java public class MainActivity extends AppCompatActivity implements View.OnClickListener {       private TextView tvResult;       @Override     protected void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout.activity_main);           ...            Button  btnMoveForResult = findViewById(R.id.btn_move_for_result);         btnMoveForResult.setOnClickListener(this);          tvResult = findViewById(R.id.tv_result);      }      ...  } Selanjutnya kita buat launcher registerForActivityResult untuk menerima nilai balik. Alih-alih menggunakan startActivity, gunakan launcher tersebut untuk menjalankan Intent seperti berikut: Kotlin class MainActivity : AppCompatActivity(), View.OnClickListener {     private lateinit var tvResult: TextView      private val resultLauncher = registerForActivityResult(         ActivityResultContracts.StartActivityForResult()     ) { result ->         if (result.resultCode == MoveForResultActivity.RESULT_CODE && result.data != null) {             val selectedValue =                 result.data?.getIntExtra(MoveForResultActivity.EXTRA_SELECTED_VALUE, 0)             tvResult.text = ""Hasil : $selectedValue""         }     }  ... override fun onClick(v: View) {     when (v.id) {         ...          R.id.btn_move_for_result -> {             val moveForResultIntent = Intent(this@MainActivity, MoveForResultActivity::class.java)             resultLauncher.launch(moveForResultIntent)         }      } } Java public class MainActivity extends AppCompatActivity implements View.OnClickListener {     private TextView tvResult;      final ActivityResultLauncher<Intent> resultLauncher = registerForActivityResult(new ActivityResultContracts.StartActivityForResult(),             result -> {                 if (result.getResultCode() == MoveForResultActivity.RESULT_CODE && result.getData() != null) {                     int selectedValue = result.getData().getIntExtra(MoveForResultActivity.EXTRA_SELECTED_VALUE, 0);                     tvResult.setText(String.format(""Hasil : %s"", selectedValue));                 }             });      ...     @Override     public void onClick(View v) {         ...            }  else if (v.getId() == R.id.btn_move_for_result) {              Intent moveForResultIntent = new Intent(MainActivity.this, MoveForResultActivity.class);             resultLauncher.launch(moveForResultIntent);          }     } } Setelah selesai, pastikan tidak ada bagian kode yang tertinggal. Jalankan kembali aplikasinya, dan coba Anda pilih tombol  Pindah Activity untuk Result . Pilih angka yang Anda suka dan lihat hasilnya. Di  MainActivity  sudah ada angka yang tadi Anda pilih di objek TextView. Bedah Kode registerForActivityResult Untuk membuat sebuah Activity yang dapat mengembalikan nilai, kita perlu membuat objek ActivityResultLauncher terlebih dahulu seperti ini:   Kotlin private val resultLauncher:  ActivityResultLauncher<Intent>  =  registerForActivityResult (      ActivityResultContracts.StartActivityForResult()  ) { result ->     ... } Java final  ActivityResultLauncher<Intent>  resultLauncher =  registerForActivityResult (new  ActivityResultContracts.StartActivityForResult() ,         result -> {             ...         }); Anda perlu mendaftarkan jenis kembalian ke sistem dengan menggunakan kode  registerForActivityResult   dengan parameter  ActivityResultContract  berupa  ActivityResultContract . Hal ini karena kita akan mendapatkan nilai kembalian setelah memanggil Activity baru. Perlu diketahui bahwa kita juga bisa mendapatkan nilai kembalian dari selain Activity, contohnya seperti foto dari galeri dengan mendefinisikan  contract  yang berbeda. Selanjutnya, perbedaan mendasar antara perpindahan Activity untuk menghasilkan nilai balik dengan tidak, adalah pada metode untuk menjalankan object Intent-nya. Sebelumnya kita menggunakan  startActivity(intent)  untuk berpindah Activity.  Nah , kali ini kita menggunakan  launch(intent)  dari object  ActivityResultLauncher . Kotlin val moveForResultIntent = Intent(this@MainActivity, MoveForResultActivity::class.java) resultLauncher. launch (moveForResultIntent) Java Intent moveForResultIntent = new Intent(MainActivity.this, MoveForResultActivity.class); resultLauncher. launch (moveForResultIntent); Mengatur dan Membaca Nilai Hasil Pada  MoveForResultActivity  kita memilih satu angka, sebagai contoh angka 150. Kemudian ketika tombol ‘ Pilih ’ ditekan. Maka baris kode di bawah ini akan dijalankan. Kotlin override fun onClick(v: View) {     if (v.id == R.id.btn_choose) {         if (rgNumber.checkedRadioButtonId > 0) {             var value = 0             when (rgNumber.checkedRadioButtonId) {                 R.id.rb_50 -> value = 50                  R.id.rb_100 -> value = 100                  R.id.rb_150 -> value = 150                  R.id.rb_200 -> value = 200             }              val resultIntent = Intent()             resultIntent.putExtra(EXTRA_SELECTED_VALUE, value)             setResult(RESULT_CODE, resultIntent)             finish()         }     } } Java @Override public void onClick(View v) {     if (v.getId() == R.id.btn_choose) {         if (rgNumber.getCheckedRadioButtonId() != 0) {             int value = 0;             int id = rgNumber.getCheckedRadioButtonId();             if (id == R.id.rb_50) {                 value = 50;             } else if (id == R.id.rb_100) {                 value = 100;             } else if (id == R.id.rb_150) {                 value = 150;             } else if (id == R.id.rb_200) {                 value = 200;             }              Intent resultIntent = new Intent();             resultIntent.putExtra(EXTRA_SELECTED_VALUE, value);             setResult(RESULT_CODE, resultIntent);             finish();         }     } } Pada kode di atas berfungsi untuk melakukan validasi nilai dari objek RadioButton yang dipilih. Bila ada nilai dari radiobutton, maka proses selanjutnya adalah menentukan objek RadioButton mana yang diklik berdasarkan nilai dari  rgNumber.getCheckedRadioButtonId() . Mengapa kita tidak memeriksa langsung ke objek RadioButton? Karena kita menggunakan RadioGroup sebagai  parent  pada objek-objek RadioButton. Secara otomatis kita bisa mendapatkan mana objek RadioButton yang dipilih dengan  rgNumber.getCheckedRadioButtonId() . <RadioGroup    android:id=""@+id/rg_number""    android:layout_width=""match_parent""    android:layout_height=""wrap_content""    android:orientation=""vertical"">    <RadioButton        android:id=""@+id/rb_50""        android:layout_width=""match_parent""        android:layout_height=""wrap_content""        android:text=""50""        android:layout_marginBottom=""16dp""/>    <RadioButton        android:id=""@+id/rb_100""        android:layout_width=""match_parent""        android:layout_height=""wrap_content""        android:text=""100""        android:layout_marginBottom=""16dp""/>    <RadioButton        android:id=""@+id/rb_150""        android:layout_width=""match_parent""        android:layout_height=""wrap_content""        android:text=""150""        android:layout_marginBottom=""16dp""/>    <RadioButton        android:id=""@+id/rb_200""        android:layout_width=""match_parent""        android:layout_height=""wrap_content""        android:text=""200""        android:layout_marginBottom=""16dp""/> </RadioGroup> Selanjutnya, ketika sudah didapatkan nilainya, baris ini akan dieksekusi: Kotlin val resultIntent = Intent() resultIntent.putExtra(EXTRA_SELECTED_VALUE, value)  setResult(RESULT_CODE, resultIntent)  finish() Java Intent resultIntent = new Intent(); resultIntent.putExtra( EXTRA_SELECTED_VALUE , value);  setResult( RESULT_CODE , resultIntent);  finish(); Kita membuat sebuah Intent tanpa ada inputan apa pun di konstruktornya. Kemudian kita meletakkan variabel  value  ke dalam metode  putExtra(Key, Value)  dengan  EXTRA_SELECTED_VALUE  bertipekan  static string  dan bernilai  “extra_selected_value” . Kemudian kita jadikan obyek  resultIntent  yang telah dibuat sebelumnya menjadi parameter dari  setResult(RESULT_CODE, Intent) . Setelah itu, kita panggil method  finish()  untuk menutup  MoveForResultActivity  dan kembali ke Activity sebelumnya. Ketika  MoveForResultActivity  telah tertutup sempurna, maka callback  ActivityResultLauncher  pada  MainActivity  akan dijalankan. Kotlin private val resultLauncher: ActivityResultLauncher<Intent> = registerForActivityResult(     ActivityResultContracts.StartActivityForResult() ) { result ->      if (result.resultCode == MoveForResultActivity.RESULT_CODE && result.data != null) {         val selectedValue =             result.data?.getIntExtra(MoveForResultActivity.EXTRA_SELECTED_VALUE, 0)         tvResult.text = ""Hasil : $selectedValue""     }  } Java final ActivityResultLauncher<Intent> resultLauncher = registerForActivityResult(new ActivityResultContracts.StartActivityForResult(),         result -> {              if (result.getResultCode() == MoveForResultActivity.RESULT_CODE && result.getData() != null) {                 int selectedValue = result.getData().getIntExtra(MoveForResultActivity.EXTRA_SELECTED_VALUE, 0);                 tvResult.setText(String.format(""Hasil : %s"", selectedValue));             }          }); Di sinilah  MainActivity  akan merespon terhadap nilai balik yang dikirimkan oleh  MoveForResultActivity . Pada baris 4 di atas, dilakukan perbandingan apakah nilai  resultCode  sama yang dikirim oleh  MoveForResultActivity . Selain itu, juga diperiksa, apakah data yang dikembalikan bernilai null atau tidak. Bila semua kondisi terpenuhi, data RadioButton yang dipilih akan ditampilkan di TextView  tvResult . Untuk lebih dalam lagi silakan pelajari materi pada tautan berikut:  Intent Result Keren! Anda sudah belajar dasar-dasar penggunaan intent secara umum di proyek aplikasi Android. 4 intent secara eksplisit dan 1 secara implisit dengan satu di antaranya mencakup nilai balik dari Activity yang dijalankan. Untuk mendalami materi intent, silakan meluncur ke tautan di bawah ini. Intent Filters Untuk source code materi, silakan unduh di tautan berikut ini : Source Code Latihan Intent";Latihan ini membahas tentang cara mendapatkan nilai balik dari Intent antara Activity dalam pengembangan aplikasi Android. Ketika Activity A menjalankan Activity B, kadang kita perlu menerima hasil dari Activity B sebelum ditutup. Contohnya, Activity B memungkinkan pengguna untuk memilih angka dari beberapa pilihan yang disajikan dalam bentuk RadioButton. Setelah pengguna membuat pilihan dan menekan tombol, angka yang dipilih dikirimkan kembali ke Activity A menggunakan Intent. Proses ini dimulai dengan membuat Activity baru bernama MoveForResultActivity, di mana layoutnya berisi TextView, RadioGroup, RadioButton, dan Button. Setelah itu, di dalam MoveForResultActivity, kita menangani klik pada tombol untuk mengambil nilai dari RadioButton yang dipilih dan mengembalikannya ke Activity A menggunakan setResult() dan finish(). Di MainActivity, kita menggunakan ActivityResultLauncher untuk meluncurkan MoveForResultActivity dan menerima hasilnya. Ketika hasil diterima, kita memeriksa kode hasil dan menampilkan nilai yang dikembalikan pada TextView. Latihan ini menunjukkan cara yang efisien untuk berinteraksi antara Activity dengan nilai balik menggunakan Intent.
"Debugging dengan Logging dan Debug Breakpoint Tujuan Ketika mengembangkan aplikasi Android, tentu salah satu hal yang paling menantang adalah saat menemukan  bug  ketika aplikasi dijalankan. Memecahkan sebuah  bug  di platform android bukanlah hal yang mudah. Ada beragam spesifikasi perangkat android yang beredar di pasar. Aplikasi kita bisa jadi berjalan lancar di satu peranti. Namun bermasalah di peranti yang berbeda. Memusingkan, bukan? Tetapi inilah tantangannya! Untuk itulah kita mengetahui beberapa cara untuk melakukan Debugging. Debugging adalah proses untuk mengidentifikasi bug atau masalah yang muncul dan mencari solusinya. Alur Latihan Berikut alur yang akan kita pelajari dalam latihan ini:  Membuat aplikasi menjadi crash. Membaca error pada Logcat. Menampilkan Log. Menampilkan Debug Breakpoint. Codelab Debugging Sangat krusial bagi  developer  untuk mampu menangani setiap  bug  yang muncul. Kita perlu mengenal bagaimana cara menemukan  bug  pada aplikasi Android. Berikut adalah cara-caranya: Buat Project baru di Android Studio dengan kriteria sebagai berikut: Nama Project MyTestingApp Target & Minimum Target SDK Phone and Tablet, Api level 21 Tipe Activity Empty Activity Activity Name MainActivity Use AndroidX artifacts True Language Kotlin/Java Selanjutnya pada  activity_main.xml  lengkapi kodenya menjadi seperti berikut: <?xml version=""1.0"" encoding=""utf-8""?> <RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android""     xmlns:tools=""http://schemas.android.com/tools""     android:id=""@+id/activity_main""     android:layout_width=""match_parent""     android:layout_height=""match_parent""      android:padding=""16dp"">        <TextView         android:id=""@+id/tv_text""         android:layout_width=""wrap_content""         android:layout_height=""wrap_content""         android:text=""@string/hello_world"" />      <Button         android:id=""@+id/btn_set_value""         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:layout_below=""@id/tv_text""         android:text=""@string/set_value""/>   </RelativeLayout> Tambahkan resource string di dalam  res → values → strings.xml . <resources>     <string name=""app_name"">MyTestingApp</string>      <string name=""set_value"">Set Nilai</string>     <string name=""hello_world"">Hello World!</string>  </resources> Sekarang kita akan melakukan pengujian aplikasi untuk mendapatkan eror NullPointerException. Pada  MainActivity ,   silakan lengkapi kodenya menjadi seperti berikut ini: Kotlin class MainActivity : AppCompatActivity() , View.OnClickListener  {      private var btnSetValue: Button? = null     private lateinit var tvText: TextView       override fun onCreate(savedInstanceState: Bundle?) {         super.onCreate(savedInstanceState)         setContentView(R.layout.activity_main)           tvText = findViewById(R.id.tv_text)         btnSetValue!!.setOnClickListener(this)      }       override fun onClick(view: View) {         if (view.id == R.id.btn_set_value) {             tvText.text = ""19""         }     }  } Java public class MainActivity extends AppCompatActivity  implements View.OnClickListener  {      private Button btnSetValue;     private TextView tvText;       @Override     protected void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout.activity_main);           tvText = findViewById(R.id.tv_text);         btnSetValue.setOnClickListener(this);      }       @Override     public void onClick(View view) {         if (view.getId() == R.id.btn_set_value) {             tvText.setText(""19"");         }     }  } Setelah selesai, silakan jalankan aplikasi. Seharusnya jika kita klik button  Set Nilai , aplikasi akan langsung  force close  seperti di bawah ini. Perhatikan  tab   l ogcat  di bagian bawah  editor  Android Studio yang menampilkan  log  berwarna merah seperti berikut ini. Jelasnya seperti ini: E/AndroidRuntime: FATAL EXCEPTION: main     Process: com.dicoding.picodiploma.mytestingapp, PID: 15645     java.lang.RuntimeException: Unable to start activity ComponentInfo{com.dicoding.picodiploma.mytestingapp/com.dicoding.picodiploma.mytestingapp.MainActivity}: java.lang.NullPointerException         at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2913)         at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3048)         at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:78)         at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:108)         at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:68)         at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1808)         at android.os.Handler.dispatchMessage(Handler.java:106)         at android.os.Looper.loop(Looper.java:193)         at android.app.ActivityThread.main(ActivityThread.java:6669)         at java.lang.reflect.Method.invoke(Native Method)         at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:493)         at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:858)      Caused by: java.lang.NullPointerException         at com.dicoding.picodiploma.mytestingapp.MainActivity.onCreate(MainActivity.kt:29)         at android.app.Activity.performCreate(Activity.java:7136)         at android.app.Activity.performCreate(Activity.java:7127)         ... Catatan: Terkadang aplikasi langsung force close   tanpa menampilkan eror. hal ini karena dia langsung restart app ketika terjadi force close, jadi tidak terlihat errornya. Apabila ini terjadi, buka kembali aplikasi dan buat aplikasi eror sampai berulang kali. Ketika pop up muncul, barulah nanti pesan eror akan muncul. Hal lain yang perlu diperhatikan adalah pastikan Anda memilih emulator dan aplikasi yang tepat pada Logcat. Jangan sampai memilih aplikasi yang sudah dead padahal bisa dibuka. Dengan memperhatikan log di atas, kita dapat mengetahui penyebab erornya: Caused by: java.lang.NullPointerException Eror  NullPointerException  muncul karena kita mencoba menekan button   yang belum diinisiasi (masih bernilai  null ). Solusinya, kita perlu menginisiasi obyek dengan cara berikut: Kotlin class MainActivity : AppCompatActivity(), View.OnClickListener {       private lateinit var btnSetValue: Button      private lateinit var tvText: TextView      override fun onCreate(savedInstanceState: Bundle?) {         super.onCreate(savedInstanceState)         setContentView(R.layout.activity_main)           btnSetValue = findViewById(R.id.btn_set_value)          tvText = findViewById(R.id.tv_text)          btnSetValue.setOnClickListener(this)     } Java btnSetValue = findViewById(R.id.btn_set_value); Kemudian jalankan aplikasi kembali, maka eror sudah tidak muncul lagi. Selanjutnya kita coba untuk memunculkan eror lainnya dengan menambahkan beberapa baris kode yang ditebalkan pada  MainActivity  seperti baris berikut: Kotlin class MainActivity : AppCompatActivity(), View.OnClickListener {      private lateinit var btnSetValue: Button     private lateinit var tvText: TextView       private var names = ArrayList<String>()       override fun onCreate(savedInstanceState: Bundle?) {         super.onCreate(savedInstanceState)         setContentView(R.layout.activity_main)          btnSetValue = findViewById(R.id.btn_set_value)         tvText = findViewById(R.id.tv_text)          btnSetValue.setOnClickListener(this)           names.add(""Narenda Wicaksono"")         names.add(""Kevin"")         names.add(""Yoza"")      }      override fun onClick(view: View) {          if (view.id == R.id.btn_set_value) {               Log.d(""MainActivity"", names.toString())              val name = StringBuilder()             for (i in 0..3) {                 name.append(names[i]).append(""\n"")             }             tvText.text = name.toString()         }      } } Java public class MainActivity extends AppCompatActivity implements View.OnClickListener {     private Button btnSetValue;     private TextView tvText;      private ArrayList<String> names;       @Override     protected void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout.activity_main);         btnSetValue = findViewById(R.id.btn_set_value);         tvText = findViewById(R.id.tv_text);         btnSetValue.setOnClickListener(this);           names = new ArrayList<>();         names.add(""Narenda Wicaksono"");         names.add(""Kevin"");         names.add(""Yoza"");      }      @Override     public void onClick(View view) {          if (view.getId() == R.id.btn_set_value) {               Log.d(""MainActivity"", names.toString());             StringBuilder name = new StringBuilder();             for (int i = 0; i <= 3; i++){                 name.append(names.get(i)).append(""\n"");             }             tvText.setText(name.toString());         }      } } Ketika kita klik button  Set Nilai  muncul kembali eror seperti berikut: Dan perhatikan eror pada android monitor seperti berikut: 2019-01-21 11:52:04.028 13739-13739/com.dicoding.picodiploma.testingapp E/AndroidRuntime: FATAL EXCEPTION: main     Process: com.dicoding.picodiploma.testingapp, PID: 13739     java.lang.IndexOutOfBoundsException: Index: 3, Size: 3         at java.util.ArrayList.get(ArrayList.java:437)          at com.dicoding.picodiploma.testingapp.MainActivity.onClick(MainActivity.java:35)          at android.view.View.performClick(View.java:6597)         at android.view.View.performClickInternal(View.java:6574)         at android.view.View.access$3100(View.java:778)         at android.view.View$PerformClick.run(View.java:25885)         at android.os.Handler.handleCallback(Handler.java:873)         at android.os.Handler.dispatchMessage(Handler.java:99)         at android.os.Looper.loop(Looper.java:193)         at android.app.ActivityThread.main(ActivityThread.java:6669)         at java.lang.reflect.Method.invoke(Native Method)         at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:493)         at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:858) Kode di atas akan memunculkan  IndexOutOfBoundsException .  Collection names  memiliki 3  item . Karena sebuah  collection  dimulai dari 0, maka  item  terakhirnya berada pada indeks ke 2. Ketika kita hendak mengambil data ke-3, maka  IndexOutOfBoundsException  akan dibangkitkan. Anda juga dapat memanfaatkan Log yang telah Anda sisipkan pada kode untuk menampilkan data nama pada Logcat, sehingga kalau dilihat pada Logcat akan muncul seperti ini (gunakan pencarian untuk mempermudah mencari suatu log): Dengan begitu Anda bisa memastikan berapa jumlah data maksimal yang dapat diambil. Hal ini akan sangat membantu jika Anda mengambil data dari database atau dari server internet yang datanya tidak dapat dilihat dari kode. Maka solusinya adalah dengan mengganti nilai maksimal perulangan dari 3 menjadi 2 berikut pada proses perulangan  for . Silakan jalankan kembali dan seharusnya sudah berjalan tanpa eror saat ini. Kotlin for (i in 0.. 2 ) { Java for (int i = 0; i <=  2 ; i++) { Bedah Kode Bug Terdapat tiga tipe jenis  bug  umum yang kerap terjadi pada proses pengembangan aplikasi Android:  Bug yang menyebabkan  Force Closed Kelompok  bug  ini akan menampilkan dialog  force closed .  Bug  ini dapat terjadi ketika kode kita tidak dapat menangani kondisi tertentu saat aplikasi sedang berjalan: Java Null Pointer Exception , umumnya terjadi ketika kode kita mengharapkan obyek tertentu untuk diproses, namun yang ia peroleh adalah nilai  null . Java Out of Memory Exception , umumnya terjadi karena memori yang digunakan oleh aplikasi melebihi jatah yang disediakan oleh sistem android.  Bug  ini bisa terjadi misalnya ketika kita memuat gambar dengan ukuran besar tanpa mengecilkannya terlebih dahulu. Java Index Out Of Bound , terjadi ketika kita mencoba mengakses data dengan indeks yang berada di luar jangkauan ukuran dari sebuah  collection  seperti arraylist atau linkedlist. Contoh dari masalah ini dapat Anda lihat pada kode berikut ini: Kotlin for (a in 0..presList.size) {     val companyName = presList[a + 1] } Java for (int a = 0; a < presList.size(); a++) {     String companyName = presList.get(a + 1); } Anggap  preList  memiliki 2 item di dalamnya. Masalah akan muncul ketika baris ini dijalankan  companyName = presList.get(a + 1); .   Pada perulangan kedua, nilai  a   bernilai 1. Ketika ia dijalankan maka ia akan berusaha mengambil  item  pada posisi ke 2 (a + 1 = 2, karena a bernilai 1). Tidak ada  item  pada posisi ke 2. Ini karena  collection  dimulai dari posisi 0. Sehingga posisi  valid  terakhir untuk  presList  adalah 1. Java Memory Leak,  ini adalah  bug  yang sangat berpengaruh pada performa aplikasi karena berhubungan dengan penggunaan memori peranti pengguna. Bug yang menyebabkan  Application is not Responding Android akan menganggap sebuah aplikasi sebagai  not responding  bila proses yang berjalan di  main thread  tidak selesai dalam waktu 5 detik. Bug yang disebabkan oleh kesalahan logika Ini adalah  bug  yang berbahaya. Kesalahan dalam kelompok ini dapat menyebabkan aplikasi berperilaku di luar rancangan kita walaupun aplikasi tidak  crash . Ketiga grup  bug  atau eror yang terjadi di android umumnya didasari pada beberapa hal. Pemahaman tentang proses bisnis yang dirancang. Pemahaman tentang komponen aplikasi android.  Konsep OOP dan pemahaman tentang Java yang digunakan. Ketelitian dalam menulis program (termasuk kesalahan algoritma yang ada) hingga pada kurang baiknya dalam melakukan pengujian aplikasi.  Tuliskan rancangan  testing  terlebih dahulu sebelum melakukan penulisan kode. Kenapa? Ini membuat penulisan kode mengarah pada proses pengujian yang sudah direncanakan berdasarkan rancangan proses yang ditentukan.  Ingat, aplikasi  mobile  itu sangat mahal dalam proses akuisisi pengguna untuk mengunduh aplikasi. Ketika terdapat eror  bug  yang tak bisa ditolerir , maka otomatis pengguna akan mencopot aplikasi buatan Anda dari perantinya. Sayang kan? Tenang, kita akan bahas cara mengatasi eror  bug   pada modul ini, seperti: Menemukan  bug  dari membaca android monitor. Melakukan perbaikan pada  bug. Melakukan proses  debugging  aplikasi. Melakukan otomasi  testing  dengan  tools  yang disediakan seperti Espresso untuk  ui testing  dan JUnit untuk unit testing (pada materi selanjutnya). Logging Logging adalah sebuah cara untuk menampilkan data di dalam Logcat. Hal ini akan memudahkan Anda dalam mendeteksi suatu data apakah sudah ada atau belum. Ia juga bisa digunakan untuk memberi tahu apakah suatu fungsi sudah terpanggil atau belum.   Untuk membuatnya Anda bisa menggunakan kode seperti berikut: Log.d(""MainActivity"", ""Data yang ingin ditampilkan"") Anda juga dapat membuatnya dengan lebih cepat dengan mengetik  logd  (dengan huruf  l  kecil dan  d  tersambung) untuk membuat log dengan isi nama fungsi seperti berikut: Untuk membuat TAG yang berisi nama Activity secara otomatis Anda juga dapat menggunakan  live template  logt   seperti berikut: Berikut ini adalah beberapa variasi log yang bisa Anda pilih, yaitu: Log.e()  untuk log error. Log.w()  untuk log warning. Log.i()  untuk log information. Log.d()  untuk log debug. Log.v()  untuk log verbose. Anda juga dapat melihat log secara spesifik dengan memilih tipe pada Logcat seperti berikut: Debug Breakpoint Inti untuk menemukan sebuah  bug  adalah dengan membaca  error   log  yang ada pada android monitor dengan seksama. Anda dapat melakukan  googling  dengan kata kunci yang lebih akurat ketika Anda dapat membaca  error log . Setelah kita mempelajari bagaimana menemukan dan mengenali  bug  umum yang biasa terjadi, sekarang saatnya kita mempelajari bagaimana melakukan proses  debug breakpoint . Debug breakpoint adalah fitur di dalam Android Studio untuk mendeteksi suatu nilai pada baris kode tertentu ketika aplikasi dijalankan.   Caranya adalah dengan menekan tombol  Debug 'app' pada toolbar. Kemudian Anda dapat menambahkan  breakpoint  dengan menekan baris kode yang ingin kita lihat prosesnya. Dengan adanya  breakpoint  ini, Anda dapat memantau proses yang sedang berjalan. Contohnya adalah sebagai berikut: Kemudian setelah dijalankan dan klik tombol  ""SET NILAI"" , aplikasi akan berhenti di baris  breakpoint    tersebut, dan di bagian  tab  Debug  kita bisa melihat nilai tiap-tiap variabel yang ada di activity itu. Jika ingin melanjutkan proses, Anda bisa mengklik tombol  Resume Program yang berwarna   hijau di sebelah kiri. Karena breakpoint di dalam perulangan, maka baris kode tersebut akan dipanggil sejumlah perulangan dan baru setelahnya lanjut ke breakpoint selanjutnya, yakni baris 40. Bisa dilihat nilai variabel  name  berubah sesuai dengan proses yang sedang berjalan. Pada modul ini Anda telah belajar beberapa  bug  umum yang terjadi dan bagaimana menelaah masalahnya. Anda juga telah belajar bagaimana melakukan proses  debugging . Inti dari proses di atas adalah ketelitian dan pemahaman yang menyeluruh tentang proses bisnis, algoritma, dan alur aplikasi yang dirancang. Kita tidak bisa menjamin bahwa aplikasi kita akan 100% terbebas dari  bug . Namun, tetaplah penting bagi kita meminimalisir eror yang terjadi sebelum meluncurkan aplikasi ke publik. Artikel yang bisa membantu Anda ketika mengalami eror di Android Studio: Dicoding Blog : Aplikasi Error! Apa yang harus dilakukan? New Logcat: 5 Features for Effective Android App Debugging Source code materi ini bisa Anda unduh di tautan berikut:  Source Code Latihan Debugging";Latihan ini mengajarkan teknik debugging dalam pengembangan aplikasi Android dengan menggunakan logging dan debug breakpoints. Anda akan membuat proyek baru, menyebabkan aplikasi crash dengan NullPointerException dan IndexOutOfBoundsException, serta belajar membaca log di Logcat untuk memahami penyebab kesalahan. Dengan menggunakan Log.d() untuk mencetak informasi debug dan menambahkan breakpoint di Android Studio, Anda dapat memantau nilai variabel saat aplikasi dijalankan, yang membantu dalam mengidentifikasi dan memperbaiki bug. Melalui proses ini, Anda akan meningkatkan keterampilan dalam menangani masalah yang muncul selama pengembangan aplikasi.
Latihan Menganalisis View dan View Group Tujuan Pada latihan kali ini kita akan menganalisis berbagai view dan view group yang ada di latihan sebelumnya. Kita bisa memeriksa detail dari setiap view dan view group sewaktu aplikasi dijalankan. Tujuannya adalah untuk memastikan apa yang Anda buat dalam berkas XML sesuai dengan yang tampil di layar. Selain itu, kita juga dapat mengantisipasi agar layout yang ditulis tidak menyebabkan bug atau masalah yang tak terduga.  Komponen yang akan kita gunakan untuk menganalisis tampilan adalah Layout Inspector. Layout Inspector sendiri sudah ada dalam bawaan Android Studio. Seperti inilah gambaran Layout Inspector ketika menganalisis view dan view group: Berikut detail dari masing-masing poin di atas: Component Tree : hierarki dari view yang ada dalam tampilan. Layout Display : menggambarkan bagaimana hasil rendering dari tata letak aplikasi seperti halnya yang muncul dalam perangkat atau emulator Anda. Di sini juga terdapat garis yang tampil pada setiap view. Layout Inspector toolbar : tool yang bisa kita manfaatkan untuk mengetahui jumlah tumpukan dalam view tersebut. Attributes : menjelaskan berbagai atribut dari sebuah view yang dipilih. Alur Latihan Berikut alur yang akan kita lakukan dalam latihan menganalisis view dan view group: Membuka project pada latihan sebelumnya.  Menjalankan project pada emulator atau real device. Menjalankan Layout Inspector pada Android Studio. Menganalisis setiap view yang ada dalam tampilan. Latihan Menganalisis View dan View Group Menganalisis view dan viewgroup menjadi langkah penting ketika membangun aplikasi. Sebab, kita bisa mendeteksi lebih dini bagaimana sebuah layout yang sudah dirancang dalam Android Studio muncul di layar. Selain itu, kita juga bisa memeriksa apakah atribut-atribut yang digunakan sesuai dengan yang diinginkan atau tidak.  Lalu, bagaimana cara untuk menganalisis tampilan aplikasi dalam emulator atau real device android? Yuk, silakan ikuti beberapa langkah berikut dengan seksama.  Langkah pertama yang harus Anda lakukan adalah membuka project latihan View dan View Group. Catatan:  Jika kesulitan dengan latihan sebelumnya, Anda dapat mengunduh hasilnya melalui tautan  Latihan View dan ViewGroup . Setelah itu, jalankan aplikasi tersebut, baik melalui emulator maupun  real device . Catatan:  Jika Anda menggunakan  real device , pastikan tetap terhubung dengan Laptop/PC. Oke, sampai di sini aplikasi sudah berjalan dengan baik. Mari kita analisis bagaimana susunan View dan View Group dari tampilan tersebut. Caranya cukup mudah, silakan klik  Tools , lalu pilih  Layout Inspector . Setelah itu, akan muncul tampilan seperti berikut. Pada bagian kotak merah inilah yang dinamakan Layout Inspector. Kita bisa melihat berbagai hal seputar tampilan aplikasi.   Jika tampilan aplikasi belum muncul, Anda perlu mengunduh Layout Inspector dari Android SDK. Bagaimana cara menginstalnya? Caranya cukup mudah, Anda cukup menekan item  3D Mode  dalam Layout Inspector berikut. Setelah itu, Android Studio akan mengunduh SDK Tools untuk Layout Inspector tersebut. Dengan begitu, Anda bisa menganalisis tampilan, baik secara 2 dimensi maupun 3 dimensi. Oke mari kita coba analisis lebih seksama. Berikut keterangan dari masing-masing item: Bagian kiri ( A ) dinamakan  Component Tree : Merupakan hierarki dari view yang ada dalam tampilan. Bagian tengah ( B ) dinamakan  Layout Display : Menggambarkan bagaimana hasil rendering dari tata letak aplikasi seperti halnya yang muncul dalam perangkat atau emulator Anda. Di sini juga terdapat garis yang tampil pada setiap view. Bagian tengah atas ( C ) dinamakan  Layout Inspector toolbar : Tool yang bisa kita manfaatkan untuk seberapa banyak tumpukan dalam view tersebut. Bagian kanan ( D ) dinamakan  Attributes : Menjelaskan berbagai atribut dari sebuah view yang dipilih. Mari kita coba bermain dengan  Component Tree . Seperti yang dijelaskan sebelumnya, bagian ini membahas hierarki dari sebuah View. Silakan buka semua grup dalam Component Tree. Semua view dan viewgroup dibungkus dalam satu viewgroup utama bernama  LinearLayout . Melalui Component Tree, Anda dapat melihat suatu view itu berada dalam group apa dan berada di mana dengan mudah. Bahkan, jika Anda perhatikan, nilai yang ada dalam view pun terlihat di sini. Mari kita beralih ke  Layout Display . Pada bagian ini, kita bisa melihat berbagai view yang ada dalam component tree tersusun rapi menjadi sebuah tampilan. Lalu bagaimana caranya untuk melihat berbagai lapisan yang ada dalam tampilan tersebut? Anda bisa mengubah mode 2 dimensi menjadi 3 dimensi seperti berikut. Kemudian hasilnya akan terlihat seperti ini: Anda bisa memutar-mutar tampilan untuk menganalisis layer atau tumpukan dalam tampilan tersebut. Selanjutnya kita akan membahas  Layout Inspector Toolbar . Pada bagian ini kita bisa mengatur spasi antar layar dalam Layout display. Selain itu, jika sedang menjalankan beberapa aplikasi, Anda dapat memilih aplikasi mana yang akan dianalisis. Dengan begitu, Anda bisa fokus menganalisis aplikasi tersebut. Sedangkan bagian paling kanan adalah Attribut. Ketika Anda menekan salah satu view, secara otomatis Android Studio akan menampilkan atribut dalam view tersebut. Menarik, kan? Anda dapat dengan mudah menganalisis berbagai atribut dalam suatu view. Tujuannya tentu agar sesuai dengan apa yang Anda inginkan atau rencanakan dalam rancangan desain atau mockup. Itulah beberapa manfaat Layout Inspector dalam Android Studio. Anda dapat melihat, menganalisa, bahkan melakukan debugging tampilan yang telah dibuat sewaktu dijalankan, baik pada emulator maupun real device. Untuk mempelajari lebih lanjut mengenai Layout Inspector, silakan kunjungi tautan berikut: Debug your layout with Layout Inspector and Layout Validation   Sekadar informasi, sebaik apapun tampilan, sebaiknya hindari penggunaan layout yang bertumpuk. Contohnya bagaimana? Suatu view berada dalam layer view group berlapis-lapis. Ini membuat proses rendering semakin melambat. Akibatnya, akan memicu masalah atau bug. Oleh karena itu, manfaatkan Layout Inspector ini untuk menganalisis tampilan aplikasi yang dibuat agar menjadi semakin lebih baik lagi.;Latihan ini bertujuan untuk menganalisis berbagai view dan view group dalam aplikasi Android menggunakan Layout Inspector di Android Studio. Dengan membuka proyek sebelumnya dan menjalankannya di emulator atau perangkat nyata, Anda dapat memeriksa susunan view dan view group untuk memastikan bahwa desain XML sesuai dengan tampilan yang dihasilkan. Layout Inspector menyediakan komponen seperti Component Tree untuk melihat hierarki view, Layout Display untuk menggambarkan rendering layout, dan Attributes untuk menampilkan atribut dari view yang dipilih. Anda juga dapat beralih antara mode 2D dan 3D untuk menganalisis tumpukan view. Penting untuk menghindari penggunaan layout yang bertumpuk untuk mencegah masalah performa, dan Layout Inspector membantu dalam mendeteksi serta memperbaiki potensi bug dalam tampilan aplikasi.
"Latihan ConstraintLayout Tujuan Pada latihan kali ini Anda akan mengembangkan sebuah halaman detail yang di dalamnya mengimplementasikan ConstraintLayout. Tampilan akhir aplikasi akan jadi seperti ini: Alur Latihan Berikut alur yang akan kita pelajari dalam latihan ini:  Menambahkan  Constraint  pada komponen. Mengatur  Relative Positioning  suatu komponen terhadap komponen lainnya. Mengatur  Alignment  pada beberapa komponen. Mendesain menggunakan  Guideline . Codelab ConstraintLayout Kali ini kita akan menggunakan ConstraintLayout   untuk membuat  layout   yang menyerupai latihan sebelumnya.  Let’s start! Buat proyek baru di Android Studio dengan kriteria sebagai berikut: Nama Project MyConstraintView Target & Minimum Target SDK Phone and Tablet, Api level 21 Tipe Activity Empty Activity Activity Name MainActivity Use AndroidX Artifacts True Language Kotlin/Java Karena kita akan membuat  layout  yang sama, maka ambil sumber ( resources ) yang ada dari latihan sebelumnya.  Copy  semua  strings.xml  dan  resource image  yang ada di folder  drawable .  Jika kesulitan, Anda bisa mengunduhnya kembali menggunakan tautan berikut:  Asset Latihan . Sekarang masuk ke  activity_main.xml . Ganti  layout  dengan peranti yang besar ukuran  height -nya, karena kita akan membuat  layout  yang cukup tinggi. Pilihlah  device  Pixel XL . Okay , kita mulai tambahkan  view -nya satu per satu. Tambahkan  ImageView . <ImageView     android:layout_width=""0dp""     android:layout_height=""wrap_content""     android:adjustViewBounds=""true""     android:scaleType=""fitXY""     app:srcCompat=""@drawable/pixel_google"" /> Tambahkan  TextView . <TextView     android:layout_width=""wrap_content""     android:layout_height=""wrap_content""     android:background=""#4D000000""     android:drawableLeft=""@drawable/ic_collections_white_18dp""     android:drawablePadding=""4dp""     android:drawableStart=""@drawable/ic_collections_white_18dp""     android:elevation=""2dp""     android:padding=""8dp""     android:text=""@string/ dummy_photos ""     android:textAppearance=""@style/TextAppearance.AppCompat.Small""     android:textColor=""@android:color/white""     tools:layout_editor_absoluteX=""16dp""     tools:layout_editor_absoluteY=""193dp"" /> Sekarang layout  activity_main.xml  akan menjadi seperti ini: <?xml version=""1.0"" encoding=""utf-8""?> <androidx.constraintlayout.widget.ConstraintLayout xmlns:android=""http://schemas.android.com/apk/res/android""     xmlns:app=""http://schemas.android.com/apk/res-auto""     xmlns:tools=""http://schemas.android.com/tools""     android:layout_width=""match_parent""     android:layout_height=""match_parent"">      <ImageView         android:layout_width=""0dp""         android:layout_height=""wrap_content""         android:adjustViewBounds=""true""         android:scaleType=""fitXY""         app:srcCompat=""@drawable/pixel_google"" />      <TextView         android:layout_width=""wrap_content""         android:layout_height=""wrap_content""         android:background=""#4D000000""         android:drawableLeft=""@drawable/ic_collections_white_18dp""         android:drawablePadding=""4dp""         android:drawableStart=""@drawable/ic_collections_white_18dp""         android:elevation=""2dp""         android:padding=""8dp""         android:text=""@string/dummy_photos""         android:textAppearance=""@style/TextAppearance.AppCompat.Small""         android:textColor=""@android:color/white""         tools:layout_editor_absoluteX=""16dp""         tools:layout_editor_absoluteY=""193dp"" /> </androidx.constraintlayout.widget.ConstraintLayout> Sekarang, kita akan menambahkan  constraint  untuk 2  v iew  yang ada. Masuk ke  tab  design . Kemudian  pilih ImageView  yang ada. Perhatikan  tab  attributes  yang ada di sebelah kanan. Tambahkan  constraint   left ,  top ,  right  dan  bottom . Setelah ditambahkan ketiganya. Angka  0  adalah nilai  margin . Coba Anda ubah semua nilainya menjadi  16dp . Alhasil, bisa kita lihat layout-nya menjadi seperti ini: Sekarang posisi dari gambarnya berada di tengah. Kita perlu memberikan aksi  drag  seperti gambar di bawah, untuk memindahkan gambar agar berada di atas tampilan. Alright,  karena kita akan membuat  layout  yang sama dengan latihan sebelumnya, ayo kembalikan nilai  margin -nya menjadi 0. Tambahkan atribut  id  ke imageview. Beri  id- nya  image_phone . Sehingga kode dari  ImageView  menjadi seperti ini:  <ImageView      android:id=""@+id/image_phone""      android:layout_width=""0dp""     android:layout_height=""wrap_content""     android:adjustViewBounds=""true""     android:scaleType=""fitXY""     app:layout_constraintBottom_toBottomOf=""parent""     app:layout_constraintEnd_toEndOf=""parent""     app:layout_constraintStart_toStartOf=""parent""     app:layout_constraintTop_toTopOf=""parent""     app:layout_constraintVertical_bias=""0.0""     app:srcCompat=""@drawable/pixel_google"" /> Sekarang kita tambahkan constraint untuk teks  6 photos . Tambahkan  connection  left ,  top ,  right , dan  bottom  ke ImageView  image_phone . Ikuti gambar berikut: Jika mengalami kesulitan saat menggunakan  tab  design , gunakanlah  tab  text . Sehingga TextView menjadi seperti berikut: <TextView     android:layout_width=""wrap_content""     android:layout_height=""wrap_content""     android:layout_marginStart=""8dp""     android:layout_marginTop=""8dp""     android:layout_marginEnd=""8dp""     android:layout_marginBottom=""8dp""     android:background=""#4D000000""     android:drawableStart=""@drawable/ic_collections_white_18dp""     android:drawableLeft=""@drawable/ic_collections_white_18dp""     android:drawablePadding=""4dp""     android:elevation=""2dp""     android:padding=""8dp""     android:text=""@string/dummy_photos""     android:textAppearance=""@style/TextAppearance.AppCompat.Small""     android:textColor=""@android:color/white""     app:layout_constraintBottom_toBottomOf=""@+id/image_phone""     app:layout_constraintEnd_toEndOf=""parent""     app:layout_constraintHorizontal_bias=""0""     app:layout_constraintStart_toStartOf=""parent""     app:layout_constraintTop_toTopOf=""parent""     app:layout_constraintVertical_bias=""1"" /> Sekarang kita akan menambahkan 3 TextView baru. Berikut ini kodenya: <?xml version=""1.0"" encoding=""utf-8""?> <androidx.constraintlayout.widget.ConstraintLayout xmlns:android=""http://schemas.android.com/apk/res/android""     xmlns:app=""http://schemas.android.com/apk/res-auto""     xmlns:tools=""http://schemas.android.com/tools""     android:layout_width=""match_parent""     android:layout_height=""match_parent""     tools:context="".MainActivity"">     <ImageView .../>     <TextView .../>       <TextView         android:id=""@+id/text_price""         android:layout_width=""0dp""         android:layout_height=""wrap_content""         android:text=""@string/dummy_value""         android:textColor=""@android:color/black""         android:textSize=""32sp""         tools:layout_editor_absoluteX=""0dp""         tools:layout_editor_absoluteY=""273dp"" />      <TextView         android:id=""@+id/ text_stock ""         android:layout_width=""match_parent""         android:layout_height=""21dp""         android:text=""@string/stock""         android:textSize=""12sp""         tools:layout_editor_absoluteY=""349dp"" />      <TextView         android:id=""@+id/ text_ description ""         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:lineSpacingMultiplier=""1""         android:text=""@string/content_text""         android:textColor=""@android:color/black""         tools:layout_editor_absoluteX=""0dp""         tools:layout_editor_absoluteY=""429dp"" />  </androidx.constraintlayout.widget.ConstraintLayout> Tambahkan  constraint left  dan  right  untuk teks  $735 , atur nilai marginya menjadi  8dp . Sesuaikan juga untuk width menjadi  match_constraint  dan height menjadi  wrap_content , kita juga bisa menggantinya dengan klik  4 garis  yang ada pada atribut. Mari kita sedikit uji coba dengan mengganti nilai  constraint  width -nya menjadi  wrap_content . Di sini kita bisa sesuaikan dengan yang kita inginkan, apakah  wrap_content  yaitu mengikuti ukuran view, atau  match_constraint  yaitu mengikuti constraint yang telah kita tentukan. Jangan lupa mengembalikan nilai  width  dari  $735  menjadi  match_constraint  kembali. Selanjutnya, mari kita gunakan fitur  alignment  secara kelompok.  Select  ketiga  v iew  dengan menekan tombol  Shift + kemudian klik satu per satu  viewnya. Kemudian klik kanan pilih  Align . Ada banyak opsi  alignment  yang bisa kita pilih. Pilihlah  Align Left Edges , karena kita akan menempatkan semua teks menjadi rata kiri. Selanjutnya adalah nilai  constraint left  pada teks  $735  menjadi  0 . Nah, sekarang sudah rata kiri. Setelah itu kita tambahkan  constraint  pada  text_description  dan  text_stock  agar lebih baik. Dengan mengatur  to p ,  ri ght  dan   left  constrain -nya. Secara keseluruhan kode yang sudah kita tambahkan menjadi seperti ini: <?xml version=""1.0"" encoding=""utf-8""?> <androidx.constraintlayout.widget.ConstraintLayout xmlns:android=""http://schemas.android.com/apk/res/android""     xmlns:app=""http://schemas.android.com/apk/res-auto""     xmlns:tools=""http://schemas.android.com/tools""     android:layout_width=""match_parent""     android:layout_height=""match_parent""     tools:context="".MainActivity"">      <ImageView         android:id=""@+id/image_phone""         android:layout_width=""0dp""         android:layout_height=""wrap_content""         android:adjustViewBounds=""true""         android:scaleType=""fitXY""         app:layout_constraintBottom_toBottomOf=""parent""         app:layout_constraintEnd_toEndOf=""parent""         app:layout_constraintStart_toStartOf=""parent""         app:layout_constraintTop_toTopOf=""parent""         app:layout_constraintVertical_bias=""0.0""         app:srcCompat=""@drawable/pixel_google"" />      <TextView         android:layout_width=""wrap_content""         android:layout_height=""wrap_content""         android:layout_marginStart=""8dp""         android:layout_marginTop=""8dp""         android:layout_marginEnd=""8dp""         android:layout_marginBottom=""8dp""         android:background=""#4D000000""         android:drawableStart=""@drawable/ic_collections_white_18dp""         android:drawableLeft=""@drawable/ic_collections_white_18dp""         android:drawablePadding=""4dp""         android:elevation=""2dp""         android:padding=""8dp""         android:text=""@string/dummy_photos""         android:textAppearance=""@style/TextAppearance.AppCompat.Small""         android:textColor=""@android:color/white""         app:layout_constraintBottom_toBottomOf=""@+id/image_phone""         app:layout_constraintEnd_toEndOf=""parent""         app:layout_constraintHorizontal_bias=""0""         app:layout_constraintStart_toStartOf=""parent""         app:layout_constraintTop_toTopOf=""parent""         app:layout_constraintVertical_bias=""1"" />      <TextView         android:id=""@+id/text_price""         android:layout_width=""0dp""         android:layout_height=""wrap_content""         android:layout_marginTop=""8dp""         android:text=""@string/dummy_value""         android:textColor=""@android:color/black""         android:textSize=""32sp""         app:layout_constraintStart_toStartOf=""@+id/text_stock""         app:layout_constraintTop_toBottomOf=""@+id/image_phone"" />      <TextView         android:id=""@+id/text_stock""         android:layout_width=""match_parent""         android:layout_height=""21dp""         android:layout_marginStart=""8dp""         android:layout_marginTop=""8dp""         android:layout_marginEnd=""8dp""         android:text=""@string/stock""         android:textSize=""12sp""         app:layout_constraintEnd_toEndOf=""parent""         app:layout_constraintStart_toStartOf=""@+id/text_ description ""         app:layout_constraintTop_toBottomOf=""@+id/text_price"" />      <TextView         android:id=""@+id/text_ description ""         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:layout_marginStart=""8dp""         android:layout_marginTop=""8dp""         android:layout_marginEnd=""8dp""         android:lineSpacingMultiplier=""1""         android:text=""@string/content_text""         android:textColor=""@android:color/black""         app:layout_constraintEnd_toEndOf=""parent""         app:layout_constraintStart_toStartOf=""parent""         app:layout_constraintTop_toBottomOf=""@+id/text_stock"" /> </androidx.constraintlayout.widget.ConstraintLayout> Tampilannya akan menjadi seperti ini: Oke, kini sudah setengah jadi. Sekarang ubah  root layout -nya menjadi ScrollView. Pindah  ConstraintLayout  kita di dalam  Scrollview  tersebut. <?xml version=""1.0"" encoding=""utf-8""?> < ScrollView  xmlns:android=""http://schemas.android.com/apk/res/android""     xmlns:app=""http://schemas.android.com/apk/res-auto""     xmlns:tools=""http://schemas.android.com/tools""     android:layout_width=""match_parent""     android:layout_height=""match_parent""     tools:context="".MainActivity"">        <androidx.constraintlayout.widget.ConstraintLayout         android:layout_width=""match_parent""         android:layout_height=""wrap_content"">            <ImageView ... />          <TextView ... />          <TextView ... />          <TextView ... />        </androidx.constraintlayout.widget.ConstraintLayout> </ScrollView> Selanjutnya kita akan membuat tampilan yang berbentuk seperti tabel. Mari kita manfaatkan fitur  include  di dalam  layout . Buatlah layout baru dengan caranya seperti di bawah ini: Kemudian beri nama  layout_specification . Tambahkan kode untuk  layout_specification.xml . <?xml version=""1.0"" encoding=""utf-8""?> <androidx.constraintlayout.widget.ConstraintLayout xmlns:android=""http://schemas.android.com/apk/res/android""     xmlns:app=""http://schemas.android.com/apk/res-auto""     xmlns:tools=""http://schemas.android.com/tools""     android:layout_width=""match_parent""     android:layout_height=""wrap_content"">      <TextView         android:id=""@+id/text_specification""         android:layout_width=""wrap_content""         android:layout_height=""0dp""         android:text=""@string/specification""         tools:layout_editor_absoluteX=""16dp""         tools:layout_editor_absoluteY=""16dp"" />      <TextView         android:id=""@+id/text_spec_display_title""         android:layout_width=""58dp""         android:layout_height=""wrap_content""         android:text=""@string/display""         tools:layout_editor_absoluteX=""16dp""         tools:layout_editor_absoluteY=""51dp"" />      <TextView         android:id=""@+id/text_spec_display""         android:layout_width=""0dp""         android:layout_height=""wrap_content""         android:text=""@string/content_specs_display""         tools:layout_editor_absoluteX=""106dp""         tools:layout_editor_absoluteY=""51dp"" />      <TextView         android:id=""@+id/text_spec_size_title""         android:layout_width=""0dp""         android:layout_height=""wrap_content""         android:text=""@string/size""         tools:layout_editor_absoluteX=""16dp""         tools:layout_editor_absoluteY=""115dp"" />      <TextView         android:id=""@+id/text_spec_size""         android:layout_width=""0dp""         android:layout_height=""wrap_content""         android:text=""@string/content_specs_size""         tools:layout_editor_absoluteX=""106dp""         tools:layout_editor_absoluteY=""115dp"" />      <TextView         android:id=""@+id/text_battery_title""         android:layout_width=""0dp""         android:layout_height=""wrap_content""         android:text=""@string/battery""         tools:layout_editor_absoluteX=""16dp""         tools:layout_editor_absoluteY=""165dp"" />      <TextView         android:id=""@+id/text_battery""         android:layout_width=""0dp""         android:layout_height=""266dp""         android:text=""@string/content_specs_battery""         tools:layout_editor_absoluteX=""106dp""         tools:layout_editor_absoluteY=""165dp"" />  </androidx.constraintlayout.widget.ConstraintLayout> Sehingga, tampilannya menjadi seperti ini: Tambahkan  guidelines  dengan cara klik kanan pada  layout . Kemudian akan ada komponen  guidelines  yang ada di  component tree , sebelah kiri bawah. Kemudian akan terlihat garis  guidelines -nya di  layout . Geser  guidelines -nya sampai nilainya menjadi  105 . Guidelines  merupakan garis pembatas yang tidak terlihat ketika aplikasi dijalankan. Kita bisa menggunakan  guidelines  sebagai acuan dari  constraint  tiap  View . Selanjutnya adalah tambahkan  constraint  tiap  View  hingga membentuk seperti ini: Atau dalam kode menjadi seperti berikut: <?xml version=""1.0"" encoding=""utf-8""?> <androidx.constraintlayout.widget.ConstraintLayout xmlns:android=""http://schemas.android.com/apk/res/android""     xmlns:app=""http://schemas.android.com/apk/res-auto""     android:layout_width=""match_parent""     android:layout_height=""wrap_content"">      <TextView         android:id=""@+id/text_specification""         android:layout_width=""wrap_content""         android:layout_height=""0dp""         android:layout_marginStart=""8dp""         android:layout_marginTop=""8dp""         android:text=""@string/specification""         app:layout_constraintStart_toStartOf=""parent""         app:layout_constraintTop_toTopOf=""parent"" />      <TextView         android:id=""@+id/text_spec_display_title""         android:layout_width=""58dp""         android:layout_height=""wrap_content""         android:layout_marginStart=""8dp""         android:layout_marginTop=""8dp""         android:text=""@string/display""         app:layout_constraintStart_toStartOf=""parent""         app:layout_constraintTop_toBottomOf=""@+id/text_specification"" />      <TextView         android:id=""@+id/text_spec_display""         android:layout_width=""0dp""         android:layout_height=""wrap_content""         android:layout_marginStart=""8dp""         android:layout_marginTop=""8dp""         android:layout_marginEnd=""8dp""         android:text=""@string/content_specs_display""         app:layout_constraintEnd_toEndOf=""parent""         app:layout_constraintStart_toEndOf=""@+id/guideline""         app:layout_constraintTop_toBottomOf=""@+id/text_specification"" />      <TextView         android:id=""@+id/text_spec_size_title""         android:layout_width=""0dp""         android:layout_height=""wrap_content""         android:layout_marginStart=""8dp""         android:layout_marginTop=""8dp""         android:text=""@string/size""         app:layout_constraintStart_toStartOf=""parent""         app:layout_constraintTop_toBottomOf=""@+id/text_spec_display"" />      <TextView         android:id=""@+id/text_spec_size""         android:layout_width=""0dp""         android:layout_height=""wrap_content""         android:layout_marginStart=""8dp""         android:layout_marginTop=""8dp""         android:layout_marginEnd=""8dp""         android:text=""@string/content_specs_size""         app:layout_constraintEnd_toEndOf=""parent""         app:layout_constraintStart_toEndOf=""@+id/guideline""         app:layout_constraintTop_toBottomOf=""@+id/text_spec_display"" />      <TextView         android:id=""@+id/text_battery_title""         android:layout_width=""0dp""         android:layout_height=""wrap_content""         android:layout_marginStart=""8dp""         android:layout_marginTop=""8dp""         android:text=""@string/battery""         app:layout_constraintStart_toStartOf=""parent""         app:layout_constraintTop_toBottomOf=""@+id/text_spec_size"" />      <TextView         android:id=""@+id/text_battery""         android:layout_width=""0dp""         android:layout_height=""266dp""         android:layout_marginStart=""8dp""         android:layout_marginTop=""8dp""         android:layout_marginEnd=""8dp""         android:text=""@string/content_specs_battery""         app:layout_constraintEnd_toEndOf=""parent""         app:layout_constraintStart_toEndOf=""@+id/guideline""         app:layout_constraintTop_toBottomOf=""@+id/text_spec_size"" />      <androidx.constraintlayout.widget.Guideline         android:id=""@+id/guideline""         android:layout_width=""wrap_content""         android:layout_height=""wrap_content""         android:orientation=""vertical""         app:layout_constraintGuide_begin=""105dp"" />  </androidx.constraintlayout.widget.ConstraintLayout> Sekarang kembali lagi ke  activity_main.xml  dan mari kita masukkan  layout_specification  dengan memanfaatkan  include . Pertama tambahkan  horizontal guidelines  terlebih dahulu. Dan  set  nilainya agar berada di bawah  text_ description , di contoh ini nilainya menjadi  460dp  (Sesuaikan dengan ukuran layar yang Anda pilih). Kemudian tambahkan  constraint  bottom  untuk  text_ description   ke  guidelines  dengan nilai  8 . Kurang lebih seperti ini kodenya: <?xml version=""1.0"" encoding=""utf-8""?> <ScrollView xmlns:android=""http://schemas.android.com/apk/res/android""     xmlns:app=""http://schemas.android.com/apk/res-auto""     xmlns:tools=""http://schemas.android.com/tools""     android:layout_width=""match_parent""     android:layout_height=""match_parent"">      <androidx.constraintlayout.widget.ConstraintLayout         android:layout_width=""match_parent""         android:layout_height=""wrap_content"">          <ImageView ... />          <TextView ... />          <TextView ... />          <TextView ... />          <TextView ... />           <androidx.constraintlayout.widget.Guideline              android:id=""@+id/guideline""             android:layout_width=""wrap_content""             android:layout_height=""wrap_content""             android:orientation=""horizontal""             app:layout_constraintGuide_begin=""460dp"" />       </androidx.constraintlayout.widget.ConstraintLayout> </ScrollView> Sekarang tambahkan  include  layout_specification , buka langsung  tab  text   dan tambahkan kode berikut: <include     layout=""@layout/layout_specification""     android:layout_width=""0dp""     android:layout_height=""wrap_content""     app:layout_constraintBottom_toBottomOf=""parent""     app:layout_constraintEnd_toEndOf=""parent""     app:layout_constraintStart_toStartOf=""parent""     app:layout_constraintTop_toBottomOf=""@id/guideline"" /> Tampilannya akan seperti ini: Hampir selesai. Anda hanya tinggal menambahkan Image View dan Button. Mari kita buat  resource layout  satu lagi dan beri nama  layout_seller . Sesuaikan kode di layout_seller.xml menjadi seperti berikut: <?xml version=""1.0"" encoding=""utf-8""?> <androidx.constraintlayout.widget.ConstraintLayout xmlns:android=""http://schemas.android.com/apk/res/android""     xmlns:app=""http://schemas.android.com/apk/res-auto""     xmlns:tools=""http://schemas.android.com/tools""     android:layout_width=""match_parent""     android:layout_height=""match_parent"">      <TextView         android:id=""@+id/text_seller""         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:text=""@string/seller""         android:textSize=""12sp""         app:layout_constraintTop_toTopOf=""parent"" />      <ImageView         android:id=""@+id/profile_image""         android:layout_width=""56dp""         android:layout_height=""56dp""         android:src=""@drawable/photo_2""         tools:layout_editor_absoluteX=""0dp""         tools:layout_editor_absoluteY=""61dp"" />      <TextView         android:id=""@+id/profile_text""         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:text=""@string/my_name""         android:textColor=""@android:color/black""         tools:layout_editor_absoluteX=""0dp""         tools:layout_editor_absoluteY=""140dp"" />      <Button         android:id=""@+id/button_buy""         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:text=""@string/buy""         tools:layout_editor_absoluteX=""16dp""         tools:layout_editor_absoluteY=""204dp"" /> </androidx.constraintlayout.widget.ConstraintLayout> Kurang lebih tampilannya menjadi seperti ini: Tambahkan constraint untuk tiap View yang ada. Sehingga tampilan menjadi seperti ini: Untuk bagian kodenya, akan menjadi seperti ini: <?xml version=""1.0"" encoding=""utf-8""?> <androidx.constraintlayout.widget.ConstraintLayout xmlns:android=""http://schemas.android.com/apk/res/android""     xmlns:app=""http://schemas.android.com/apk/res-auto""     xmlns:tools=""http://schemas.android.com/tools""     android:layout_width=""match_parent""     android:layout_height=""match_parent"">      <TextView         android:id=""@+id/text_seller""         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:layout_marginStart=""8dp""         android:layout_marginTop=""8dp""         android:layout_marginEnd=""8dp""         android:text=""@string/seller""         android:textSize=""12sp""         app:layout_constraintEnd_toEndOf=""parent""         app:layout_constraintStart_toStartOf=""parent""         app:layout_constraintTop_toTopOf=""parent"" />      <ImageView         android:id=""@+id/profile_image""         android:layout_width=""56dp""         android:layout_height=""56dp""         android:layout_marginStart=""8dp""         android:layout_marginTop=""8dp""         android:src=""@drawable/photo_2""         app:layout_constraintStart_toStartOf=""parent""         app:layout_constraintTop_toBottomOf=""@+id/text_seller"" />      <TextView         android:id=""@+id/profile_text""         android:layout_width=""0dp""         android:layout_height=""wrap_content""         android:layout_marginStart=""8dp""         android:layout_marginEnd=""8dp""         android:text=""@string/my_name""         android:textColor=""@android:color/black""         app:layout_constraintBottom_toBottomOf=""@+id/profile_image""         app:layout_constraintEnd_toEndOf=""parent""         app:layout_constraintStart_toEndOf=""@+id/profile_image""         app:layout_constraintTop_toTopOf=""@+id/profile_image"" />      <Button         android:id=""@+id/button_buy""         android:layout_width=""match_parent""         android:layout_height=""wrap_content""         android:layout_marginStart=""8dp""         android:layout_marginTop=""8dp""         android:layout_marginEnd=""8dp""         android:text=""@string/buy""         app:layout_constraintEnd_toEndOf=""parent""         app:layout_constraintStart_toStartOf=""parent""         app:layout_constraintTop_toBottomOf=""@+id/profile_image"" /> </androidx.constraintlayout.widget.ConstraintLayout> Oke, sekarang tambahkan  layout_seller  ke dalam  activity_main . Sesuaikan  include  baru dan  include sebelumnya yang sudah kita tambahkan. Seperti ini kodenya: <include      android:id=""@+id/include_specifications""      layout=""@layout/layout_specification""     android:layout_width=""0dp""     android:layout_height=""wrap_content""     app:layout_constraintEnd_toEndOf=""parent""     app:layout_constraintStart_toStartOf=""parent""     app:layout_constraintTop_toBottomOf=""@id/guideline"" />   <include     android:id=""@+id/include_seller""     layout=""@layout/layout_seller""     android:layout_width=""0dp""     android:layout_height=""wrap_content""     app:layout_constraintBottom_toBottomOf=""parent""     app:layout_constraintEnd_toEndOf=""parent""     app:layout_constraintStart_toStartOf=""parent""     app:layout_constraintTop_toBottomOf=""@id/ include_specifications "" /> Sehingga,  activity_main.xml  menjadi seperti ini: <?xml version=""1.0"" encoding=""utf-8""?> <ScrollView xmlns:android=""http://schemas.android.com/apk/res/android""     xmlns:app=""http://schemas.android.com/apk/res-auto""     xmlns:tools=""http://schemas.android.com/tools""     android:layout_width=""match_parent""     android:layout_height=""match_parent""     tools:context="".MainActivity"">      <androidx.constraintlayout.widget.ConstraintLayout         android:layout_width=""match_parent""         android:layout_height=""wrap_content"">          <ImageView             android:id=""@+id/image_phone""             android:layout_width=""0dp""             android:layout_height=""wrap_content""             android:adjustViewBounds=""true""             android:scaleType=""fitXY""             app:layout_constraintBottom_toBottomOf=""parent""             app:layout_constraintEnd_toEndOf=""parent""             app:layout_constraintStart_toStartOf=""parent""             app:layout_constraintTop_toTopOf=""parent""             app:layout_constraintVertical_bias=""0.0""             app:srcCompat=""@drawable/pixel_google"" />          <TextView             android:layout_width=""wrap_content""             android:layout_height=""wrap_content""             android:layout_marginStart=""8dp""             android:layout_marginTop=""8dp""             android:layout_marginEnd=""8dp""             android:layout_marginBottom=""8dp""             android:background=""#4D000000""             android:drawableStart=""@drawable/ic_collections_white_18dp""             android:drawableLeft=""@drawable/ic_collections_white_18dp""             android:drawablePadding=""4dp""             android:elevation=""2dp""             android:padding=""8dp""             android:text=""@string/dummy_photos""             android:textAppearance=""@style/TextAppearance.AppCompat.Small""             android:textColor=""@android:color/white""             app:layout_constraintBottom_toBottomOf=""@+id/image_phone""             app:layout_constraintEnd_toEndOf=""parent""             app:layout_constraintHorizontal_bias=""0""             app:layout_constraintStart_toStartOf=""parent""             app:layout_constraintTop_toTopOf=""parent""             app:layout_constraintVertical_bias=""1"" />          <TextView             android:id=""@+id/text_price""             android:layout_width=""0dp""             android:layout_height=""wrap_content""             android:layout_marginTop=""8dp""             android:text=""@string/dummy_value""             android:textColor=""@android:color/black""             android:textSize=""32sp""             app:layout_constraintStart_toStartOf=""@+id/text_stock""             app:layout_constraintTop_toBottomOf=""@+id/image_phone"" />          <TextView             android:id=""@+id/text_stock""             android:layout_width=""match_parent""             android:layout_height=""21dp""             android:layout_marginStart=""8dp""             android:layout_marginTop=""8dp""             android:layout_marginEnd=""8dp""             android:text=""@string/stock""             android:textSize=""12sp""             app:layout_constraintEnd_toEndOf=""parent""             app:layout_constraintStart_toStartOf=""@+id/text_ description ""             app:layout_constraintTop_toBottomOf=""@+id/text_price"" />          <TextView             android:id=""@+id/text_ description ""             android:layout_width=""match_parent""             android:layout_height=""wrap_content""             android:layout_marginStart=""8dp""             android:layout_marginTop=""8dp""             android:layout_marginEnd=""8dp""             android:lineSpacingMultiplier=""1""             android:text=""@string/content_text""             android:textColor=""@android:color/black""             app:layout_constraintEnd_toEndOf=""parent""             app:layout_constraintStart_toStartOf=""parent""             app:layout_constraintTop_toBottomOf=""@+id/text_stock"" />          <androidx.constraintlayout.widget.Guideline             android:id=""@+id/guideline""             android:layout_width=""wrap_content""             android:layout_height=""wrap_content""             android:orientation=""horizontal""             app:layout_constraintGuide_begin=""460dp"" />          <include             android:id=""@+id/include_specifications""             layout=""@layout/layout_specification""             android:layout_width=""0dp""             android:layout_height=""wrap_content""             app:layout_constraintEnd_toEndOf=""parent""             app:layout_constraintStart_toStartOf=""parent""             app:layout_constraintTop_toBottomOf=""@id/guideline"" />          <include             android:id=""@+id/include_seller""             layout=""@layout/layout_seller""             android:layout_width=""0dp""             android:layout_height=""wrap_content""             app:layout_constraintBottom_toBottomOf=""parent""             app:layout_constraintEnd_toEndOf=""parent""             app:layout_constraintStart_toStartOf=""parent""             app:layout_constraintTop_toBottomOf=""@id/include_specifications"" />     </androidx.constraintlayout.widget.ConstraintLayout> </ScrollView> Mari kita jalankan aplikasinya. Seperti ini hasilnya: Bedah Kode Constraint Layout Ketika Anda menggunakan  constraint layout , hasil dari  text editor  menjadikan berkas  layout  tersebut menjadi lebih banyak. Apa pasal? Terdapat beberapa pengaturan tambahan yang berbeda ketika menggunakan View Group lain seperti LinearLayout, RelativeLayout, dll.  Relative Positioning Relative positioning adalah salah satu dasar pembuatan tata letak di constraintlayout. Relative Positioning memungkinkan Anda untuk memposisikan  widget  secara relatif terhadap  widget  yang lain. Anda dapat membatasi  widget  pada sumbu horizontal dan vertikal : Horizontal Axis:  left, right, start and end sides. Vertical Axis:  top, bottom sides and text baseline. Konsep umum dari Constraint Layout adalah membatasi sisi tertentu  widget  ke sisi lain dari  widget  lainnya.  Misal";Latihan ini bertujuan untuk mengembangkan halaman detail menggunakan ConstraintLayout di Android. Anda akan mempelajari cara menambahkan constraint pada komponen, mengatur posisi relatif antar komponen, dan menggunakan guideline untuk membantu desain layout. Dimulai dengan membuat proyek baru di Android Studio dan menyalin sumber daya dari latihan sebelumnya, Anda akan menambahkan elemen seperti ImageView dan TextView, kemudian mengatur constraint untuk memastikan elemen-elemen tersebut terletak dengan benar di layar. Setelah itu, Anda akan menambahkan fitur ScrollView untuk memungkinkan tampilan yang lebih panjang dan menggunakan layout include untuk menyusun tampilan seperti tabel. Dengan memanfaatkan guideline dan alignment, Anda akan dapat menciptakan layout yang rapi dan responsif. Akhirnya, Anda akan menjalankan aplikasi untuk melihat hasilnya, sekaligus memahami dasar-dasar relative positioning yang menjadi inti dari ConstraintLayout.
"Teori Library di Android Sampai sini, Anda sudah bisa membuat sebuah aplikasi yang dapat menampilkan list. Selamat!  Nah , Sekarang Anda akan belajar membuat aplikasi yang sudah dibuat agar menjadi lebih bagus lagi dari segi  user interface  atau tampilannya. Mungkin Anda akan bertanya, “ Bikin  tampilan bagus bukannya susah ya? Katanya perlu pengetahuan tentang  design  dulu?”  Yup,  jawabannya betul! Guna membuat suatu tampilan yang menarik di mata pengguna, Anda perlu menguasai ilmunya terlebih dahulu. Namun, tak tertutup kemungkinan seorang  developer  pemula sekalipun, bisa membuat aplikasi berpenampilan menarik. Salah satu caranya yakni dengan memanfaatkan  library .  Apa itu  library ?  Library  adalah  tools  atau  source code  yang sudah dibuat oleh orang lain (pihak ketiga) dan bisa dipakai di dalam aplikasi Anda. Sebagai contoh Anda ingin membuat ImageView dengan tampilan yang lebih menarik, maka Anda dapat memanfaatkan  library  yang bernama  CircleImageView .  Library  yang dibuat oleh Henning Dodenhof ini mampu membuat bentuk gambar yang tampil menjadi lingkaran seperti gambar di bawah ini: Sebenarnya Anda bisa membuat sendiri, namun proses tersebut akan memerlukan waktu dan pengetahuan yang lebih dalam tentang komponen  shape  yang ada di Android. Sedangkan jika menggunakan  library , Anda cukup memakainya saja tanpa memikirkan bagaimana bentuk itu dibuat. Menyenangkan bukan! Sebenarnya,  library  tidak hanya tersedia untuk  user interface  atau tampilan saja. Masih banyak  library  lainnya yang bisa Anda gunakan di Android, mulai dari  library  untuk  image loader  seperti Glide dan Picasso, mengambil data dari internet seperti LoopJ dan Retrofit, maupun untuk membuat  database  seperti Room dan Realm. Untuk  list  lainnya, silakan lihat di tautan berikut yang merupakan  repository  Github berisi kumpulan  library . Awesome Android Libraries Awesome Android UI Android Arsenal Bahkan ketika membuat  project  baru pun, sebenarnya Anda secara tidak langsung sudah menggunakan  library . Di  build.gradle (Module:app)  pada bagian  dependencies , Anda akan melihat  library-library  dasar yang diperlukan dalam membuat aplikasi Android. Contohnya yaitu  AppCompat  yang merupakan dasar komponen di Android dan  JUnit  yang biasanya digunakan untuk pengujian. Cara Menambahkan Library Lalu bagaimana cara menambahkan  library  baru di proyek yang sedang kita buat? Pertama, tentukan library yang ingin ditambahkan terlebih dahulu. Misal Anda ingin menambahkan  library  CircleImageView. Kedua, cari  library  tersebut dengan mesin pencari dan kemudian Anda akan menjumpai tautan berikut: https://github.com/hdodenhof/CircleImageView .  Ketika Anda sudah berada dalam laman suatu  library , maka biasanya di dalam deskripsi akan dijelaskan perintah/kode yang bisa digunakan untuk mengunduh  library  tersebut. Contohnya untuk CircleImageView terdapat kode yang bentuknya seperti ini: Nomor pada bagian akhir adalah versi  release  terakhir dari  library  tersebut, di sini tertulis ""3.1.0"". Jika tidak dituliskan di bagian deskripsinya, Anda bisa melihat versi yang terbaru di bagian   Releases  seperti ini: Anda akan menjumpai berbagai versi dari library CircleImageView. Selanjutnya,  copy  kode tersebut dan tambahkan ke  build.gradle (module:app)  pada bagian  dependencies   seperti berikut: dependencies {     ...       implementation 'de.hdodenhof:circleimageview:3.1.0'  } Setelah itu, dalam Android Studio akan muncul  warning  di sebelah kanan atas. Android Studio meminta izin kepada Anda untuk melakukan sinkronisasi atau mengunduh library yang telah dimasukkan dengan memilih  Sync Now . Pastikan Laptop/PC yang Anda gunakan terhubung dengan internet ya. Jika sudah, klik tulisan "" Sync Now "" maka proses unduh akan dimulai. Tunggulah sampai selesai. Peringatan ini akan muncul setiap kali Anda mengubah kode yang ada di  build.gradle , baik itu mengubah versi maupun menghapus library. Jadi, pastikan untuk selalu melakukan sinkronisasi saat peringatan ini muncul. Selain menggunakan cara  copy-paste  di atas, Anda juga dapat menambahkan  library  langsung dari dalam Android Studio dengan cara berikut, klik  Build > Edit Libraries and Dependencies . Kemudian Klik icon plus ( + ) dan pilih  Library Dependency . Kemudian cari dengan kata kunci  “circleimageview” . Pilih  de.hdodenhof  dan Klik  OK . Maka otomatis Android Studio akan menambahkan kode di  build.gradle (Module:app)  pada bagian  dependencies  dan juga sekaligus mengunduh  library -nya. Catatan : Cara ini tergolong cepat, tetapi terkadang ada beberapa  library  yang tidak masuk ke dalam sini. Sebenarnya ada satu lagi cara untuk menambahkan  library , yaitu dengan mengunduh berkas berformat  .jar  dari  library  tersebut. Kemudian buat sebuah direktori  /libs  dalam proyek Anda dan salin berkas JAR ke direktori tersebut. Untuk lebih lengkapnya, Anda dapat membaca artikel berikut: How to add libraries Cara Memakai Library Setelah  library  diunduh, bagaimana cara kita memakainya? Biasanya, tiap  library  sudah dijelaskan pula cara penggunaannya pada bagian  readme . Selain itu, ada pula yang dijelaskan melalui  web  official documentation  tersendiri. Misalnya penjelasan  library  CircleImageView ada di  Dokumentasi CircleImageView .  Dari  documentation  tersebut, Anda menjadi tahu cara menggunakan  library  ini, yaitu dengan menambahkan kode berikut ke dalam layout XML. <de.hdodenhof.circleimageview.CircleImageView     xmlns:app=""http://schemas.android.com/apk/res-auto""     android:id=""@+id/profile_image""     android:layout_width=""96dp""     android:layout_height=""96dp""     android:src=""@drawable/profile""     app:civ_border_width=""2dp""     app:civ_border_color=""#FF000000""/> Mantap! Anda sudah mengetahui cara untuk mengunduh dan menggunakan suatu  library . Dengan menggunakan  library  proses pengembangan aplikasi menjadi lebih cepat dan mudah. Namun ingat, jangan berlebihan dalam penggunaan  library.  Setiap  library  yang kita tambahkan akan menambah ukuran dari APK. Oleh karena itu, hapuslah library yang tidak digunakan supaya ukuran APK tetap bisa dijaga.  Selain itu, perhatikan juga pemilihan versi pada suatu  library . Pastikan gunakan versi yang sudah stabil. Menggunakan versi stabil akan memberikan performa yang optimal dan mengurangi munculnya berbagai  bug  yang mungkin terjadi. Contoh versi yang belum stabil atau masih dalam pengembangan biasanya diakhiri dengan  -alpha ,  -beta ,  -rc . Gunakan versi-versi ini jika Anda ingin mencoba fitur terbaru saja. Untuk mendalami materi lebih lanjut, Anda bisa membaca materi pada tautan berikut ini:  Menambahkan Dependensi Build What is Gradle and why do we use it as Android developers? Selanjutnya Anda akan mengimplementasikan ilmu yang dipelajari di modul ini, yaitu dengan menambahkan  library  Glide pada proyek latihan sebelumnya. Semangat!";Teori Library di Android menjelaskan bagaimana cara meningkatkan tampilan aplikasi dengan menggunakan library, yaitu kumpulan kode atau alat yang dibuat oleh pihak ketiga. Library seperti CircleImageView memungkinkan pengembang untuk membuat tampilan ImageView yang lebih menarik tanpa harus memahami detail implementasinya. Selain itu, ada banyak library lain untuk berbagai keperluan, seperti Glide untuk pemuatan gambar dan Retrofit untuk pengambilan data dari internet. Untuk menambahkan library, pengembang dapat mencarinya di repositori seperti GitHub dan menyalin kode ke dalam file build.gradle proyek. Setelah diunduh, library dapat digunakan sesuai petunjuk di dokumentasi resminya. Namun, penting untuk tidak menggunakan terlalu banyak library karena dapat meningkatkan ukuran APK, serta memilih versi yang stabil untuk menghindari bug.
"Latihan Implementasi Library Glide Tujuan Pada codelab kali ini Anda akan belajar menerapkan library  Glide  untuk menampilkan gambar pahlawan dari internet. Sebenarnya ada banyak library yang bisa Anda gunakan, seperti  Picasso ,  Fresco , dan  Coil . Namun, pada latihan ini kita akan menggunakan Glide sebagai contoh. Glide bisa juga digunakan untuk memperkecil ukuran sebelum ditampilkan. Hal ini biasanya digunakan untuk mengatasi eror OutOfMemory ketika memuat gambar yang besar dari lokal. Target Anda adalah menghasilkan  output  seperti di bawah ini: Alur Latihan Berikut alur yang akan kita pelajari dalam latihan ini:  Menambahkan dependencies library di build.gradle. Sinkronisasi project. Menggunakan library.   Codelab Latihan Implementasi Library Glide Ikutilah beberapa instruksi berikut: Bukalah proyek latihan  List   Pahlawan  yang sudah Anda buat sebelumnya atau silahkan unduh di  Latihan RecyclerView . Buka web dari library Glide, yakni  https://github.com/bumptech/glide . Copy  kode dari laman tersebut, kemudian buka   build.gradle (module:app)  dan  paste  kodenya pada bagian dependencies: dependencies {     ...       implementation 'com.github.bumptech.glide:glide:4.12.0'  } Setelah itu klik   Sync Now  untuk mengunduh  library  tersebut. Selain menggunakan cara  copy-paste  di atas, Anda juga dapat menambahkan  library  langsung dari Android Studio dengan cara berikut klik  Build > Edit Libraries and Dependencies . Kemudian Klik  icon plus (+)  dan pilih  Library Dependency . Kemudian cari dengan kata kunci “ glide ”. Pilih  com.github.bumptech.glide  dan Klik  OK . Sehingga secara otomatis Android Studio akan menambahkan kode di  build.gradle (Module:app)  pada bagian  dependencies  dan juga sekaligus mengunduh  library -nya. Selanjutnya bukalah  Strings.xml . Ubahlah kode untuk menampung image berikut: <integer-array name=""data_photo"">     <item>@drawable/ahmad_dahlan</item>     <item>@drawable/ahmad_yani</item>     <item>@drawable/bung_tomo</item>     <item>@drawable/gatot_subroto</item>     <item>@drawable/ki_hadjar_dewantara</item>     <item>@drawable/mohammad_hatta</item>     <item>@drawable/sudirman</item>     <item>@drawable/sukarno</item>     <item>@drawable/supomo</item> </integer-array> Menjadi seperti ini: <string-array name=""data_photo"">     <item>https://upload.wikimedia.org/wikipedia/commons/8/87/Ahmad_Dahlan.jpg</item>     <item>https://upload.wikimedia.org/wikipedia/commons/3/3f/Ahmad_Yani.jpg</item>     <item>https://upload.wikimedia.org/wikipedia/commons/e/ed/Bung_Tomo.jpg</item>     <item>https://upload.wikimedia.org/wikipedia/commons/b/be/Col_Gatot_Subroto%2C_Kenang-Kenangan_Pada_Panglima_Besar_Letnan_Djenderal_Soedirman%2C_p27.jpg</item>     <item>https://upload.wikimedia.org/wikipedia/commons/3/3a/Ki_Hadjar_Dewantara_Mimbar_Umum_18_October_1949_p2.jpg</item>     <item>https://upload.wikimedia.org/wikipedia/commons/thumb/3/3b/VP_Hatta.jpg/330px-VP_Hatta.jpg</item>     <item>https://upload.wikimedia.org/wikipedia/commons/thumb/e/e7/Sudirman.jpg/486px-Sudirman.jpg</item>     <item>https://upload.wikimedia.org/wikipedia/commons/thumb/0/01/Presiden_Sukarno.jpg/330px-Presiden_Sukarno.jpg</item>     <item>https://upload.wikimedia.org/wikipedia/commons/a/a6/Supomo.jpg</item>     <item>https://upload.wikimedia.org/wikipedia/commons/thumb/f/f7/TanMalaka_DariPendjara_ed3.jpg/330px-TanMalaka_DariPendjara_ed3.jpg</item> </string-array> Karena pada array data_photo berubah, yang awalnya integer-array menjadi string-array, maka Anda perlu mengubah tipe data yang ada dalam kelas Hero. Kotlin @Parcelize data class Hero(     var name: String,     var description: String,     var photo:  String  ) : Parcelable Java public class Hero implements Parcelable {     private String name;     private String description;     private  String  photo;      public String getName() {         return name;     }      public void setName(String name) {         this.name = name;     }      public String getDescription() {         return description;     }      public void setDescription(String description) {         this.description = description;     }      public  String  getPhoto() {         return photo;     }      public void setPhoto( String  photo) {         this.photo = photo;     }      @Override     public int describeContents() {         return 0;     }      @Override     public void writeToParcel(Parcel dest, int flags) {         dest.writeString(this.name);         dest.writeString(this.description);         dest. writeString (this.photo);     }      public Hero() {     }      private Hero(Parcel in) {         this.name = in.readString();         this.description = in.readString();         this.photo = in. readString ();     }      public static final Parcelable.Creator<Hero> CREATOR = new Parcelable.Creator<Hero>() {         @Override         public Hero createFromParcel(Parcel source) {             return new Hero(source);         }          @Override         public Hero[] newArray(int size) {             return new Hero[size];         }     }; } Lalu akan ada error di bagian getListHeroes di kelas MainActivity. Ubahlah menjadi seperti ini untuk mengganti array integer menjadi array string. Kotlin private val listHeroes: ArrayList<Hero>     get() {         val dataName = resources.getStringArray(R.array.data_name)         val dataDescription = resources.getStringArray(R.array.data_description)          val dataPhoto = resources.getStringArray(R.array.data_photo)          val listHero = ArrayList<Hero>()         for (i in dataName.indices) {             val hero = Hero(dataName[i], dataDescription[i],  dataPhoto[i] )             listHero.add(hero)         }         return listHero     } Java public ArrayList<Hero> getListHeroes() {     String[] dataName = getResources().getStringArray(R.array.data_name);     String[] dataDescription = getResources().getStringArray(R.array.data_description);      String[] dataPhoto = getResources().getStringArray(R.array.data_photo);       ArrayList<Hero> listHero = new ArrayList<>();     for (int i = 0; i < dataName.length; i++) {         Hero hero = new Hero();         hero.setName(dataName[i]);         hero.setDescription(dataDescription[i]);          hero.setPhoto(dataPhoto[i]);           listHero.add(hero);     }     return listHero; } Jika sudah, silakan masuk ke dalam ListHeroAdapter. Di sana akan ada error di bagian penampil gambar. Mengapa demikian? Karena kita sudah mengganti tipe data image menjadi string. Oleh karena itu kita harus sesuaikan terlebih dahulu. Kotlin override fun onBindViewHolder(holder: ListViewHolder, position: Int) {     val (name, description, photo) = listHero[position]      holder.imgPhoto.setImageResource(photo)      holder.tvName.text = name     holder.tvDescription.text = description     holder.itemView.setOnClickListener {         onItemClickCallback.onItemClicked(listHero[holder.adapterPosition])     } } Java @Override public void onBindViewHolder(@NonNull final ListViewHolder holder, int position) {     Hero hero = listHero.get(position);      holder.imgPhoto.setImageResource(hero.getPhoto());      holder.tvName.setText(hero.getName());     holder.tvDescription.setText(hero.getDescription());      holder.itemView.setOnClickListener(v -> onItemClickCallback.onItemClicked(listHero.get(holder.getAdapterPosition()))); } Karena source gambar saat ini menggunakan alamat url, maka kita bisa memanfaatkan Glide untuk mengatasi itu. gantilah kode error tersebut menjadi seperti ini: Kotlin Glide.with(holder.itemView.context)     .load(photo) // URL Gambar     .into(holder.imgPhoto) // imageView mana yang akan diterapkan Java Glide.with(holder.itemView.getContext())     .load(hero.getPhoto()) // URL Gambar     .into(holder.imgPhoto); // imageView mana yang akan diterapkan Terakhir, karena kita mengambil data dari internet, kita perlu mengaktifkan permission internet terlebih dahulu. Caranya yaitu dengan menambahkan kode berikut pada  manifest/AndroidManifest.xml . <?xml version=""1.0"" encoding=""utf-8""?> <manifest xmlns:android=""http://schemas.android.com/apk/res/android""     package=""com.dicoding.picodiploma.myrecyclerview"">       <uses-permission android:name=""android.permission.INTERNET"" />       <application         ...     </application>  </manifest> Setelah semuanya selesai, jalankanlah aplikasi yang Anda buat. Maka hasilnya akan menjadi seperti ini: Bedah Kode Glide Seperti yang kita tahu, Glide berfungsi untuk memuat gambar. Kita bisa dengan mudah untuk memuat gambar yang datanya berasal dari sebuah URL. Bahkan di dalam Glide, sudah ada berbagai pengaturan yang bisa kita gunakan.  Kotlin Glide.with(holder.itemView.context)     .load(photo) // URL Gambar     .into(holder.imgPhoto) // imageView mana yang akan diterapkan Java Glide.with(holder.itemView.getContext())     .load(hero.getPhoto()) // URL Gambar     .into(holder.imgPhoto); // imageView mana yang akan diterapkan Kode di atas merupakan kode dasar untuk bisa menampilkan gambar dari URL ke dalam sebuah ImageView. Selain itu, Anda bisa menggunakan berbagai fungsi lainnya seperti:  circleCrop() , digunakan untuk membuat gambar menjadi lingkaran. transition , digunakan untuk menambahkan transisi ketika gambar selesai dimuat. thumbnail , digunakan untuk menambahkan thumbnail atau gambar sebelum gambar dimuat. error , digunakan untuk menggantikan gambar yang gagal ketika dimuat. Anda bisa membaca lebih detail tentang Glide pada tautan berikut: Dokumentasi Glide GitHub Glide Source code  latihan ini dapat diunduh di sini: Source Code Latihan Library";Latihan Implementasi Library Glide bertujuan untuk menerapkan library Glide dalam menampilkan gambar pahlawan dari internet. Dalam latihan ini, Anda akan menambahkan dependensi Glide di build.gradle, menyinkronkan proyek, dan menggunakan library tersebut. Pertama, buka proyek latihan List Pahlawan atau unduh dari Latihan RecyclerView. Selanjutnya, tambahkan kode Glide ke dependencies di build.gradle dan sinkronkan. Ubah data gambar di strings.xml dari integer-array menjadi string-array yang berisi URL gambar. Sesuaikan kelas Hero untuk menggunakan String sebagai tipe data foto. Perbarui metode getListHeroes di MainActivity untuk menggunakan array string. Di ListHeroAdapter, ganti penanganan gambar dengan Glide untuk memuat gambar dari URL. Terakhir, aktifkan izin internet di AndroidManifest.xml dan jalankan aplikasi untuk melihat hasilnya. Glide memungkinkan Anda untuk memuat gambar dengan mudah dan menyediakan berbagai opsi pengaturan untuk meningkatkan pengalaman pengguna.
"Cara Membaca Dokumentasi Mantap! Anda telah melalui latihan pertama dalam membuat aplikasi Android. Anda mulai memahami sedikit demi sedikit arti dari setiap kode dengan bantuan bedah kode yang ada di bagian bawah Codelab. Namun, mungkin Anda masih penasaran dari mana bisa mengetahui kegunaan dari kode-kode tersebut. Selain itu,  method  apa saja yang bisa dipakai di komponen tersebut? Misalnya di komponen Button terdapat  method  setOnClickListener. Lalu apa lagi  method  yang lainnya? Jawabannya ada di  Documentation !  Setiap  framework  biasanya memiliki dokumentasi masing-masing. Untuk  framework  Android, Anda bisa melihatnya di  https://developer.android.com/docs . Di sana Anda bisa membaca dokumentasi penggunaan masing-masing komponen, contoh kode, panduan tutorial, dan juga  best practice  dalam pengembangan aplikasi. Sebagai contoh pada aplikasi yang dibuat sebelumnya, Anda menggunakan komponen Button. Dengan menggunakan fitur  search  dan menuliskan  ""Button"" , maka Anda akan menjumpai halaman berikut:  https://developer.android.com/reference/android/widget/Button.html Di dalam halaman tersebut terdapat keterangan bagaimana cara menampilkan Button di layout XML. Kemudian bagaimana cara menambahkan aksi ketika sebuah Button diklik. Ada juga keterangan lainnya, seperti Constructor apa saja yang bisa digunakan untuk membuat Button sendiri (CustomView).  Selain membaca di halaman dokumentasi, Anda juga dapat membaca langsung dokumentasi suatu komponen melalui Android Studio. Caranya yaitu dengan menekan  Ctrl+Q  pada kode yang ingin dilihat dokumentasinya. Hasilnya nanti seperti gambar di bawah ini: Selain dari sisi penggunaan suatu komponen misal Button, Anda juga dapat melihat panduan penggunaan Button dari sisi  User Interface (UI)  di  https://developer.android.com/guide/topics/ui/controls/button . Sudah paham? Jika sudah, Anda juga bisa menerapkan cara yang sama untuk komponen atau kode lainnya. Namun perhatikan bahwa Anda tak perlu membaca semua  documentation  satu per satu untuk mengetahui semua tentang Android. Itu ide yang buruk. Cukup cari yang sedang Anda butuhkan saja ya!";Untuk memahami kegunaan kode dan metode yang tersedia dalam komponen Android, Anda dapat merujuk ke dokumentasi resmi Android di developer.android.com/docs. Di sana, Anda dapat mencari informasi tentang komponen tertentu, seperti Button, dengan menggunakan fitur pencarian. Halaman dokumentasi akan memberikan penjelasan tentang cara penggunaan, contoh kode, dan metode yang dapat digunakan, seperti setOnClickListener. Selain itu, Anda juga bisa mengakses dokumentasi langsung melalui Android Studio dengan menekan Ctrl+Q pada kode yang ingin Anda pelajari. Dengan cara ini, Anda dapat dengan mudah menemukan informasi yang relevan tanpa harus membaca semua dokumentasi secara menyeluruh.
Prasyarat Kemampuan Kelas ini merupakan lanjutan dari kelas sebelumnya di learning path Android Developer Dicoding, yakni  Memulai Pemrograman dengan Kotlin . Idealnya, Anda telah lulus dari kelas tersebut ya. Jika tidak, maka setidaknya Anda harus memiliki bekal pengetahuan dasar tentang bahasa Kotlin yang mendalam seperti:  Memahami tentang teori dasar Kotlin. Dengan mempelajari konsep dasar dari Kotlin seperti menggunakan tipe data, membuat fungsi dasar, menangani tipe data null, dan membuat String Template. Mempelajari perbedaan antara expression dan statement, cara menggunakan enumeration, cara mengontrol aliran program menggunakan ekspresi if dan when, dan bagaimana menerapkan perulangan menggunakan while, do-while, dan break and continue. Mengetahui bagaimana mengelola data di Kotlin dengan menggunakan data class dan collection.  Memahami konsep function programing dengan mempelajari extension, lambda, higher-order function, recursion serta melihat contoh penerapannya pada colletion operator dan scope function. Memahami konsep OOP (Object-Oriented Programming) dengan mempelajari inheritance, abstract class, interface, visibility modifier, dan overloading. Mempelajari Coroutine sebagai solusi untuk menjalankan concurrency pada Kotlin. Sudah siap? Yuk, mari lanjut ke modul selanjutnya!;"Kelas ini merupakan lanjutan dari ""Memulai Pemrograman dengan Kotlin"" di jalur pembelajaran Android Developer Dicoding. Sebelum melanjutkan, Anda sebaiknya memiliki pengetahuan dasar yang kuat tentang Kotlin, termasuk tipe data, fungsi dasar, penanganan null, kontrol aliran program, pengelolaan data dengan data class dan collection, pemrograman fungsional, konsep OOP seperti inheritance dan interface, serta penggunaan Coroutine untuk concurrency. Jika Anda sudah menguasai semua hal ini, Anda siap untuk melanjutkan ke modul berikutnya."
Prasyarat Tools Selain kemampuan prasyarat yang sudah Anda ketahui di materi sebelumnya, kelas ini juga memiliki prasyarat tools yang perlu Anda penuhi terlebih dahulu. Berikut beberapa tools yang bisa Anda gunakan. Komputer/Laptop Komputer/Laptop menjadi tools wajib untuk mengikuti kelas ini. Anda bebas menggunakan sistem operasi apa saja, baik Windows, Linux, atau pun MacOS. Pastikan komputer atau laptop yang Anda gunakan juga terhubung dengan internet. Untuk spesifikasi yang digunakan minimal adalah sebagai berikut: Prosesor : Intel Core i3 (Rekomendasi Core i5 ke atas). RAM : 8 GB atau lebih. Resolusi layar : 1280 x 800 (Rekomendasi Full HD 1920 x 1080). Android Studio Selain komputer/laptop, tools lain yang diperlukan adalah Android Studio. Android Studio merupakan IDE (Integrated Development Environment) berbasis JetBrains Intellij IDEA yang dikhususkan untuk pengembangan software berbasis Android. Kami sarankan Anda menggunakan versi terbaru dari Android Studio. Untuk tata cara instalasi dan penggunaan akan dipelajari di dalam materi.;"Selain kemampuan prasyarat yang telah dijelaskan, kelas ini juga memerlukan beberapa tools yang harus Anda penuhi. Pertama, Anda membutuhkan komputer atau laptop yang terhubung ke internet, dengan spesifikasi minimal berupa prosesor Intel Core i3 (disarankan Core i5 ke atas), RAM 8 GB atau lebih, dan resolusi layar 1280 x 800 (disarankan Full HD 1920 x 1080). Kedua, Anda perlu menginstal Android Studio, yaitu IDE berbasis JetBrains IntelliJ IDEA yang khusus untuk pengembangan aplikasi Android; disarankan untuk menggunakan versi terbaru. Panduan instalasi dan penggunaan Android Studio akan dijelaskan dalam materi kelas."
Rangkuman Pengenalan Android Studio Android Studio  adalah IDE (Integrated Development Environment) berbasis Intellij IDEA yang digunakan khusus untuk membangun aplikasi Android. Bahasa pemrograman yang bisa digunakan untuk mengembangkan aplikasi Android adalah Kotlin dan Java. Namun, yang direkomendasikan dari Google adalah Kotlin. Android Studio memiliki fitur yang lengkap untuk mengembangkan aplikasi seperti berikut.  Template : template memulai project maupun Activity tanpa harus membuatnya dari nol. Intelligent code editor : code completion yang memudahkan untuk menulis kode dengan cepat tanpa harus menuliskan secara lengkap. Selain itu, juga ada warning apabila terdapat kesalahan penulisan kode. Design tool : digunakan untuk mendesain aplikasi beserta melihat preview secara langsung sebelum dijalankan. Flexible build system : Android Studio menggunakan Gradle yang fleksibel untuk menciptakan build variant yang berbeda untuk berbagai device. Anda juga dapat menganalisa prosesnya secara mendetail. Emulator : menjalankan aplikasi tanpa harus menggunakan device Android. Dilengkapi dengan Instant Run untuk melihat perubahan tanpa harus build project dari awal. Debugging : memudahkan untuk mencari tahu masalah. Testing : menjalankan pengujian untuk memastikan semua kode aman sebelum rilis. Publish : membuat berkas AAB/APK dan menganalisanya guna dibagikan dan di-publish ke PlayStore. Integrasi : Terhubung dengan berbagai layanan yang memudahkan untuk mengembangkan aplikasi, seperti Github, Firebase, dan Google Cloud. JRE  (Java Runtime Environment) adalah Virtual Machine untuk menjalankan program Java, sedangkan  JDK  (Java SE Development Kit) merupakan compiler dan tools untuk membuat program. Untuk melihat proses  instalasi Android Studio  secara lebih detail di masing-masing OS, Anda dapat melihatnya pada tautan berikut. https://developer.android.com/studio/install Android SDK  adalah sekumpulan tool yang digunakan untuk mengembangkan aplikasi Android. Berikut adalah beberapa cara untuk membuat project baru pada Android Studio. Ketika pertama kali membuka Android Studio dan muncul window “ Welcome to Android Studio ”, klik “ Start a new Android Studio project .” Jika sudah membuka project lain, klik  File → New → New Project . Package name : digunakan sebagai identifikasi unik dari aplikasi ketika di-publish di PlayStore. Antara satu aplikasi dengan aplikasi lainnya harus berbeda. Biasanya penamaan package menggunakan format domain, tetapi urutannya dibalik. Minimum SDK : digunakan untuk menentukan versi minimum Android yang dapat menjalankan project ini. Anda dapat membuka Help me choose pada saat membuat project untuk melihat distribusi pemakai Android pada setiap versi sehingga bisa menentukan minimum SDK yang cocok. Saat versi baru Android dirilis, developer hendaknya terus mengikuti best-practice terbaru untuk memastikan aplikasi yang dibuat tetap memberikan pengalaman yang terbaik di sebanyak mungkin device. Untuk mencari tahu tentang versi terbaru, Anda dapat melihatnya pada tautan berikut. What is API Level? Berikut adalah  bagian- bagian dari antarmuka Android Studio . Toolbar : merupakan tools yang sering digunakan dalam development, mulai dari copy/paste, build, menjalankan aplikasi, hingga menjalankan emulator. Navigation bar : membantu untuk melihat struktur dari kedalaman (depth) dan posisi proyek yang saat ini sedang dibuka.   Project Explorer dan Editor : bagian utama dari IDE untuk melihat struktur project dan menulis kode Tool Window Bar : menu yang mengelilingi editor ini merupakan button yang dapat di-expand atau menampilkan tools secara detail dan individual. Status Bar : terletak di bagian paling bawah dalam Android Studio, ia berfungsi untuk menampilkan status proyek dan pesan peringatan (warning message) bila ada. AndroidManifest  merupakan file XML yang memberikan beragam informasi penting kepada sistem Android sebelum aplikasi dijalankan. Tag  application  berfungsi untuk mendeskripsikan komponen dasar aplikasi Android, mulai dari activity, services, broadcast receiver, dan content provider. Tag  uses-permission  berfungsi untuk menentukan izin yang harus dimiliki oleh aplikasi untuk mengakses sistem, seperti internet, external storage, contact, lokasi, dan lain sebagainya. Folder  java  dengan folder sesuai nama package digunakan untuk meletakkan berkas source code yang ditulis dalam bahasa Kotlin/Java, termasuk juga source set test untuk Unit Test dan androidTest untuk Instrumentation Test. Folder  res  digunakan untuk mengatur resource di dalam aplikasi seperti berikut. drawable : untuk menyimpan berkas gambar maupun ikon. layout : untuk menyimpan berkas desain aplikasi yang berupa XML. mipmap : untuk menyimpan logo dalam berbagai dimensi. values : berisi berbagai macam sumber data, seperti colors.xml untuk warna, strings.xml untuk teks, dimens.xml untuk ukuran, dan themes.xml untuk membuat theme dan style. Selain itu, juga ada jenis folder resource yang bisa Anda tambahkan seperti yang ada pada tautan berikut. App resources overview Gradle  merupakan open source build automation system. Automation system berguna untuk mengotomatisasi proses pembuatan dari software build dan proses-proses terkait lainnya termasuk compile source code menjadi binary code, packaging binary code, dan menjalankan automated test. Ada dua jenis gradle script yang biasa Anda ubah ketika membangun aplikasi. build.gradle Level Project : merupakan software build tingkat teratas yang meliputi keseluruhan dari proyek dari sebuah aplikasi. Di dalamnya berisi konfigurasi library Android dan Kotlin untuk semua module. build.gradle Level Module : merupakan software build yang ada pada setiap module. Beberapa konfigurasi yang diedit di antaranya adalah android settings, defaultConfig dan productFlavors, buildTypes, dan dependencies. Berikut adalah beberapa detail konfigurasi yang dapat diubah pada gradle script level modul. namespace : package name unik yang digunakan untuk Play Store, sama seperti yang kita atur pada saat membuat project. compileSdk : merupakan versi SDK yang digunakan untuk meng-compile project. applicationId : biasanya sama dengan namespace, nilainya bisa berubah untuk kebutuhan build variant. minSdk : merupakan versi SDK minimal yang didukung oleh project ini. Android dengan versi di bawahnya tidak dapat menjalankan aplikasi ini. targetSdk : target versi SDK yang menandakan aplikasi ini sudah dites pada versi SDK tertentu. Best practice-nya adalah memilih SDK yang terbaru. Jika tidak didefinisikan, nilainya sama dengan minSdk. versionCode : nilai integer yang menandakan versi dari aplikasi. Apabila aplikasi sudah di-publish di PlayStore dengan versionCode 1, kita perlu mengubah versionCode menjadi 2 (incremental satu tingkat) ketika ingin meng-update aplikasinya lagi. Jika tidak diubah, PlayStore akan menolak APK yang di-upload. versionName : versi aplikasi berupa String yang biasa ditunjukkan ke user, misalnya 1.0.1. buildTypes : di dalamnya terdapat properties dari debuggable, ProGuard enabling, debug signing, version name suffix dan test information. dependencies : di dalamnya terdapat informasi tentang library yang digunakan oleh aplikasi. Berikut adalah beberapa shortcut yang sering digunakan pada Android Studio. Shift+Shift : pencarian semua jenis berkas yang masih dalam 1 proyek. Ctrl+Shift+F:  pencarian teks di seluruh berkas proyek. Ctrl+D  : menggandakan bagian yang dipilih. Ctrl+Q  : melihat dokumentasi dengan tampilan minimal. Alt+Enter : melihat solusi pada kode yang error. Ctrl+Alt+L : memformat ulang atau merapikan kode. Shift+F10 : menjalankan aplikasi ke emulator atau devices. Untuk meminimalisir salah ketik (typo) dalam pemanggilan class, method hingga variabel sebaiknya memanfaatkan Code Completion di Android Studio. Terdapat dua jenis code completion yang sering digunakan di Android Studio. Basic Code Completion (Ctrl+Space) : pemanggilan code completion standar untuk membantu kita melengkapi kode. Statement Completion (Ctrl+Shift+Enter) : perintah ini sangat membantu karena kita bisa menyelesaikan kode tanpa harus mengetik lengkap dan tanpa tanda kurung, kurung siku, kurung kurawal, serta banyak macam pemformatan lainnya. Emulator  adalah tool yang menyimulasikan OS Android di dalam komputer. Berikut adalah beberapa alternatif untuk menjalankan project Android. Android Virtual Device (AVD), emulator bawaan dari Android Studio. Emulator ketiga (Memu, Nox, Genymotion, Bluestack, dll). Physical device (perlu mengaktifkan Developer Mode). Berikut adalah langkah-langkah untuk mengaktifkan  Developer Mode pada device. Settings → About Phone →  Tekan Build Number 7 kali. Settings →  Developer Options → Aktifkan USB debugging. Hubungkan device dengan komputer via USB.  Ada dua jenis format yang perlu Anda ketahui untuk memublikasikan aplikasi.  APK  (Android Package): merupakan berkas executable yang bisa langsung dijalankan di dalam OS Android.  AAB  (Android App Bundle): merupakan berkas yang didistribusikan oleh Google Play ke pengguna. Dengan format ini, ukuran aplikasi bisa menjadi jauh lebih kecil karena ia hanya mengunduh bagian (seperti bahasa, arsitektur, dan density) yang diperlukan saja. Dari sisi kredibilitas, ada 2 macam berkas APK/AAB yang dapat Anda buat. Unsigned APK/AAB : merupakan berkas yang digunakan untuk pengujian saja. Signed APK/AAB : merupakan berkas yang digunakan untuk diupload ke PlayStore. Bedanya yaitu memerlukan keystore. Keystore  adalah sebuah berkas biner yang berisi informasi tentang satu atau lebih private key untuk mencegah pemalsuan aplikasi. Berkas penting ini harus dijaga dan disimpan karena dibutuhkan setiap kali membuat Signed AAB untuk meng-update aplikasi.;"Android Studio adalah IDE berbasis IntelliJ IDEA yang khusus digunakan untuk membangun aplikasi Android, dengan dukungan bahasa pemrograman Kotlin dan Java, di mana Kotlin direkomendasikan oleh Google. Fitur-fitur utama Android Studio meliputi template untuk memulai proyek, intelligent code editor dengan auto-completion, design tool untuk mendesain dan melihat preview aplikasi, flexible build system menggunakan Gradle, emulator untuk menjalankan aplikasi tanpa perangkat fisik, serta kemampuan debugging dan testing. Android Studio juga mendukung integrasi dengan berbagai layanan seperti GitHub dan Firebase. Untuk memulai proyek baru, pengguna dapat memilih opsi ""Start a new Android Studio project"" dan mengatur package name serta minimum SDK. Antarmuka Android Studio terdiri dari toolbar, navigation bar, project explorer, dan status bar, serta memanfaatkan file AndroidManifest.xml untuk mendeskripsikan komponen aplikasi dan izin yang diperlukan. Gradle digunakan untuk mengelola build automation dan dependencies, dengan dua level konfigurasi yaitu project dan module."
"Rangkuman Activity Activity  merupakan komponen penting Android yang berfungsi untuk menampilkan user interface ke layar pengguna dan mengelola interaksi yang ada di dalamnya. Setiap Activity harus terdaftar di  AndroidManifest.xml  supaya tidak terjadi error. Lifecycle  merupakan urutan state yang menunjukkan posisi proses aplikasi mulai dari Activity diciptakan sampai dihancurkan. Berikut adalah lifecycle dari sebuah Activity. Anda dapat menambahkan kode pada setiap setiap state lifecycle dengan  override  fungsi yang ada pada Activity. Perhatikan bahwa dalam penulisan kode XML, ada dua cara dalam penulisan tag seperti berikut. Self-closing tag : tag diawali dengan < dan diakhiri dengan />. Biasanya digunakan untuk View tanpa isi. Opening tag  dan  closing tag : opening tag diawali dengan  <  dan diakhiri dengan  >  saja. Sebagai gantinya, ada closing tag dengan format  </NamaView> . Biasanya digunakan untuk layout yang menampung View lain di dalamnya. DI dalam sebuah tag View, Anda bisa mengubah beberapa attribute dengan beberapa format berikut. android:<property_name> =""@+id/view_id""  untuk penulisan id. android:<property_name>=""<property_value>""  untuk attribute biasa. android:<property_name>=""@<resource_type>/resource_id""  untuk attribute yang memanggil value dari folder res, seperti string, color, dan dimens. Penulisan teks secara langsung (hardcoded) merupakan praktik yang kurang baik karena seharusnya kita menuliskan semua teks pada berkas  res/values/strings.xml  dan setelah itu baru memanggilnya. Dalam menentukan tinggi dan lebar suatu View, terdapat beberapa alternatif value yang bisa digunakan seperti berikut. wrap_content : ukuran menyesuaikan dengan ukuran konten di dalamnya. match_parent : ukurang menyesuaikan dengan ukuran parent (View induknya). Apabila di paling luar, berarti mengikuti ukuran layar device-nya. fixed size : Anda bisa menentukan ukuran dengan nilai tetap dengan satuan dp. Berikut beberapa alternatif untuk memberikan jarak antar View. Padding : jarak dari isi ke tepi komponen (dalam). Margin : jarak dari tepi komponen ke komponen lain (luar). Berikut beberapa satuan ukuran yang bisa Anda gunakan dalam mendesain menggunakan XML. sp  (scale independent pixel): digunakan untuk ukuran teks, tetapi diskalakan berdasarkan preferensi ukuran font pengguna. dp  (density independent pixel): digunakan untuk semuanya selain ukuran teks. px : ukuran piksel sebenarnya di layar. Penggunaan px tidak disarankan karena dapat menghasilkan ukuran yang berbeda. onCreate()  merupakan fungsi yang pertama kali dipanggil ketika membuka sebuah Activity. setContentView  digunakan untuk menampilkan XML pada sebuah Activity. findViewById  digunakan untuk menginisialisasi variabel dengan komponen View yang ada di XML sesuai dengan id-nya. setOnClickListener  digunakan untuk melakukan aksi tertentu ketika suatu komponen ditekan. Untuk mengambil suatu teks dari EditText, Anda bisa menggunakan fungsi  getText().toString()  pada Java atau  text.toString  pada Kotlin. Untuk mengatur teks suatu TextView, Anda bisa menggunakan fungsi  setText  pada Java dan   .text  pada Kotlin). onSaveInstanceState  digunakan untuk mempertahankan data ketika terjadi configuration change. Configuration change  terjadi karena perubahan yang signifikan pada aplikasi sehingga akan membuat Activity dihancurkan dan dibuat lagi. Contohnya seperti perubahan orientasi, perubahan bahasa, dan ukuran layar.";Activity adalah komponen utama dalam aplikasi Android yang menampilkan antarmuka pengguna. Setiap Activity harus terdaftar di AndroidManifest.xml. Dalam XML, tag dapat ditulis sebagai self-closing atau opening/closing. Ukuran View diatur dengan wrap_content, match_parent, atau ukuran tetap. Interaksi pengguna dikelola dengan setOnClickListener().
Rangkuman Intent Intent  adalah mekanisme untuk melakukan sebuah action dan komunikasi antar komponen aplikasi misal Activity, Service, dan Broadcast Receiver. Intent  memiliki dua bentuk yaitu: Explicit Intent : digunakan untuk menjalankan komponen lain dengan tujuan yang sudah jelas atau eksplisit. Biasanya digunakan untuk berpindah ke Activity lain pada satu aplikasi.  Implicit Intent : digunakan untuk menjalankan komponen lain dengan tujuan yang belum jelas alias implisit. Biasanya digunakan untuk melakukan aksi tertentu dengan berpindah ke aplikasi lain, misalnya membuka maps, camera, atau foto. Jika ada lebih dari satu aplikasi yang bisa menangani aksi tersebut, opsi aplikasi akan muncul. Contohnya ketika membuka maps, pilihannya bisa menggunakan Google Maps atau Waze. Fungsi  putExtra(key, value)  digunakan untuk menambahkan data di dalam Intent dengan bentuk key-value. Fungsi  intent.getFooExtra(key)  digunakan untuk mengambil data berdasarkan key. Dengan “Foo” adalah tipe data dari dari data yang dikirim. Parcelable  adalah suatu interface yang memungkinkan kita melakukan pengiriman satu objek sekaligus di dalam Intent. Parcelize  adalah plugin yang dapat digunakan untuk membuat implementasi Parcelable secara otomatis. Fungsi  setResult  digunakan untuk mengirimkan nilai balik ke Activity yang memanggilnya. Fungsi  registerForActivityResult  digunakan untuk menerima data yang dikirimkan oleh setResult dari Activity lain. Fungsi ini mengembalikan objek  ActivityResultLauncher  yang digunakan untuk menjalankan Activity lain. Fungsi  finish()  digunakan untuk menutup/menghancurkan Activity dan kembali ke Activity sebelumnya. Debugging  adalah proses untuk mengidentifikasi bug atau masalah yang muncul dan mencari solusinya. Logging  adalah sebuah cara untuk menampilkan data di dalam Logcat. Berguna untuk mendeteksi nilai suatu object atau memverifikasi suatu fungsi.   Debug breakpoint  adalah fitur di dalam Android Studio untuk mendeteksi suatu nilai pada baris kode tertentu ketika aplikasi dijalankan. Error  NullPointerException  muncul dikarenakan memanggil variabel yang masih bernilai null.;Intent adalah mekanisme komunikasi antar komponen aplikasi Android, seperti Activity dan Service, yang terdiri dari dua jenis: Explicit Intent untuk menjalankan komponen dengan tujuan jelas, dan Implicit Intent untuk tujuan tidak jelas, seperti membuka aplikasi lain (misalnya maps). Fungsi putExtra(key, value) digunakan untuk menambahkan data ke dalam Intent, sementara getFooExtra(key) mengambil data tersebut. Debugging membantu menemukan bug dengan logging untuk menampilkan data dan breakpoint untuk mendeteksi nilai saat aplikasi berjalan. Error NullPointerException terjadi saat memanggil variabel yang bernilai null.
"Rangkuman View dan ViewGroup Pada dasarnya, semua elemen UI di aplikasi Android dibangun menggunakan dua buah komponen inti, yaitu View dan ViewGroup. View  merupakan komponen dasar yang tampil di layar dan dapat digunakan untuk berinteraksi dengan pengguna. Contoh komponen turunan dari View adalah TextView, Button, ImageView, RadioButton, Checkbox, dll. ViewGroup  adalah sebuah View spesial yang mewadahi objek-objek View lainnya dan berguna untuk mengatur posisinya. LinearLayout  digunakan untuk menempatkan komponen-komponen di dalamnya secara horizontal atau vertikal. RelativeLayout  digunakan untuk menempatkan masing-masing komponen secara fleksibel dan relatif terhadap komponen yang lainnya. Misalnya komponen A di sebelah kanan komponen B atau komponen A rata tengah dengan parent-nya. FrameLayout  digunakan untuk membuat komponen menjadi menumpuk atau saling menutupi satu dengan yang lainnya. TableLayout  digunakan untuk menyusun komponen dalam baris dan kolom. ConstraintLayout  Merupakan layout default dan direkomendasikan di dalam XML. Dengan ConstraintLayout, Anda dapat menyusun tampilan yang kompleks cukup dengan satu lapis hierarki saja. Hal ini akan memberikan performa dan proses rendering yang lebih baik daripada penggunaan nested layout (layout di dalam layout). Berikut beberapa fiturnya. Relative Positioning : memposisikan komponen secara relatif terhadap komponen yang lain. Center Positioning & Bias : untuk menentukan alignment dengan menggunakan persentase, default-nya 50% atau tengah. Baseline alignment : untuk membuat text pada suatu komponen sejajar dengan teks pada komponen lain. Guideline : untuk membuat garis pembantu yang tidak terlihat oleh user. Barrier : sama seperti Guideline, tetapi posisinya dapat mengikuti komponen lainnya. Chain : mengatur sekumpulan komponen secara linear. Spread : setiap elemen akan menyebar (default style). Spread inside : tampilan pertama dan terakhir akan ditempelkan pada batasan di setiap ujung rantai, sedangkan sisanya akan didistribusikan secara merata. Weighted : jika beberapa widget disetel ke ""match constraint"", mereka akan membagi ruang yang tersedia. Packed : elemen akan menyatu dan dikemas bersama. ScrollView  digunakan untuk membuat komponen di dalamnya dapat digeser (scroll) secara vertikal maupun horizontal. Di dalamnya hanya boleh ada satu layout ViewGroup, tidak boleh lebih. Untuk menambahkan gambar ke  drawable , copy paste gambar dari explorer ke folder drawable. Pilih folder drawable (bukan drawable-v24) untuk mendukung semua versi Android.  Ingat bahwa nama file yang ada di dalam resource drawable harus menggunakan  huruf kecil  dan  underscore  saja. Untuk mengubah  icon aplikasi , klik kanan pada folder res dan pilih  New → Image Asset . Pilih Launcher Icons (Adaptive and Legacy) pada Icon Type, pilih gambar pada Path, lalu klik Next → Finish sehingga, icon akan tersimpan di folder mipmap dengan berbagai density (mdpi, hdpi, xhdpi, xxhdpi, dan xxxhdpi). Layout Inspector  digunakan untuk menganalisis hierarki dan properties pada suatu tampilan.  Penggunaan  Start  dan  End  pada margin daripada Right dan Left berfungsi supaya mendukung dua jenis bahasa, baik Left to Right (LTR) seperti bahasa Inggris maupun Right to Left (RTL) seperti bahasa Arab.";View dan ViewGroup adalah komponen inti dalam UI aplikasi Android. View adalah elemen dasar yang ditampilkan di layar, seperti TextView dan Button, yang memungkinkan interaksi pengguna. ViewGroup adalah jenis View yang menampung dan mengatur posisi objek View lainnya, seperti LinearLayout (horizontal/vertikal), RelativeLayout (posisi fleksibel), FrameLayout (komponen tumpang tindih), TableLayout (baris dan kolom), dan ConstraintLayout (layout default yang efisien). ScrollView memungkinkan komponen digeser, sementara gambar di folder drawable harus menggunakan huruf kecil dan underscore. Ikon aplikasi dapat diubah melalui folder res. Layout Inspector menganalisis hierarki tampilan, dan margin Start dan End mendukung bahasa LTR dan RTL.
Rangkuman Style dan Theme Style  merupakan sebuah kumpulan properti yang dibutuhkan untuk mendefinisikan bagaimana sebuah komponen View ataupun ViewGroup ditampilkan.  Pemusatan style cocok digunakan untuk mengumpulkan atribute yang berulang-ulang digunakan di banyak komponen sehingga jika ada perubahan, cukup ubah di satu tempat saja. Style  terdefinisi dalam file xml sendiri. Anda bisa menemukannya di  res → values → themes.xml .  Semua style yang dibuat harus berada dalam tag resources. Setiap style dibuat menggunakan tag style dan tag item untuk mendefinisikan property-nya. Untuk memanggil style pada XML, gunakan property style = “@style/NamaStyle”. Theme  merupakan sebuah style yang diterapkan khusus untuk Activity dan Application pada berkas AndroidManifest.xml. Dark Theme  dapat mengurangi konsumsi energi pada handphone dan membuat aplikasi lebih mudah dibaca walaupun cahaya sedikit. Material Design  merupakan panduan desain yang dibuat oleh Google untuk membuat user interface dan user experience pada Android. Untuk membuat theme, gunakan tag style dengan parent berupa Theme, seperti “Theme.MaterialComponents.DayNight.DarkActionBar” yang merupakan tema dengan background putih dan action bar berwarna gelap. Beberapa atribut yang dapat dikustomisasi di dalamnya yaitu:   colorPrimary : warna utama aplikasi yang tampil pada Action Bar dan komponen Button. colorPrimaryVariant : variasi dari warna utama yang biasanya digunakan pada Status Bar. colorOnPrimary : warna yang digunakan ketika ada text/icon di atas warna primary. colorSecondary : warna utama sekunder yang tampil pada Action Bar dan komponen EditText. colorSecondaryVariant : variasi dari warna sekunder. colorOnSecondary : warna yang digunakan ketika ada teks/icon di atas warna sekunder. android:statusBarColor : warna yang digunakan untuk status bar. Semua variabel warna sebaiknya dimasukkan di dalam berkas  colors.xml .;Style adalah kumpulan properti yang mendefinisikan tampilan komponen View dan ViewGroup, memungkinkan pengelolaan atribut yang sering digunakan secara efisien. Style didefinisikan dalam file XML di res → values → themes.xml dan harus berada dalam tag resources, menggunakan tag style dan item untuk mendefinisikan properti. Untuk menerapkan style, gunakan property style = “@style/NamaStyle”. Theme adalah style khusus untuk Activity dan Application yang ditentukan di AndroidManifest.xml. Dark Theme mengurangi konsumsi energi dan meningkatkan keterbacaan. Material Design adalah panduan desain dari Google untuk UI/UX Android. Theme dibuat dengan tag style dengan parent seperti “Theme.MaterialComponents.DayNight.DarkActionBar”, dan atribut yang dapat disesuaikan meliputi colorPrimary, colorSecondary, dan android:statusBarColor, dengan semua variabel warna disimpan di colors.xml.
Rangkuman RecyclerView RecyclerView  merupakan komponen yang digunakan untuk menampilkan data dalam jumlah banyak secara dinamis. Dengan RecyclerView, objek yang dibuat hanya sebatas ukuran layar dan beberapa di atas dan di bawahnya saja. Selanjutnya, ia menggunakan kembali item yang sudah tidak terlihat sehingga penggunaan memori menjadi lebih efisien. Berikut adalah beberapa bagian yang perlu Anda ketahui untuk menampilkan data dengan RecyclerView. RecyclerView : merupakan komponen ViewGroup yang perlu ditambahkan ke dalam berkas XML. LayoutManager : digunakan untuk mengatur tata letak item di dalam RecyclerView. Berikut beberapa opsi yang bisa Anda pilih. LinearLayoutManager : tampilan satu kolom secara linear. GridLayoutManager : tampilan lebih dari satu kolom atau grid. StaggeredLayoutManager : tampilan menyesuaikan tinggi setiap item. Data source :   sumber data yang akan ditampilkan ke dalam RecyclerView, biasanya berupa List/ArrayList. Layout item : berkas tampilan XML untuk setiap baris item. RecyclerView.Adapter : class yang digunakan untuk menghubungkan data source dengan RecyclerView. Di dalamnya terdapat beberapa fungsi berikut. onCreateViewHolder() : digunakan untuk membuat ViewHolder baru yang terhubung dengan layout item. onBindViewHolder() : digunakan untuk menetapkan data source ke dalam ViewHolder sesuai dengan posisinya. getItemCount() : digunakan untuk menetapkan ukuran dari jumlah data yang ingin ditampilkan. RecyclerView.ViewHolder : digunakan untuk me-recycle item dan menentukan bagaimana data ditampilkan ke dalam layout Item. Untuk mendapatkan  context  pada  Adapter , gunakan itemView.getContext(). Ada banyak cara untuk menambahkan aksi onClick pada item RecyclerView. Berikut di antaranya. Langsung menambahkan setOnClickListener di dalam adapter. Membuat callback menggunakan interface pada parameter. Menambahkan lambda pada parameter. Library  adalah tools atau source code yang sudah dibuat oleh orang lain (pihak ketiga) dan bisa dipakai di dalam aplikasi Anda.  Setelah menambahkan dependency pada  build.gradle (module:app) , klik  Sync Now  untuk mengunduh library. Untuk menampilkan gambar dari internet, Anda bisa menggunakan library  Glide ,  Picasso ,  Fresco , dan  Coil . View Binding  adalah fitur untuk mengakses semua View yang ada di dalam XML secara otomatis tanpa perlu menggunakan findViewById(). View Binding akan men-generate class baru berdasarkan XML dengan format PascalCaseBinding, misal  activity_main.xml  menjadi  ActivityMainBinding . Setiap id yang ada di dalam XML akan dibuat variabelnya secara otomatis dengan format lowerPascalCase, seperti  tv_welcome  menjadi  tvWelcome . Variabel  rootView  merupakan layout dasar pada sebuah XML dan bisa Anda gunakan dengan method  getRoot() .;RecyclerView adalah komponen untuk menampilkan data dalam jumlah besar secara dinamis dengan efisiensi memori, hanya membuat objek sesuai ukuran layar dan menggunakan kembali item yang tidak terlihat. Komponen utama dalam RecyclerView meliputi: RecyclerView (ViewGroup di XML), LayoutManager (mengatur tata letak item, seperti LinearLayoutManager, GridLayoutManager, dan StaggeredLayoutManager), Data source (List/ArrayList), Layout item (XML untuk setiap item), RecyclerView.Adapter (menghubungkan data dengan RecyclerView melalui metode seperti onCreateViewHolder(), onBindViewHolder(), dan getItemCount()), serta RecyclerView.ViewHolder (me-recycle item dan menampilkan data). Aksi onClick dapat ditambahkan melalui setOnClickListener di adapter, callback interface, atau lambda. Library pihak ketiga seperti Glide, Picasso, dan Fresco dapat digunakan untuk menampilkan gambar dari internet. View Binding memudahkan akses ke View dalam XML tanpa findViewById(), dengan otomatis menghasilkan class dan variabel berdasarkan nama ID XML.
"View Binding View Binding adalah sebuah fitur yang memungkinkan kita untuk binding sebuah properti ke elemen view. Library ini secara otomatis akan memberi akses langsung ke semua view yang ada di dalam XML. Dengan demikian kita tidak perlu secara eksplisit melakukan binding ke elemen view menggunakan findViewByID() atau library lainnya. Cara Mengaktifkan View Binding Secara default View Binding tidak otomatis aktif. Untuk mengaktifkannya, Anda perlu menambahkan kode berikut pada build.gradle di level module yang akan menggunakan View Binding. android {     ...      buildFeatures {         viewBinding true     }  } Setelah project disinkronisasikan, ia akan otomatis membuat kelas yang menampung semua id yang di dalam layout XML. Sebagai contoh Anda memiliki sebuah layout bernama  activity_main.xml  dengan isi sebagai berikut: <LinearLayout ...>    <TextView        android:id=""@+id/ tv_welcome ""        ... /> </LinearLayout> Sehingga, ia akan otomatis ter-generate class dengan nama  ActivityMainBinding  (PascalCase dari activity_main) pada  app\build\generated\data_binding_base_class_source_out\debug\out\com\dicoding\[nama_aplikasi]\databinding  dengan isi seperti berikut: public final class ActivityMainBinding implements ViewBinding {     @NonNull     private final LinearLayout rootView;     @NonNull     public final TextView tvWelcome;     ... } Perhatikan, setiap id yang ada di dalam layout tersebut akan dibuat variabelnya secara otomatis dengan format lowerPascalCase, seperti  tv_welcome  menjadi  tvWelcome . Selain itu untuk layout dasarnya terdapat variabel  rootView  yang bisa Anda gunakan dengan method  getRoot() . Jika Anda ingin sebuah layout tidak di-generate class View Binding-nya, Anda harus menambahkan property berikut pada parent layout-nya. <LinearLayout     ...      tools:viewBindingIgnore=""true""      ... </LinearLayout>   Cara Menggunakan View Binding Untuk menggunakan View Binding Anda perlu membuat object View Binding yang meng- inflate  Activity yang digunakan dan ganti parameter pada setContentView dengan root dari View Binding seperti berikut: Kotlin class MainActivity : AppCompatActivity() {       private lateinit var binding: ActivityMainBinding       override fun onCreate(savedInstanceState: Bundle?) {         super.onCreate(savedInstanceState)          binding = ActivityMainBinding.inflate(layoutInflater)          setContentView( binding.root )     } } Java public class MainActivity extends AppCompatActivity {          private ActivityMainBinding binding;        @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);         binding = ActivityMainBinding.inflate(getLayoutInflater());         setContentView( binding.getRoot() );    } } Sekarang kamu bisa langsung menggunakan id  tv_welcome  yang di dalam  activity_main.xml  seperti berikut: Kotlin binding.tvWelcome.text = ""Hello Dicoding"" Java binding.tvWelcome.setText(""Hello Dicoding""); Dengan ini kamu tidak perlu lagi menggunakan findViewById yang biasanya menyebabkan boilerplate. Selain itu View Binding juga lebih aman karena ia hanya memberikan id yang sesuai dengan layout yang diperlukan saja, tidak seperti findViewById yang bisa mengakses id di semua layout yang menyebabkan null. Selain itu dengan View Binding tipe komponen yang diberikan sudah sesuai, tidak seperti findViewById yang bisa menimbulkan eror karena salah mendefinisikan tipe komponen.   Refactor findViewById dengan View Binding Untuk memahami lebih lanjut silakan menulis ulang (refactor) kode pada project  BarVolume  pada latihan pertama dengan menggunakan View Binding. Selanjutnya ikuti langkah-langkah di bawah ini: Pada MainActivity hapus kode untuk variabel komponen dan findViewById. Kotlin class MainActivity : AppCompatActivity(), View.OnClickListener {   //    hapus kode berikut //    private lateinit var edtWidth: EditText //    private lateinit var edtHeight: EditText //    private lateinit var edtLength: EditText //    private lateinit var btnCalculate: Button //    private lateinit var tvResult: TextView       companion object {         private const val STATE_RESULT = ""state_result""     }      override fun onCreate(savedInstanceState: Bundle?) {         super.onCreate(savedInstanceState)         setContentView(R.layout.activity_main)   //        hapus kode berikut   //        edtWidth = findViewById(R.id.edt_width) //        edtHeight = findViewById(R.id.edt_height) //        edtLength = findViewById(R.id.edt_length) //        btnCalculate = findViewById(R.id.btn_calculate) //        tvResult = findViewById(R.id.tv_result)           ...     } } Java public class MainActivity extends AppCompatActivity {     //    hapus kode berikut //    private EditText edtWidth; //    private EditText edtHeight; //    private EditText edtLength; //    private Button btnCalculate; //    private TextView tvResult;      private static final String STATE_RESULT = ""state_result"";    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);   //        hapus kode berikut //        edtWidth = findViewById(R.id.edt_width); //        edtHeight = findViewById(R.id.edt_height); //        edtLength = findViewById(R.id.edt_length); //        btnCalculate = findViewById(R.id.btn_calculate); //        tvResult = findViewById(R.id.tv_result);          ...    } } Aktifkan View Binding pada build.gradle(module:app) dengan menambahkan kode berikut: android {     ...      buildFeatures {         viewBinding true     }  } Kemudian tambahkan kode untuk menyiapkan View Binding seperti ini: Kotlin class MainActivity : AppCompatActivity(), View.OnClickListener {      companion object {         private const val STATE_RESULT = ""state_result""     }       private lateinit var binding: ActivityMainBinding       override fun onCreate(savedInstanceState: Bundle?) {         super.onCreate(savedInstanceState)          binding = ActivityMainBinding.inflate(layoutInflater)          setContentView( binding.root )        ...    } } Java public class MainActivity extends AppCompatActivity implements View.OnClickListener{    private static final String STATE_RESULT = ""state_result"";      private ActivityMainBinding binding;        @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);         binding = ActivityMainBinding.inflate(getLayoutInflater());         setContentView( binding.getRoot() );        ...    } } Lalu ubah setiap variabel menggunakan binding seperti berikut: Kotlin class MainActivity : AppCompatActivity() {      companion object {         private const val STATE_RESULT = ""state_result""     }      private lateinit var binding: ActivityMainBinding      override fun onCreate(savedInstanceState: Bundle?) {         super.onCreate(savedInstanceState)         binding = ActivityMainBinding.inflate(layoutInflater);         setContentView(binding.root)           binding. btnCalculate.setOnClickListener(this)          if (savedInstanceState != null) {             val result = savedInstanceState.getString(STATE_RESULT)              binding. tvResult.text = result         }     }     ... } Java public class MainActivity extends AppCompatActivity {    private static final String STATE_RESULT = ""state_result"";     private ActivityMainBinding binding;     @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        binding = ActivityMainBinding.inflate(getLayoutInflater());        setContentView(binding.getRoot());          binding. btnCalculate.setOnClickListener(this);        if (savedInstanceState != null) {            String result = savedInstanceState.getString(STATE_RESULT);             binding. tvResult.setText(result);        }    }    ... } Kode di atas hanyalah contoh pada fungsi  onCreate . Silakan lakukan hal yang sama pada komponen yang lainnya. Selesai! Anda dapat melihat bahwa ketika menggunakan findViewById banyak sekali kode yang harus ditulis untuk mem-binding View, mulai dari membuat variabel hingga inisialisasi menggunakan findViewById. Contoh di sini baru 5 komponen. Bayangkan jika terdapat 100 komponen, tentu akan banyak sekali boilerplate code yang perlu Anda tulis, bukan? Namun setelah menggunakan View Binding, kode menjadi lebih bersih dan elegan karena Anda hanya perlu satu variabel untuk mengakses View. Mantap sekali, ya! View Binding pada Adapter Anda sudah mencoba mem-binding layout yang ada di Activity. Lalu bagaimana jika ingin mem-binding item layout yang digunakan di dalam adapter? Sebagai contoh di sini kita akan me- refactor  kode  List HeroAdapter  yang ada pada project  Latihan   RecyclerView   berikut: Pertama, ubah bagian  onCreateViewHolder  dengan  ItemRowHeroBinding  seperti berikut. Kotlin override fun onCreateViewHolder(viewGroup: ViewGroup, i: Int): ListViewHolder {      val binding = ItemRowHeroBinding.inflate(LayoutInflater.from(viewGroup.context), viewGroup, false)      return ListViewHolder( binding ) } Java @NonNull @Override public ListViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int viewType) {      ItemRowHeroBinding binding =  ItemRowHeroBinding.inflate(LayoutInflater.from(viewGroup.getContext()), viewGroup, false);      return new ListViewHolder( binding ); } Pada tahap ini kode tersebut akan mengalami error. Mengapa demikian? Karena sebelumnya yang diminta ListViewHolder adalah  Vi ew , bukan  ItemRowHeroBinding . Oke, mari kita sesuaikan kelas ListViewHolder. Hapus kode yang di dalam kelas  ListViewHolder  yang awalnya seperti ini: Kotlin class ListViewHolder( itemView: View ) : RecyclerView.ViewHolder( itemView ) {  //    Hapus kode di bawah ini: //    var imgPhoto: ImageView = itemView.findViewById(R.id.img_item_photo) //    var tvName: TextView = itemView.findViewById(R.id.tv_item_name) //    var tvDescription: TextView = itemView.findViewById(R.id.tv_item_description)  } Java class ListViewHolder extends RecyclerView.ViewHolder {  //    Hapus kode-kode di bawah ini: //    ImageView imgPhoto; //    TextView tvName, tvDescription;  //    ListViewHolder(View itemView) { //        super(itemView); //        imgPhoto = itemView.findViewById(R.id.img_item_photo); //        tvName = itemView.findViewById(R.id.tv_item_name); //        tvDescription = itemView.findViewById(R.id.tv_item_description); //    }  } Kemudian ubah menjadi seperti ini: Kotlin class ListViewHolder( var binding: ItemRowHeroBinding ) : RecyclerView.ViewHolder( binding.root ) Java class ListViewHolder extends RecyclerView.ViewHolder {      ItemRowHeroBinding binding;       ListViewHolder( ItemRowHeroBinding  binding ) {         super( binding.getRoot() );          this.binding = binding;      } } Konsepnya sama seperti di Activity. Anda dapat membuat variable binding untuk mem- binding  View pada ViewHolder dan langsung menggunakannya. Oleh karena itu, pada bagian  onBindViewHolder  akan menjadi seperti ini: Kotlin override fun onBindViewHolder(holder: ListViewHolder, position: Int) {     val (name, description, photo) = listHero[position]     holder. binding.imgItemPhoto .setImageResource(photo)     holder. binding.tvItemName .text = name     holder. binding.tvItemDescription .text = description     holder.itemView.setOnClickListener {         onItemClickCallback.onItemClicked(listHero[holder.adapterPosition])     } } Java @Override public void onBindViewHolder(@NonNull final ListViewHolder holder, int position) {     Hero hero = listHero.get(position);     holder. binding.imgItemPhoto .setImageResource(hero.getPhoto());     holder. binding.tvItemName. setText(hero.getName());     holder. binding.tvItemDescription. setText(hero.getDescription());      holder.itemView.setOnClickListener(v -> onItemClickCallback.onItemClicked(listHero.get(holder.getAdapterPosition()))); } Mantap! Dengan ini, Anda juga dapat menggunakan view binding pada adapter di latihan RecyclerView.  Perbandingan View Binding dengan Alternatif Lain Sebenarnya selain View Binding, ada juga beberapa alternatif lain yang bisa Anda gunakan untuk mem-binding View, tetapi View Binding merupakan solusi terbaik untuk saat ini. Untuk lebih lengkapnya, silakan lihat tabel berikut ini: Compile Time Safety Elegance Correct Type of View Build Speed Impact Support Kotlin & Java findViewById ❌ ❌ ❌ ✅ ✅ Kotlin Synthetic ❌ ✅ ✅ ✅ ❌ DataBinding ✅ ✅ ✅ ❌ ✅ ViewBinding ✅ ✅ ✅ ✅ ✅  Dapat dilihat ViewBinding memiliki banyak kelebihan daripada alternatif lain, yaitu: Compile Time Safety  : Aman dari eror null yang biasanya disebabkan karena mengambil id dari layout yang berbeda. Elegance  : Kode lebih terlihat bersih dan tidak banyak boilerplate code (kode yang ditulis berulang-ulang). Correct Type of View  : Memberikan tipe komponen yang tepat, berbeda dengan findViewById yang bisa saja salah menentukan tipe komponen. Build Speed  : Kecepatan saat project dijalankan lebih cepat daripada DataBinding. Support Java & Kotlin  : Mendukung kedua bahasa. Berbeda dengan Kotlin Synthetic yang hanya mendukung bahasa Kotlin.   Anda bisa membaca penjelasan lebih lanjut tentang View Binding pada tautan berikut: View Binding Documentation Use view binding to replace findViewById Migrating the deprecated Kotlin Android Extensions compiler plugin";RecyclerView adalah komponen yang memungkinkan tampilan data dalam jumlah besar secara dinamis dan efisien dengan memori, hanya membuat objek sesuai ukuran layar dan menggunakan kembali item yang tidak terlihat. Komponen utama RecyclerView mencakup RecyclerView (ViewGroup di XML), LayoutManager (mengatur tata letak item, seperti LinearLayoutManager, GridLayoutManager, dan StaggeredLayoutManager), Data source (List/ArrayList), Layout item (XML untuk setiap item), RecyclerView.Adapter (menghubungkan data dengan RecyclerView melalui metode seperti onCreateViewHolder(), onBindViewHolder(), dan getItemCount()), serta RecyclerView.ViewHolder (me-recycle item dan menampilkan data). Aksi onClick dapat ditambahkan melalui setOnClickListener di adapter, callback interface, atau lambda. Untuk menampilkan gambar dari internet, Anda dapat menggunakan library pihak ketiga seperti Glide, Picasso, dan Fresco. View Binding juga memudahkan akses ke View dalam XML tanpa menggunakan findViewById(), dengan otomatis menghasilkan class dan variabel berdasarkan nama ID XML.
"Rangkuman Pengenalan Android Studio Android Studio  adalah IDE ( Integrated Development Environment ) berbasis Intellij IDEA yang digunakan khusus untuk membangun aplikasi Android. Bahasa pemrograman yang bisa digunakan untuk mengembangkan aplikasi Android adalah Kotlin dan Java. Namun, yang direkomendasikan dari Google adalah Kotlin. Android Studio memiliki fitur yang lengkap untuk mengembangkan aplikasi seperti berikut.  Template : template memulai project maupun Activity tanpa harus membuatnya dari nol. Intelligent code editor : code completion yang memudahkan untuk menulis kode dengan cepat tanpa harus menuliskan secara lengkap. Selain itu, juga ada warning apabila terdapat kesalahan penulisan kode. Design tool : digunakan untuk mendesain aplikasi beserta melihat preview secara langsung sebelum dijalankan. Flexible build system : Android Studio menggunakan Gradle yang fleksibel untuk menciptakan build variant yang berbeda untuk berbagai device. Anda juga dapat menganalisa prosesnya secara mendetail. Emulator : menjalankan aplikasi tanpa harus menggunakan device Android. Dilengkapi dengan Instant Run untuk melihat perubahan tanpa harus build project dari awal. Debugging : memudahkan untuk mencari tahu masalah. Testing : menjalankan pengujian untuk memastikan semua kode aman sebelum rilis. Publish : membuat berkas AAB/APK dan menganalisanya guna dibagikan dan di- publish  ke PlayStore. Integrasi : Terhubung dengan berbagai layanan yang memudahkan untuk mengembangkan aplikasi, seperti Github, Firebase, dan Google Cloud. JRE  (Java Runtime Environment) adalah Virtual Machine untuk menjalankan program Java, sedangkan  JDK  (Java SE Development Kit) merupakan compiler dan tools untuk membuat program. Untuk melihat proses  instalasi Android Studio secara lebih detail di masing-masing OS, Anda dapat melihatnya pada tautan berikut. https://developer.android.com/studio/install Android SDK  adalah sekumpulan tool yang digunakan untuk mengembangkan aplikasi Android. Berikut adalah beberapa cara untuk membuat project baru pada Android Studio. Ketika pertama kali membuka Android Studio dan muncul window  “Welcome to Android Studio” ,   klik  “Start a new Android Studio project.” Jika sudah membuka project lain, klik  File → New → New Project . Package name : digunakan sebagai identifikasi unik dari aplikasi ketika di-publish di PlayStore. Antara satu aplikasi dengan aplikasi lainnya harus berbeda. Biasanya penamaan package menggunakan format domain, tetapi urutannya dibalik. Minimum SDK : digunakan untuk menentukan versi minimum Android yang dapat menjalankan project ini. Anda dapat membuka  Help me choose  pada saat membuat project untuk melihat distribusi pemakai Android pada setiap versi sehingga bisa menentukan minimum SDK yang cocok. Saat versi baru Android dirilis, developer hendaknya terus mengikuti best-practice terbaru untuk memastikan aplikasi yang dibuat tetap memberikan pengalaman yang terbaik di sebanyak mungkin device. Untuk mencari tahu tentang versi terbaru, Anda dapat melihatnya pada tautan berikut. What is API Level? Berikut adalah bagian-bagian dari  antarmuka Android Studio . Toolbar : merupakan tools yang sering digunakan dalam development, mulai dari copy/paste, build, menjalankan aplikasi, hingga menjalankan emulator. Navigation bar : membantu untuk melihat struktur dari kedalaman ( depth ) dan posisi proyek yang saat ini sedang dibuka.   Project Explorer dan Editor : bagian utama dari IDE untuk melihat struktur project dan menulis kode Tool Window Bar : menu yang mengelilingi editor ini merupakan button yang dapat di-expand atau menampilkan tools secara detail dan individual. Status Bar : terletak di bagian paling bawah dalam Android Studio, ia berfungsi untuk menampilkan status proyek dan pesan peringatan (warning message) bila ada. AndroidManifest  merupakan file XML yang memberikan beragam informasi penting kepada sistem Android sebelum aplikasi dijalankan. Tag  application  berfungsi untuk mendeskripsikan komponen dasar aplikasi Android, mulai dari activity, services, broadcast receiver, dan content provider. Tag  uses-permission  berfungsi untuk menentukan izin yang harus dimiliki oleh aplikasi untuk mengakses sistem, seperti internet, external storage, contact, lokasi, dan lain sebagainya. Folder java  dengan folder sesuai nama package digunakan untuk meletakkan berkas source code yang ditulis dalam bahasa Kotlin/Java, termasuk juga source set test untuk Unit Test dan androidTest untuk Instrumentation Test. Folder res  digunakan untuk mengatur  resource  di dalam aplikasi seperti berikut. drawable : untuk menyimpan berkas gambar maupun ikon. layout : untuk menyimpan berkas desain aplikasi yang berupa XML. mipmap : untuk menyimpan logo dalam berbagai dimensi. values : berisi berbagai macam sumber data, seperti  colors.xml  untuk warna,  strings.xml  untuk teks,  dimens.xml  untuk ukuran, dan  themes.xml  untuk membuat theme dan style. Selain itu, juga ada jenis folder resource yang bisa Anda tambahkan seperti yang ada pada tautan berikut. App resources overview Gradle  merupakan open source build automation system. Automation system berguna untuk mengotomatisasi proses pembuatan dari software build dan proses-proses terkait lainnya termasuk compile source code menjadi binary code, packaging binary code, dan menjalankan automated test. Ada dua jenis gradle script yang biasa Anda ubah ketika membangun aplikasi. build.gradle Level Project : merupakan software build tingkat teratas yang meliputi keseluruhan dari proyek dari sebuah aplikasi. Di dalamnya berisi konfigurasi library Android dan Kotlin untuk semua module. build.gradle Level Module : merupakan software build yang ada pada setiap module. Beberapa konfigurasi yang diedit di antaranya adalah android settings, defaultConfig dan productFlavors, buildTypes, dan dependencies. Berikut adalah beberapa detail konfigurasi yang dapat diubah pada gradle script level modul. namespace : package name unik yang digunakan untuk Play Store, sama seperti yang kita atur pada saat membuat project. compileSdk : merupakan versi SDK yang digunakan untuk meng- compile  project. applicationId : biasanya sama dengan namespace, nilainya bisa berubah untuk kebutuhan build variant. minSdk : merupakan versi SDK minimal yang didukung oleh project ini. Android dengan versi di bawahnya tidak dapat menjalankan aplikasi ini. targetSdk : target versi SDK yang menandakan aplikasi ini sudah dites pada versi SDK tertentu.  Best practice -nya adalah memilih SDK yang terbaru. Jika tidak didefinisikan, nilainya sama dengan minSdk. versionCode : nilai integer yang menandakan versi dari aplikasi. Apabila aplikasi sudah di-publish di PlayStore dengan versionCode 1, kita perlu mengubah versionCode menjadi 2 (incremental satu tingkat) ketika ingin meng-update aplikasinya lagi. Jika tidak diubah, PlayStore akan menolak APK yang di-upload. versionName : versi aplikasi berupa String yang biasa ditunjukkan ke user, misalnya 1.0.1. buildTypes : di dalamnya terdapat properties dari debuggable, ProGuard enabling, debug signing, version name suffix dan test information. dependencies : di dalamnya terdapat informasi tentang library yang digunakan oleh aplikasi. Berikut adalah beberapa shortcut yang sering digunakan pada Android Studio. Shift+Shift : pencarian semua jenis berkas yang masih dalam 1 proyek. Ctrl+Shift+F :   pencarian teks di seluruh berkas proyek. Ctrl+D  : menggandakan bagian yang dipilih. Ctrl+Q  : melihat dokumentasi dengan tampilan minimal. Alt+Enter : melihat solusi pada kode yang error. Ctrl+Alt+L : memformat ulang atau merapikan kode. Shift+F10 : menjalankan aplikasi ke emulator atau devices. Untuk meminimalisir salah ketik (typo) dalam pemanggilan class, method hingga variabel sebaiknya memanfaatkan Code Completion di Android Studio. Terdapat dua jenis code completion yang sering digunakan di Android Studio. Basic Code Completion (Ctrl+Space) : pemanggilan code completion standar untuk membantu kita melengkapi kode. Statement Completion (Ctrl+Shift+Enter) : perintah ini sangat membantu karena kita bisa menyelesaikan kode tanpa harus mengetik lengkap dan tanpa tanda kurung, kurung siku, kurung kurawal, serta banyak macam pemformatan lainnya. Emulator  adalah tool yang menyimulasikan OS Android di dalam komputer. Berikut adalah beberapa alternatif untuk menjalankan project Android. Android Virtual Device (AVD), emulator bawaan dari Android Studio. Emulator ketiga (Memu, Nox, Genymotion, Bluestack, dll). Physical device (perlu mengaktifkan Developer Mode). Berikut adalah langkah-langkah untuk mengaktifkan  Developer Mode pada device. Settings → About Phone →  Tekan Build Number 7 kali. Settings →  Developer Options → Aktifkan USB debugging. Hubungkan device dengan komputer via USB.  Ada dua jenis  format  yang perlu Anda ketahui untuk memublikasikan aplikasi.  APK  (Android Package): merupakan berkas executable yang bisa langsung dijalankan di dalam OS Android.  AAB  (Android App Bundle): merupakan berkas yang didistribusikan oleh Google Play ke pengguna. Dengan format ini, ukuran aplikasi bisa menjadi jauh lebih kecil karena ia hanya mengunduh bagian (seperti bahasa, arsitektur, dan density) yang diperlukan saja. Dari sisi kredibilitas, ada 2 macam berkas APK/AAB yang dapat Anda buat. Unsigned APK/AAB : merupakan berkas yang digunakan untuk pengujian saja. Signed APK/AAB : merupakan berkas yang digunakan untuk diupload ke PlayStore. Bedanya yaitu memerlukan keystore. Keystore  adalah sebuah berkas biner yang berisi informasi tentang satu atau lebih private key untuk mencegah pemalsuan aplikasi. Berkas penting ini harus dijaga dan disimpan karena dibutuhkan setiap kali membuat Signed AAB untuk meng-update aplikasi. Rangkuman Activity Activity  merupakan komponen penting Android yang berfungsi untuk menampilkan user interface ke layar pengguna dan mengelola interaksi yang ada di dalamnya. Setiap Activity harus terdaftar di  AndroidManifest.xml  supaya tidak terjadi error. Lifecycle  merupakan urutan state yang menunjukkan posisi proses aplikasi mulai dari Activity diciptakan sampai dihancurkan. Berikut adalah lifecycle dari sebuah Activity. Anda dapat menambahkan kode pada setiap setiap state lifecycle dengan override fungsi yang ada pada Activity. Perhatikan bahwa dalam penulisan kode XML, ada dua cara dalam penulisan tag seperti berikut. Self-closing tag : tag diawali dengan  <  dan diakhiri dengan  /> . Biasanya digunakan untuk View tanpa isi. Opening tag  dan  closing tag : opening tag diawali dengan  <  dan diakhiri dengan  >  saja. Sebagai gantinya, ada closing tag dengan format  </NamaView> . Biasanya digunakan untuk layout yang menampung View lain di dalamnya. DI dalam sebuah tag View, Anda bisa mengubah beberapa attribute dengan beberapa format berikut. android:<property_name>=""@+id/view_id""  untuk penulisan id. android:<property_name>=""<property_value>""  untuk attribute biasa. android:<property_name>=""@<resource_type>/resource_id""  untuk attribute yang memanggil value dari folder res, seperti string, color, dan dimens. Penulisan teks secara langsung ( hardcoded ) merupakan praktik yang kurang baik karena seharusnya kita menuliskan semua teks pada berkas  res/values/strings.xml  dan setelah itu baru memanggilnya. Dalam menentukan tinggi dan lebar suatu View, terdapat beberapa alternatif value yang bisa digunakan seperti berikut. wrap_content : ukuran menyesuaikan dengan ukuran konten di dalamnya. match_parent : ukurang menyesuaikan dengan ukuran parent (View induknya). Apabila di paling luar, berarti mengikuti ukuran layar device-nya. fixed size : Anda bisa menentukan ukuran dengan nilai tetap dengan satuan dp. Berikut beberapa alternatif untuk memberikan jarak antar View. Padding : jarak dari isi ke tepi komponen (dalam). Margin : jarak dari tepi komponen ke komponen lain (luar). Berikut beberapa satuan ukuran yang bisa Anda gunakan dalam mendesain menggunakan XML. sp  (scale independent pixel): digunakan untuk ukuran teks, tetapi diskalakan berdasarkan preferensi ukuran font pengguna. dp  (density independent pixel): digunakan untuk semuanya selain ukuran teks. px : ukuran piksel sebenarnya di layar. Penggunaan px tidak disarankan karena dapat menghasilkan ukuran yang berbeda. onCreate()  merupakan fungsi yang pertama kali dipanggil ketika membuka sebuah Activity. setContentView  digunakan untuk menampilkan XML pada sebuah Activity. findViewById  digunakan untuk menginisialisasi variabel dengan komponen View yang ada di XML sesuai dengan id-nya. setOnClickListener  digunakan untuk melakukan aksi tertentu ketika suatu komponen ditekan. Untuk mengambil suatu teks dari EditText, Anda bisa menggunakan fungsi  getText().toString()  (text.toString pada Kotlin). Untuk mengatur teks suatu TextView, Anda bisa menggunakan fungsi  setText  (.text pada Kotlin). onSaveInstanceState  digunakan untuk mempertahankan data ketika terjadi configuration change.  Configuration change  terjadi karena perubahan yang signifikan pada aplikasi sehingga akan membuat Activity dihancurkan dan dibuat lagi. Contohnya seperti perubahan orientasi, perubahan bahasa, dan ukuran layar. Rangkuman Intent Intent  adalah mekanisme untuk melakukan sebuah action dan komunikasi antar komponen aplikasi misal Activity, Service, dan Broadcast Receiver. Intent memiliki dua bentuk yaitu: Explicit Intent : digunakan untuk menjalankan komponen lain dengan tujuan yang sudah jelas atau eksplisit. Biasanya digunakan untuk berpindah ke Activity lain pada satu aplikasi.  Implicit Intent : digunakan untuk menjalankan komponen lain dengan tujuan yang belum jelas alias implisit. Biasanya digunakan untuk melakukan aksi tertentu dengan berpindah ke aplikasi lain, misalnya membuka maps, camera, atau foto. Jika ada lebih dari satu aplikasi yang bisa menangani aksi tersebut, opsi aplikasi akan muncul. Contohnya ketika membuka maps, pilihannya bisa menggunakan Google Maps atau Waze. Fungsi  putExtra(key, value)  digunakan untuk menambahkan data di dalam Intent dengan bentuk  key-value . Fungsi  intent.getFooExtra(key)  digunakan untuk mengambil data berdasarkan key. Dengan “Foo” adalah tipe data dari dari data yang dikirim. Parcelable  adalah suatu interface yang memungkinkan kita melakukan pengiriman satu objek sekaligus di dalam Intent. Parcelize  adalah plugin yang dapat digunakan untuk membuat implementasi Parcelable secara otomatis. Fungsi  setResult  digunakan untuk mengirimkan nilai balik ke Activity yang memanggilnya. Fungsi  registerForActivityResult  digunakan untuk menerima data yang dikirimkan oleh setResult dari Activity lain. Fungsi ini mengembalikan objek  ActivityResultLauncher  yang digunakan untuk menjalankan Activity lain. Fungsi  finish()  digunakan untuk menutup/menghancurkan Activity dan kembali ke Activity sebelumnya. Debugging  adalah proses untuk mengidentifikasi bug atau masalah yang muncul dan mencari solusinya. Logging  adalah sebuah cara untuk menampilkan data di dalam Logcat. Berguna untuk mendeteksi nilai suatu object atau memverifikasi suatu fungsi.    Debug breakpoint  adalah fitur di dalam Android Studio untuk mendeteksi suatu nilai pada baris kode tertentu ketika aplikasi dijalankan. Error  NullPointerException  muncul dikarenakan memanggil variabel yang masih bernilai null. Rangkuman View dan ViewGroup Pada dasarnya, semua elemen UI di aplikasi Android dibangun menggunakan dua buah komponen inti, yaitu View dan ViewGroup. View  merupakan komponen dasar yang tampil di layar dan dapat digunakan untuk berinteraksi dengan pengguna. Contoh komponen turunan dari View adalah TextView, Button, ImageView, RadioButton, Checkbox, dll. ViewGroup  adalah sebuah View spesial yang mewadahi objek-objek View lainnya dan berguna untuk mengatur posisinya. LinearLayout  digunakan untuk menempatkan komponen-komponen di dalamnya secara horizontal atau vertikal. RelativeLayout  digunakan untuk menempatkan masing-masing komponen secara fleksibel dan relatif terhadap komponen yang lainnya. Misalnya komponen A di sebelah kanan komponen B atau komponen A rata tengah dengan parent-nya. FrameLayout  digunakan untuk membuat komponen menjadi menumpuk atau saling menutupi satu dengan yang lainnya. TableLayout  digunakan untuk menyusun komponen dalam baris dan kolom. ConstraintLayout  Merupakan layout default dan direkomendasikan di dalam XML. Dengan ConstraintLayout, Anda dapat menyusun tampilan yang kompleks cukup dengan satu lapis hierarki saja. Hal ini akan memberikan performa dan proses rendering yang lebih baik daripada penggunaan nested layout (layout di dalam layout). Berikut beberapa fiturnya. Relative Positioning : memposisikan komponen secara relatif terhadap komponen yang lain. Center Positioning & Bias : untuk menentukan alignment dengan menggunakan persentase, default-nya 50% atau tengah. Baseline alignment : untuk membuat text pada suatu komponen sejajar dengan teks pada komponen lain. Guideline : untuk membuat garis pembantu yang tidak terlihat oleh user. Barrier : sama seperti Guideline, tetapi posisinya dapat mengikuti komponen lainnya. Chain : mengatur sekumpulan komponen secara linear. Spread : setiap elemen akan menyebar (default style). Spread inside : tampilan pertama dan terakhir akan ditempelkan pada batasan di setiap ujung rantai, sedangkan sisanya akan didistribusikan secara merata. Weighted : jika beberapa widget disetel ke ""match constraint"", mereka akan membagi ruang yang tersedia. Packed : elemen akan menyatu dan dikemas bersama. ScrollView  digunakan untuk membuat komponen di dalamnya dapat digeser (scroll) secara vertikal maupun horizontal. Di dalamnya hanya boleh ada satu layout ViewGroup, tidak boleh lebih. Untuk menambahkan gambar ke  drawable , copy paste gambar dari explorer ke folder drawable. Pilih folder drawable (bukan drawable-v24) untuk mendukung semua versi Android.  Ingat bahwa nama file yang ada di dalam resource drawable harus menggunakan  huruf kecil  dan  underscore  saja. Untuk mengubah  icon aplikasi , klik kanan pada folder res dan pilih  New → Image Asset . Pilih Launcher Icons (Adaptive and Legacy) pada Icon Type, pilih gambar pada Path, lalu klik Next → Finish sehingga, icon akan tersimpan di folder mipmap dengan berbagai density (mdpi, hdpi, xhdpi, xxhdpi, dan xxxhdpi). Layout Inspector  digunakan untuk menganalisis hierarki dan properties pada suatu tampilan.  Penggunaan  Start  dan  End  pada margin daripada Right dan Left berfungsi supaya mendukung dua jenis bahasa, baik Left to Right (LTR) seperti bahasa Inggris maupun Right to Left (RTL) seperti bahasa Arab. Rangkuman Style dan Theme Style  merupakan sebuah kumpulan properti yang dibutuhkan untuk mendefinisikan bagaimana sebuah komponen View ataupun ViewGroup ditampilkan.  Pemusatan style cocok digunakan untuk mengumpulkan atribute yang berulang-ulang digunakan di banyak komponen sehingga jika ada perubahan, cukup ubah di satu tempat saja. Style  terdefinisi dalam file xml sendiri. Anda bisa menemukannya di  res → values → themes.xml .  Semua style yang dibuat harus berada dalam tag resources. Setiap style dibuat menggunakan tag style dan tag item untuk mendefinisikan property-nya. Untuk memanggil style pada XML, gunakan property style = “@style/NamaStyle”. Theme  merupakan sebuah style yang diterapkan khusus untuk Activity dan Application pada berkas AndroidManifest.xml. Dark Theme  dapat mengurangi konsumsi energi pada handphone dan membuat aplikasi lebih mudah dibaca walaupun cahaya sedikit. Material Design  merupakan panduan desain yang dibuat oleh Google untuk membuat user interface dan user experience pada Android. Untuk membuat theme, gunakan tag style dengan parent berupa Theme, seperti “Theme.MaterialComponents.DayNight.DarkActionBar” yang merupakan tema dengan background putih dan action bar berwarna gelap. Beberapa atribut yang dapat dikustomisasi di dalamnya yaitu: colorPrimary : warna utama aplikasi yang tampil pada Action Bar dan komponen Button. colorPrimaryVariant : variasi dari warna utama yang biasanya digunakan pada Status Bar. colorOnPrimary : warna yang digunakan ketika ada text/icon di atas warna primary. colorSecondary : warna utama sekunder yang tampil pada Action Bar dan komponen EditText. colorSecondaryVariant : variasi dari warna sekunder. colorOnSecondary : warna yang digunakan ketika ada teks/icon di atas warna sekunder. android:statusBarColor : warna yang digunakan untuk status bar. Semua variabel warna sebaiknya dimasukkan di dalam berkas  colors.xml . Rangkuman RecyclerView RecyclerView  merupakan komponen yang digunakan untuk menampilkan data dalam jumlah banyak secara dinamis. Dengan RecyclerView, objek yang dibuat hanya sebatas ukuran layar dan beberapa di atas dan di bawahnya saja. Selanjutnya, ia menggunakan kembali item yang sudah tidak terlihat sehingga penggunaan memori menjadi lebih efisien. Berikut adalah beberapa bagian yang perlu Anda ketahui untuk menampilkan data dengan RecyclerView. RecyclerView : merupakan komponen ViewGroup yang perlu ditambahkan ke dalam berkas XML. LayoutManager : digunakan untuk mengatur tata letak item di dalam RecyclerView. Berikut beberapa opsi yang bisa Anda pilih. LinearLayoutManager : tampilan satu kolom secara linear. GridLayoutManager : tampilan lebih dari satu kolom atau grid. StaggeredLayoutManager : tampilan menyesuaikan tinggi setiap item. Data source :   sumber data yang akan ditampilkan ke dalam RecyclerView, biasanya berupa List/ArrayList. Layout item : berkas tampilan XML untuk setiap baris item. RecyclerView.Adapter : class yang digunakan untuk menghubungkan data source dengan RecyclerView. Di dalamnya terdapat beberapa fungsi berikut. onCreateViewHolder() : digunakan untuk membuat ViewHolder baru yang terhubung dengan layout item. onBindViewHolder() : digunakan untuk menetapkan data source ke dalam ViewHolder sesuai dengan posisinya. getItemCount() : digunakan untuk menetapkan ukuran dari jumlah data yang ingin ditampilkan. RecyclerView.ViewHolder : digunakan untuk me-recycle item dan menentukan bagaimana data ditampilkan ke dalam layout Item. Untuk mendapatkan  context  pada  Adapter , gunakan itemView.getContext(). Ada banyak cara untuk menambahkan aksi onClick pada item RecyclerView. Berikut di antaranya. Langsung menambahkan setOnClickListener di dalam adapter. Membuat callback menggunakan interface pada parameter. Menambahkan lambda pada parameter. Library  adalah tools atau source code yang sudah dibuat oleh orang lain (pihak ketiga) dan bisa dipakai di dalam aplikasi Anda.  Setelah menambahkan dependency pada  build.gradle (module:app) , klik  Sync Now  untuk mengunduh library. Untuk menampilkan gambar dari internet, Anda bisa menggunakan library  Glide ,  Picasso ,  Fresco , dan  Coil . View Binding  adalah fitur untuk mengakses semua View yang ada di dalam XML secara otomatis tanpa perlu menggunakan findViewById(). View Binding akan men-generate class baru berdasarkan XML dengan format PascalCaseBinding, misal  activity_main.xml  menjadi  ActivityMainBinding . Setiap id yang ada di dalam XML akan dibuat variabelnya secara otomatis dengan format lowerPascalCase, seperti  tv_welcome  menjadi  tvWelcome . Variabel  rootView  merupakan layout dasar pada sebuah XML dan bisa Anda gunakan dengan method  getRoot() .";Android Studio adalah IDE resmi untuk pengembangan aplikasi Android, mendukung Kotlin dan Java dengan fitur lengkap seperti template, intelligent code editor, emulator, dan debugging. Komponen utama meliputi Activity untuk antarmuka, Intent untuk komunikasi, dan View/ViewGroup sebagai elemen dasar. Struktur proyek terdiri dari AndroidManifest, folder resource, dan Gradle build system. Desain antarmuka menggunakan berbagai layout dan komponen, dengan dukungan style dan theme. Fitur lanjutan seperti RecyclerView, View Binding, dan library pihak ketiga memudahkan pengembangan. Publikasi aplikasi dilakukan melalui APK atau AAB dengan memperhatikan proses signing dan keystore.
Modul kelas Memulai Pemrograman Dengan Kotlin dalam bentuk cetak (buku) maupun elektronik sudah didaftarkan ke Dirjen HKI, Kemenkumham RI. Segala bentuk penggandaan dan atau komersialisasi, sebagian atau seluruh bagian, baik cetak maupun elektronik terhadap modul kelas Memulai Pemrograman Dengan Kotlin tanpa izin formal tertulis kepada pemilik hak cipta akan diproses melalui jalur hukum. Hak cipta dilindungi oleh Undang-undang © Dicoding 2017 - 2023. Dengan lanjut ke materi berikutnya,   Anda menyetujui adanya informasi hak cipta di atas terhadap modul dalam kelas ini.;Modul kelas Memulai Pemrograman Dengan Kotlin dalam bentuk cetak (buku) maupun elektronik sudah didaftarkan ke Dirjen HKI, Kemenkumham RI. Segala bentuk penggandaan dan atau komersialisasi, sebagian atau seluruh bagian, baik cetak maupun elektronik terhadap modul kelas Memulai Pemrograman Dengan Kotlin tanpa izin formal tertulis kepada pemilik hak cipta akan diproses melalui jalur hukum. Hak cipta dilindungi oleh Undang-undang © Dicoding 2017 - 2023. Dengan lanjut ke materi berikutnya,   Anda menyetujui adanya informasi hak cipta di atas terhadap modul dalam kelas ini.
Apa itu Kotlin? Pada tahun 2010 lalu  JetBrains  memulai sebuah proyek open-sources baru. Proyek ini merupakan sebuah bahasa pemrograman  statically typed  yang menargetkan  JVM ,  Android ,  JavaScript  dan  Native  [1] .  Kotlin  -nama sebuah pulau di Rusia- menjadi inspirasi oleh tim pengembang untuk ditetapkan sebagai nama bahasa pemrograman tersebut. Mungkin karena pulau tersebut terletak tidak jauh dari markas tim programer JetBrains, yaitu Saint Petersburg, Rusia. Bahasa Kotlin pertama kali dirilis pada bulan Februari 2016 dengan versi 1.0. Saat ini sudah mencapai  versi 1.5.21  per rilis 14 Juli 2021.  Di balik kemajuan pesatnya Kotlin, terdapat pengembang - pengembang hebat dan kreatif dari JetBrains. Kotlin dikembangkan oleh lebih dari 50 developer pimpinan  Andrey Breslav . Mereka semua terinspirasi dari bahasa pemrograman yang sudah ada seperti Java, Scala, JavaScript, C# dan juga Groovy. Apa yang membedakan? Salah satunya, JetBrains memastikan bahwa Kotlin sangat mudah dipelajari. Karena tergolong proyek open-sources, Kotlin dapat bebas kita gunakan secara gratis. Kotlin dikembangkan di bawah lisensi  Apache 2.0  dan kode sumbernya bisa Anda akses di laman  GitHub -nya. Kita pun bisa berkontribusi dengan mengirimkan  pull request  ke repository-nya. Kotlin dapat digunakan untuk berbagai macam pengembangan aplikasi, baik itu server atau backend, website, maupun mobile Android. Bahkan saat ini tengah dikembangkan  Kotlin/Native.  Apa uniknya? Kotlin/Native memungkinkan developer untuk menggunakannya sebagai bahasa pemrograman dalam pengembangan aplikasi di platform lain seperti  embedded system , desktop, macOS, dan iOS. Bahkan tak menutup kemungkinan Kotlin juga bisa digunakan untuk  data science  dan  machine learning . Menarik, bukan? Dukungan  tools  untuk Kotlin , sangat kuat. Kita bisa dengan mudah menggunakan Kotlin pada IDE seperti  IntelliJ IDEA ,  Android Studio ,  Eclipse , dan  NetBeans . Anda pun bisa menggunakan perintah terminal untuk mengkompilasi dan menjalankan Kotlin. Begitu pula untuk  build tools.  Pada JVM kita bisa menggunakan  Gradle ,  Maven ,  Ant , atau  Kobalt . Tersedia juga beberapa  build tools  yang menargetkan JavaScript. Sebagaimana dijelaskan, kita bisa menargetkan Kotlin ke beberapa target. Kotlin akan menghasilkan  bytecode  yang berbeda sesuai dengan targetnya. Ketika menargetkan JVM, Kotlin akan menghasilkan  bytecode  yang kompatibel dengan Java. Kemudian ketika menargetkan JavaScript, Kotlin akan melakukan transpile ke ES5.1 dan menghasilkan kode yang kompatibel dengan sistem sub-modul termasuk AMD dan CommonJS. Sedangkan untuk native, Kotlin akan menghasilkan kode yang spesifik dengan platformnya melalui  LLVM . Pada sub-modul ini kita akan mencoba mengenal Kotlin secara lebih mendalam. Harapannya, sebelum mempelajari komponen-komponen pada Kotlin secara spesifik, kita semua bisa memahami untuk apa saja Kotlin bisa digunakan, apa saja kelebihan dan kekurangannya, karakteristiknya, dan juga seperti apa ekosistem Kotlin di dunia pengembangan aplikasi.;Kotlin adalah bahasa pemrograman modern buatan JetBrains pada 2010, dirancang untuk JVM, Android, JavaScript, dan Native. Bersifat open-source, gratis, dan mudah dipelajari, Kotlin kompatibel dengan berbagai platform dan IDE. Dikembangkan oleh tim developer profesional, bahasa ini terinspirasi dari pulau di Rusia dan mengadaptasi fitur dari bahasa pemrograman populer lainnya. Kotlin memungkinkan pengembangan aplikasi lintas platform, mulai dari backend, website, mobile, hingga sistem tertanam, dengan fokus pada kemudahan dan fleksibilitas.
Apa keunikan Kotlin? Salah satunya, Kotlin merupakan sebuah bahasa pemrograman yang bisa ditargetkan untuk berbagai macam platform ( Multiplatform ) dan juga memiliki beberapa paradigma ( Multiparadigm ). Oleh karena itu, kita perlu tahu apa maksud dari Multiplatform dan Multiparadigm tersebut.  Mari kita bahas satu per satu.  Multiparadigm Mungkin sebagian dari kita masih asing dengan istilah multiparadigm di dunia programing. Programming paradigm adalah sebuah cara untuk mengklasifikasikan bahasa pemrograman berdasarkan fitur yang dimilikinya. Paradigma disini berkaitan dengan bagaimana kode dalam sebuah bahasa pemrograman diatur, seperti mengelompokkan kode atau memodifikasinya. Lebih tepatnya, seperti apa struktur kode bisa diterapkan pada bahasa pemrograman tersebut. Terdapat beberapa paradigma yang umum dimiliki oleh sebuah bahasa pemrograman. Ketika kita ingin mengklasifikasikan bahasa pemrograman berdasarkan cara penulisan sintaksnya, object-oriented programming ( OOP ) dan functional programming ( FP ) merupakan 2 (dua) paradigma yang terkenal di kalangan developer. Dari sisi konstruksi, Kotlin sendiri mencakup keduanya. Anda bisa menggunakan gaya OOP maupun FP, bahkan mencampurnya saat menuliskan sintaks Kotlin. Dengan dukungan tinggi untuk fitur-fitur seperti  higher-order function ,  function types , dan  lambda,  Kotlin adalah pilihan yang tepat untuk Anda mengeksplorasi  functional programming . Hampir semua  General Purpose Language  sekarang sudah mendukung multiparadigm. Untuk lebih jelasnya, mari kita bahas satu per satu kedua paradigma tersebut. Object-oriented Programming Suatu bahasa pemrograman bisa diklasifikasikan ke dalam OOP jika data dan metode yang digunakan untuk memanipulasinya disimpan sebagai satu unit yang bisa disebut dengan objek. OOP memiliki fitur enkapsulasi yang sempurna. Lebih lanjut, satu-satunya cara yang bisa digunakan agar objek atau pengguna lain dapat mengakses suatu data adalah dengan metode objek. Dengan demikian, cara kerja suatu objek dapat diubah tanpa mempengaruhi kode lain yang menggunakan objek tersebut.  Kotlin memberikan dukungan yang luas untuk mengembangkan program berorientasi objek. Di dalam OOP kita akan mengenal beberapa konsep seperti  object ,  classes ,  properties ,  constructor , dll. Dengan OOP kita bisa memecahkan persoalan yang kompleks menjadi set yang lebih kecil dengan membuat objek. Objek tersebut memiliki 2 (dua) karakteristik utama, yaitu  state  (keadaan) dan  behaviour  (perilaku). Kita akan membahas mengenai komponen-komponen OOP pada Kotlin secara lebih mendalam pada sub-modul tersendiri. Sebagai pembuka, mari kita perhatikan contoh berikut: Sepeda motor adalah sebuah objek. Sepeda motor memiliki 2 (dua) roda yang mana bisa kita sebut sebagai states. Sepeda motor bisa melaju, bisa direm, bisa juga berganti gigi. Nah, ketiga hal tersebut bisa kita sebut sebagai behaviour. Kuda adalah sebuah objek. Kuda memiliki nama, warna, dan juga jenis yang mana merupakan states dari Kuda. Kuda bisa berlari, makan, dan lain sebagainya. Inilah yang kita sebut sebagai behaviour. Sebuah objek seperti sepeda motor juga bisa memiliki objek-objek kecil di dalamnya, misalnya roda, rem,  body , mesin dll. Semuanya bisa saling berhubungan dan berinteraksi. Selain itu, OOP juga berdasar pada konsep Message Passing, yakni sebuah tipe komunikasi antara proses dan objek. Itulah gambaran sederhana konsep OOP yang akan kita pelajari. Functional Programming Ada begitu banyak persepsi mengenai  functional programming.  Setiap persepsi tergantung siapa yang mengartikannya. Seorang F-sharp programer akan mengartikan FP sebagai apa yang ada pada F-sharp. Demikian halnya Swift programer akan mengartikan FP sebagai apa yang ada pada Swift. Namun kita bisa menyimpulkan bahwa semua bahasa pemrograman yang mendukung  first-class citizen  termasuk ke dalam FP.  First-class citizen  sendiri merupakan sebuah entitas yang mendukung semua operasi yang umumnya tersedia untuk entitas lain. Sebagai contoh, sebuah fungsi yang bisa dikirimkan sebagai parameter.  Functional programming  merupakan paradigma yang sedang  hype  di kalangan developer saat ini. Paradigma ini memperlakukan komputasi sebagai evaluasi fungsi matematika dan menghindari perubahan keadaan atau  state  dan data yang bisa berubah. Dalam FP, pemrograman dilakukan dengan  expression  atau  declaration . Sehingga sebuah fungsi menghasilkan nilai yang hanya bergantung pada argumen yang diteruskan ke fungsi tersebut. Menghilangkan efek seperti perubahan state yang tidak tergantung pada fungsi input, dapat membuatnya lebih mudah untuk memahami dan memprediksi  behaviour  sebuah program. Inilah tujuan utama dari  functional programming . Masih banyak developer yang langsung membayangkan OOP ketika mendengar kata “Kotlin”. Padahal seperti yang telah disebutkan sebelumnya, Kotlin merupakan  multiparadigm   language . Kotlin memiliki beberapa fitur yang memiliki gaya functional programming, walaupun tidak sepenuhnya functional programming. Mengapa demikian? Sesungguhnya Kotlin adalah sebuah bahasa pemrograman berorientasi objek yang memiliki struktur fungsional. Ini artinya Kotlin juga merupakan sebuah functional programming language. Functional programming juga bertujuan untuk mempermudah kita memahami sebuah kode. Ide dibalik FP adalah menambahkan dan mengurangi hal tertentu untuk membuat kode kita sedikit lebih mudah dipahami. Kotlin memiliki banyak fitur menarik yang membuatnya bisa disebut dengan functional programming seperti higher-order function, function types, extension functions, lambda, dll. Kita akan membahas kembali mengenai functional programming pada Kotlin dan fitur-fitur tersebut pada sub-modul tersendiri. Siap lanjut?;Keunikan Kotlin terletak pada sifatnya sebagai bahasa multiplatform dan multiparadigm. Multiplatform berarti Kotlin dapat digunakan untuk berbagai platform seperti JVM, Android, JavaScript, dan Native. Multiparadigm memungkinkan pengembang menggunakan pendekatan Object-Oriented Programming (OOP) dan Functional Programming (FP) dalam satu bahasa. Kotlin mendukung fitur-fitur canggih seperti higher-order function, lambda, dan extension functions, memungkinkan fleksibilitas tinggi dalam menulis kode yang bersih, ringkas, dan mudah dipahami lintas berbagai konteks pengembangan aplikasi.
"Multiplatform Multiplatform  berarti mendukung lebih dari 1 (satu) platform. Ketika kita membahas tentang aplikasi  multiplatform , bisa dikatakan aplikasi tersebut tersedia pada lebih dari 1 (satu) platform atau bahkan bermacam-macam platform. Platform yang dimaksud misalnya Android, iOS, Web, Desktop, dsb. Kotlin merupakan sebuah  multiplatform programming language.  Kotlin bisa digunakan untuk mengembangkan aplikasi dalam berbagai platform. Namun sebenarnya tujuan dari multiplatform pada Kotlin sendiri tidak sekedar itu. Kotlin memiliki tujuan yang lebih penting, yaitu berbagi kode antar platform. Dengan dukungan untuk  JVM ,  Android ,  JavaScript ,  iOS ,  Linux ,  Windows ,  macOS  dan bahkan  embedded system  seperti  STM32 , Kotlin mampu mengatasi komponen apapun yang terdapat pada aplikasi modern. Banyak developer kira  multiplatform  artinya membuat sebuah proyek dan langsung bisa dijalankan di atas semua platform. Tidak salah, namun tahukah Anda jika model seperti itu memiliki beberapa kekurangan? Sebuah aplikasi modern pasti akan membutuhkan akses ke fitur-fitur tertentu pada platform yang menjalankannya. Misalnya mengakses fitur pada ponsel seperti gyroscope, motion, GPS dan lain sebagainya. Melakukan hal tersebut menggunakan framework multiplatform ( cross platform ) tentunya tak semudah menggunakan bahasa pemrograman khusus untuk platform tertentu ( Native ). Misalnya Android menggunakan Java atau Kotlin dan iOS menggunakan Swift atau Objective-C. Belum lagi ketika membahas masalah performa,  native  pasti jauh lebih unggul dari  cross platform . Kotlin menawarkan konsep  multiplatform  yang sedikit berbeda. Dengan model  code-sharing  yang ada, memungkinkan Anda untuk mengelompokkan beberapa kode sesuai fungsi masing-masing. Sebagai contoh, membuat  modul A  yang berisi kumpulan kode yang dapat diakses oleh semua platform,  modul B  yang berisi kode spesifik untuk platform tertentu, dan  modul C  yang ditargetkan untuk platform tertentu namun juga memiliki ketergantungan ke modul lain. Perhatikan diagram berikut: Kurang lebih seperti itulah gambaran dari modul yang bisa kita buat pada project Kotlin multiplatform. Modul tersebut dapat kita bagi menjadi 3 (tiga) bagian berikut: Common Module Modul ini berisi kode yang tidak spesifik ke platform apa pun. Kita bisa menempatkan komponen-komponen yang bisa digunakan oleh semua modul pada modul ini. Platform Module Pada modul ini kita bisa menambahkan komponen tertentu yang spesifik untuk satu platform. Biasanya modul ini merupakan implementasi dari  common module .  Regular Module Merupakan modul umum yang menargetkan  platform tertentu. Modul ini bisa dependen atau pun menjadi dependensi dari  platform module . Kotlin pun telah menyiapkan beberapa  library  khusus untuk mendukung proyek  multiplatform , di antaranya adalah  HTTP ,  serialization  dan  coroutines . Semua  library  tersebut bisa kita terapkan pada  common module  dan kemudian diakses oleh modul lainnya. Anda pun tetap bisa menggunakan  Kotlin standard library  pada semua modul. Tentunya ini akan sangat membantu memudahkan proses pengembangan aplikasi. Pada akademi ini kita tidak akan mempraktikkan aplikasi Kotlin Multiplatform secara langsung pada sebuah proyek. Melainkan, kita balik ke fokus awal akademi ini yaitu  ""Memulai Pemrograman dengan Kotlin"" . Jika Anda penasaran dengan implementasi Kotlin Multiplatform, Anda bisa mempelajarinya pada tautan berikut: Building Multiplatform Projects with Gradle Multiplatform Project: iOS and Android JetBrains juga memiliki beberapa contoh proyek yang bisa kita pelajari untuk menerapkan Kotlin Multiplatform: KotlinConf App KotlinConf Spinner App Dokumentasi resmi dari Kotlin Multiplatform bisa Anda lihat pada  tautan ini .";Multiplatform pada Kotlin berarti kemampuan berbagi kode lintas platform dengan pendekatan unik. Bukan sekadar membuat aplikasi yang dapat dijalankan di berbagai platform, tetapi memungkinkan pembagian kode cerdas melalui tiga jenis modul: Common Module (kode umum), Platform Module (kode spesifik platform), dan Regular Module (modul umum untuk platform tertentu). Kotlin mendukung platform seperti Android, iOS, Web, Desktop, dengan tujuan utama berbagi kode efisien sambil tetap mempertahankan akses fitur khusus platform dan performa optimal.
Kotlin Untuk Aplikasi Server-side Terdapat berbagai macam aplikasi  server-side , mulai dari aplikasi Web yang menampilkan halaman HTML, Backend yang menghasilkan API untuk aplikasi  mobile , dan juga aplikasi yang lebih kompleks seperti Microservice. Semua aplikasi tersebut bisa dikembangkan menggunakan Kotlin. Selain memungkinkan kita untuk menulis kode yang ringkas dan ekspresif, Kotlin juga mempertahankan kompatibilitas dengan teknologi berbasis Java. Dengan membangun aplikasi  server-side  menggunakan Kotlin, kita akan mendapatkan beberapa manfaat, antara lain: Expressiveness Fitur-fitur pada Kotlin seperti  type-safe builder  dan  delegated properties  akan membantu membangun abstraksi yang kuat dan mudah digunakan. Scalability Dukungan Kotlin untuk coroutines akan membantu kita. Khususnya dalam membangun aplikasi  server-side  dengan skala yang besar, namun menggunakan perangkat yang sederhana. Interoperability Kotlin sepenuhnya kompatibel dengan semua  framework  Java. Ini memungkinkan Anda tetap menggunakan teknologi yang sudah ada dan mulai menggunakan bahasa yang lebih modern. Migration Kotlin mendukung proses migrasi secara bertahap, dari Java ke Kotlin. Anda dapat mulai menulis kode baru dengan Kotlin tanpa memodifikasi kode Java yang sudah ada. Tooling Selain dukungan IDE yang powerful, Kotlin menawarkan beberapa plugin untuk  framework  spesifik seperti  Spring . Tersedia juga berbagai macam framework yang bisa Anda gunakan untuk mempermudah pengembangan aplikasi  server-side  seperti: Spring Spring merupakan sebuah  framework  yang sangat terkenal di Java. Spring bisa digunakan pada Kotlin untuk komunikasi ke API dengan lebih ringkas. Tersedia juga  Spring Initializr  yang memungkinkan kita untuk membuat proyek Spring baru dengan Kotlin. Vert.x Merupakan sebuah  framework  untuk membuat  reactive  Web app di JVM. Anda bisa melihat repository-nya di  https://github.com/vert-x3/vertx-lang-kotlin . Ktor Ktor adalah sebuah  framework  yang dikembangkan oleh JetBrains untuk membuat aplikasi Web di Kotlin. Ktor memanfaatkan coroutine untuk skalabilitas yang tinggi dan menawarkan API yang mudah digunakan. Kotlinx.html Merupakan sebuah DSL yang dapat digunakan untuk membuat HTML di aplikasi Web. Kotlinx.html dapat digunakan sebagai alternatif untuk sistem templating tradisional seperti JSP dan FreeMarker. Exposed Sebuah  framework  SQL yang menyediakan kumpulan DSL yang mudah dibaca untuk menggambarkan struktur database SQL dan melakukan kueri sepenuhnya dengan Kotlin. Jelas terdapat berbagai kemudahan yang ditawarkan dan juga dukungan  framework  yang kuat. Para developer tak perlu ragu lagi dalam mencoba menerapkan Kotlin sebagai bahasa pemrograman untuk mengembangkan aplikasi  server-side . Anda pun bisa mulai mencobanya dengan mengikuti beberapa dokumentasi berikut: Creating Web Applications with Http Servlets Creating a RESTful Web Service with Spring Boot;Kotlin adalah bahasa pemrograman ideal untuk aplikasi server-side, menawarkan expressiveness, scalability, dan interoperabilitas penuh dengan teknologi Java. Didukung framework populer seperti Spring, Vert.x, dan Ktor, Kotlin memungkinkan pengembangan backend yang ringkas dan powerful. Fitur unggulan seperti coroutines, type-safe builder, dan kemudahan migrasi dari Java menjadikan Kotlin pilihan tepat bagi developer yang ingin mengembangkan aplikasi server-side modern dan efisien.
Kotlin Untuk Aplikasi Android Berbeda dengan aplikasi  server-side , aplikasi  mobile  biasanya membutuhkan proses pengembangan yang lebih cepat. Selain itu, dengan begitu banyaknya tipe perangkat  mobile , developer perlu memastikan bahwa aplikasinya dapat berjalan dengan baik pada semua perangkat. Dengan semua fitur yang Kotlin tawarkan, terpenuhilah semua kebutuhan pada pengembangan aplikasi  mobile . Berikut ini adalah beberapa kelebihan mengembangkan aplikasi Android dengan Kotlin: Compatibility Kotlin sepenuhnya kompatibel dengan JDK 6. Ini memastikan bahwa aplikasi yang dibangun dengan Kotlin dapat berjalan pada perangkat Android yang lebih lama tanpa ada masalah. Android Studio pun mendukung penuh pengembangan dengan bahasa Kotlin. Performance Dengan struktur  bytecode  yang sama dengan Java, aplikasi yang dibangun dengan Kotlin dapat berjalan setara dengan aplikasi yang dibangun dengan Java. Terdapat juga fitur seperti  inline function  pada Kotlin yang membuat kode yang dituliskan dengan  lambda  bisa berjalan lebih cepat dibandingkan kode yang sama dan dituliskan dengan Java. Interoperability Anda dapat menggunakan bahasa Kotlin bersamaan dengan bahasa Java, tanpa harus memigrasikan semua kode lama Anda ke Java. Sehingga Anda dapat memanggil kode Java dari Kotlin dan sebaliknya. Inilah alasan yang menyebabkan Kotlin menjadi cepat diterima oleh developer. Compilation Time Kotlin mendukung kompilasi inkremental yang efisien. Oleh karena itu, proses  build  biasanya sama atau lebih cepat dibandingkan dengan Java. Perkembangan Kotlin pada Android pun bisa dibilang sangat cepat. Bahkan pada acara Google I/O 2019 lalu, Google mengumumkan  Kotlin First! , yaitu menetapkan Kotlin sebagai bahasa pemrograman nomor 1 (satu) untuk Android. Hampir semua update pada Android saat ini sudah menggunakan Kotlin pada dokumentasinya. Tim Android juga merilis  Android Jetpack  yang merupakan sekumpulan library yang dapat digunakan untuk memanfaatkan fitur bahasa Kotlin dengan lebih  advanced . Semua dokumentasi juga disediakan dengan sangat jelas dan lengkap pada  https://developer.android.com/kotlin/  atau  https://kotlinlang.org/docs/reference/android-overview.html .;Kotlin menjadi pilihan utama pengembangan aplikasi Android dengan keunggulan kompatibilitas, performa, dan interoperabilitas tinggi. Didukung penuh Android Studio, Kotlin memungkinkan developer menulis kode lebih cepat, efisien, dan kompatibel dengan perangkat lama. Sejak Google I/O 2019 menetapkan Kotlin sebagai bahasa prioritas, pengembangan Android semakin condong menggunakan Kotlin, didukung Android Jetpack dan dokumentasi resmi yang komprehensif.
Kotlin Sebagai Investasi Beberapa pertanyaan yang sering muncul dari developer saat ingin mulai belajar Kotlin adalah  “Apakah  worth it?  Apa saja keunggulannya? Mengapa kita harus mempelajarinya?.”  Senada dengan itu, kali ini kita akan membahas beberapa keuntungan dan juga alasan mengapa kita harus mempelajari Kotlin. Salah satu alasan JetBrains mengembangkan Kotlin adalah karena mereka tak puas dengan Java dan ingin meningkatkan produktivitas mereka. Seorang Java developer yang sudah mempelajari Kotlin, pasti akan membenarkan pernyataan tersebut. Apa pasal? Karena memang benar Java punya kekurangan pada beberapa aspek. Lalu seberapa besar pengaruh Kotlin dalam produktivitas seorang developer? Produktivitas memang menjadi salah satu faktor penting yang menjadi alasan mengapa seorang developer harus mempelajari sebuah bahasa pemrograman. Kotlin memiliki beberapa kelebihan yang dapat meningkatkan produktivitas developer. Berikut beberapa kelebihan tersebut: Ringkas (Concise) Selain mudah dipelajari, bahasa pemrograman baru yang satu ini juga mudah untuk dituliskan. Sintaksisnya pun mudah dibaca dan bisa dibilang lebih  “manusiawi.”  Mungkin karena penamaan fungsi di dalamnya yang mirip dengan bahasa manusia sehari-hari. Kotlin memungkinkan kita untuk mengurangi jumlah penulisan kode  boilerplate . Maka jangan heran jika kita sering mendengar istilah  “ nicer  Java” . Dapat dioperasikan secara bersilangan (Interoperable) Apakah Anda seorang Java developer yang ingin berpindah ke Kotlin? Jangan khawatir, Kotlin dan Java sama-sama berjalan di atas JVM. Alhasil, keduanya bisa dijalankan bersamaan dalam 1 (satu) proyek. Tentunya ini sangat menguntungkan. Kita tidak perlu menuliskan ulang kode Java yang sudah ada. Anda cukup menuliskan kode baru dengan Kotlin. Menariknya, selain bisa dijalankan bersamaan, fungsi yang ada pada kedua bahasa tersebut juga bisa saling diakses. Java bisa mengakses fungsi yang ada pada Kotlin. Sebaliknya, Kotlin juga bisa mengakses fungsi yang ada pada Java. Dukungan tools yang memadai (Tool-friendly) Membahas soal produktivitas, tentu tak jauh dari dukungan  tools  yang diberikan. Saat ini banyak IDE yang mendukung Kotlin. Tersedia juga  https://play.kotlinlang.org/  yang memungkinkan Anda mencoba Kotlin secara online. Kita pun tetap bisa menggunakan  command line  atau terminal. Kita akan mempelajari tentang IDE dan  tools  lainnya pada modul terpisah. Dengan keunggulan-keunggulan Kotlin tersebut, bisa kita simpulkan bahwa Kotlin merupakan bahasa pemrograman yang wajib kita pelajari. Bagi seseorang yang baru mengenal pemrograman, mempelajari Kotlin bisa menjadi investasi yang baik. Dukungan  multiplatform   memungkinkan kita untuk merambah ke berbagai  platform.   Lebih lanjut, konsep  OOP  dan  FP  bisa menjadi modal utama seorang programmer untuk mempelajari bahasa pemrograman lain di kemudian hari.;Kotlin merupakan investasi strategis bagi developer karena menawarkan produktivitas tinggi dengan sintaks ringkas, interoperabilitas penuh dengan Java, dan dukungan multiplatform. Bahasa pemrograman ini memungkinkan pengembangan kode lebih cepat, bersih, dan mudah dibaca. Dengan dukungan tools yang memadai, Kotlin menjadi pilihan ideal bagi developer yang ingin meningkatkan kualitas dan efisiensi pengkodean, serta memiliki potensi untuk mengembangkan aplikasi lintas platform dengan mudah.
"Karakteristik Kotlin Untuk kenal lebih dalam sebuah bahasa pemrograman, tentu kita harus mengetahui karakteristik dari bahasa tersebut. Kotlin adalah bahasa pemrograman yang ringkas, aman, pragmatis dan difokuskan pada interoperabilitas dengan bahasa Java. Kotlin berjalan lancar dengan semua  library  dan  frameworks  Java yang sudah ada. Tentunya Kotlin juga memiliki karakteristik tersendiri yang membuatnya disukai oleh banyak developer. Mari kita bahas bersama beberapa karakteristik tersebut. Modern and Concise Kotlin dikenal dengan bahasa modern yang ringkas untuk dituliskan. Kotlin mampu memangkas berbaris-baris kode menjadi hanya beberapa baris saja. Seperti kita ketahui, programmer menghabiskan banyak waktunya untuk membaca dan menuliskan kode. Ketika kita sedang mengembangkan sebuah aplikasi, hal yang pertama kita lakukan pastinya adalah membaca kode. Baik kode dari sebuah dokumentasi atau pun kode yang sudah ada pada proyek yang sedang dikerjakan. Membaca atau menuliskan kode yang ringkas dan mudah dipahami tentunya menjadi sebuah keuntungan sendiri bagi seorang programmer. Semakin ringkas sebuah kode, maka semakin cepat pula untuk kita pahami. Selain ringkas, faktor lain seperti penamaan fungsi juga akan sangat berpengaruh. Kotlin memiliki fungsi-fungsi bawaan yang namanya mudah diingat. Bahkan pilihan  keyword  yang terkesan sangat sederhana. Mari kita perhatikan perbandingan antara Kotlin dan Java berikut: Java : public class SomeClasses{     public static void main(String[] args){         System.out.println(""Hello"");     } } Kotlin : class SomeClasses{     fun main(){         println(""Hello"")     } } “Hal apa yang pertama kali Anda lihat ketika melihat 2 (dua) kode di atas?”. “Kotlin tidak memerlukan  semicolon  atau tanda titik koma (;)”. Ya benar, itu adalah salah satu ciri dari Kotlin. Sederhana, tapi tak jarang programmer dibuat pusing karena lupa menambahkan  semicolon  di akhir kode ketika ngoding dengan Java. Kode di atas memiliki kegunaan yang sama namun dituliskan dengan bahasa pemrograman yang berbeda. Terlihat dengan sangat jelas bahwa kode yang dituliskan dengan Kotlin lebih ringkas dan lebih mudah dipahami, bukan? Nah, itu belum seberapa. Pada akademi ini Anda akan melihat banyak contoh kode yang menunjukan bahwa Kotlin adalah bahasa yang sangat ringkas. Kotlin juga dibekali dengan beberapa  standard library  seperti  higher-order function ,  extension function , dll yang membuat penulisan kodenya semakin ringkas. Semuanya akan kita pelajari satu per satu pada akademi ini. Pragmatic Sebuah bahasa pemrograman bisa dikatakan pragmatis jika mampu mengatasi masalah dengan praktis. Kotlin dikembangkan berdasarkan permasalahan-permasalahan yang sering dialami oleh programmer di JetBrains. Tanpa mengesampingkan saran dan  feedback  dari komunitas, dalam setiap rilisnya Kotlin selalu memperbarui fitur-fitur yang ada demi solusi praktis bagi programmer. Selain ringkas ditulis, hal lain yang membuat Kotlin bisa dikatakan pragmatis adalah dukungan  tools  yang sangat membantu proses penulisan kode. JetBrains menambahkan dukungan Kotlin pada IntelliJ IDEA beserta plugin-plugin yang disesuaikan dengan setiap fitur yang ada pada Kotlin. Plugin yang ada pun mampu menuntun programmer untuk mempelajari fitur-fitur pada Kotlin. Sebagai contoh, kita bisa mengkonversi kode Java menjadi Kotlin secara otomatis hanya dengan melakukan  copy-paste  kode saja pada berkas Kotlin. Dengan begitu, secara tidak langsung kita bisa belajar seperti apakah jika sebuah kode pada Java dituliskan dengan Kotlin. Contoh lain, IntelliJ IDEA mampu menampilkan peringatan pada sebuah kode yang penulisannya kurang tepat. Tak hanya itu, setiap peringatan selalu disertai dengan saran perbaikan. Tentunya kita akan belajar bagaimana seharusnya sebuah kode dituliskan pada Kotlin. Pada submodul selanjutnya kita juga akan mempelajari secara lebih lengkap bagaimana peran IDE dalam mendukung Kotlin sebagai bahasa yang praktis.";Kotlin merupakan bahasa pemrograman modern yang bercirikan ringkas, pragmatis, dan mudah dibaca. Karakteristik utamanya meliputi penulisan kode yang sederhana, tidak memerlukan semicolon, dukungan standard library canggih, dan tools yang membantu pengembangan. Dirancang oleh JetBrains untuk mengatasi permasalahan programmer, Kotlin menawarkan solusi praktis dengan fitur-fitur inovatif dan dukungan IDE yang memudahkan proses pengkodean, menjadikannya pilihan modern bagi para developer.
"Safe Seperti apakah pengertian  “aman”  dalam sebuah bahasa pemrograman? Apakah  “aman”  artinya kita bisa membuat aplikasi yang tidak mudah dibobol? Tentu tidak. Ketika seorang programer menuliskan banyak kode untuk membangun aplikasi, akan ada saatnya programer tersebut bertemu dengan beberapa masalah. Masalah yang muncul pun bermacam-macam. Mulai dari kode yang eror, proyek tak berhasil di- build , atau bahkan fitur yang tak berfungsi semestinya. Apakah ini yang akan kita bahas? Tidak, kita belum akan membahas masalah-masalah tersebut di sini. Dengan berjalannya Kotlin di atas JVM, keamanan dari sisi memori lebih terjamin. Begitu pun keamanan dari sisi masalah lain yang bersumber dari kesalahan penggunaan memori yang dialokasikan secara dinamis. Di samping itu Kotlin juga menjamin bahwa tingkat keamanan lebih tinggi dibandingkan dengan Java. Misalnya, ketika ingin mendeklarasikan sebuah tipe pada Kotlin, baik tipe data, argumen, ataupun lainnya, Kotlin mampu menyimpulkan tipe tersebut secara otomatis. Sehingga kita tidak perlu menuliskannya secara eksplisit. Tentunya ini akan sangat membantu, karena banyak juga masalah yang disebabkan oleh kesalahan deklarasi tipe tersebut. Lebih dari itu, Kotlin mampu memeriksa kesalahan pada saat kompilasi, sehingga memungkinkan kita untuk mencegah kesalahan tersebut. Yang paling hebat, Kotlin menghilangkan  NullPointerException  yang sering disebut sebagai  “The billion dollar mistake”  oleh programer Java. Kotlin membedakan antara objek yang boleh  null  atau tidak boleh  null  pada saat objek itu dibuat. Tentunya juga menyediakan beberapa solusi untuk penulisannya. Fitur tersebut dikenal dengan  Null Safety . Sebagai contoh, kode berikut: var a : String = ""Kotlin"" a = null  //kompilasi error Secara  default , Kotlin mengasumsikan nilai dari sebuah properti tidak boleh  null . Oleh karena itu, kode pada baris kedua akan langsung dianggap eror. Namun seringkali kita tidak bisa menghindari bahwa sebuah data ternyata  null , apalagi ketika kita mengkonsumsi data yang didapatkan dari server. Kita pun bisa menetapkan sebuah properti  nullable  dengan menambahkan tanda ( ? ) pada tipe datanya.  var a : String? = ""Kotlin"" a = null Properti a sekarang bisa ditetapkan sebagai  nullable , dan untuk mengaksesnya kita perlu menerapkan sebuah mekanisme untuk menghindari kesalahan kompilasi. Terdapat beberapa cara yang bisa dilakukan. Semuanya akan dibahas pada sub-modul terpisah. Statically Typed Seperti yang tertulis  http://kotlinlang.org  dan juga di awal akademi ini, Kotlin termasuk ke dalam bahasa pemrograman  statically typed. A rtinya setiap ekspresi di dalam sebuah program dapat dikenali pada saat kompilasi. Kompiler juga bisa memastikan bahwa semua fungsi yang ingin diakses terdapat pada objek yang digunakan. Hal ini berbeda dengan beberapa bahasa pemrograman lain yang juga berjalan di atas JVM seperti Groovy dan JRuby. Kedua bahasa tersebut termasuk ke dalam bahasa pemrograman  dynamically typed . Di sisi lain, jika dibandingkan dengan Java yang juga merupakan bahasa pemrograman  statically typed , Kotlin memungkinkan kita untuk tidak menuliskan tipe variabel secara eksplisit. Ini akan menghindarkan kita dari kesalahan seperti salah menuliskan tipe data atau yang lainnya. Sebagai contoh: val company = ""dicoding"" Tanpa menuliskan tipe data String secara eksplisit, kompiler secara otomatis akan mengetahui bahwa variabel company merupakan sebuah String. Sebabnya, variabel tersebut diisi dengan nilai String. Tentunya ini juga membuat kode yang dituliskan menjadi lebih ringkas. Fitur tersebut dinamakan dengan  type inference , yaitu sebuah mekanisme yang dijalankan oleh kompiler untuk menyimpulkan tipe dari sebuah context. Selama ini, terdapat banyak perdebatan mengenai  statically typed  atau  dynamically typed  yang bagus dalam hal produktivitas. Tentunya banyak juga perbedaan pendapat dari para developer. Keduanya memiliki keunggulan masing-masing. Berikut adalah beberapa keunggulan dari bahasa pemrograman  statically typed : Mengakses sesuatu akan lebih cepat karena kita tidak perlu mencari tahu fungsi mana yang perlu dipanggil; Karena kompiler menjamin kebenaran program, peluang untuk  crash  saat  runtime  akan berkurang; S tatically typed  memungkinkan proses  refactoring  yang lebih mudah, apalagi dengan dukungan  tool  yang hebat seperti  auto complete  dan yang lainnya; Lebih mudah untuk bekerja dengan relasional database dan sistem lain yang juga bergantung pada  statically typed . Selain itu, Kotlin juga mendukung  function type , yang nanti akan kita pelajari pada sub-modul  functional programming . Free and Open-Sources Bagi pegiat  open-sources  dan developer pada umumnya, hal ini tentunya sangat menguntungkan. Kompiler,  library ,  tools , dan terutama Kotlin itu sendiri bebas untuk diakses gratis. Seperti yang sudah disebutkan di awal akademi, Kotlin mempunyai lisensi  Apache 2.0 . Anda pun bisa memantau atau berkontribusi untuk pengembangan Kotlin pada repo-nya di  https://github.com/jetbrains/kotlin . Beberapa IDE yang bisa Anda gunakan seperti IntelliJ IDEA, Android Studio dan Eclipse juga termasuk ke dalam  open-sources software . Saat ini sudah terdapat ratusan developer yang berkontribusi dengan ribuan  commit -nya pada pengembangan Kotlin. Jika Anda tertarik untuk berkontribusi, tersedia juga panduan yang lengkap pada  tautan ini . Semakin banyak kontribusi dari developer-developer hebat, tentunya Kotlin akan menjadi kian  powerful .";Kotlin adalah bahasa pemrograman modern yang menawarkan keamanan, produktivitas, dan kemudahan pengembangan. Dirancang di atas JVM, Kotlin memiliki fitur null safety yang mencegah NullPointerException, dukungan statically typed dengan type inference, dan sintaks ringkas. Sebagai bahasa open-source dengan lisensi Apache 2.0, Kotlin memungkinkan pengembang menulis kode lebih bersih, aman, dan efisien dibandingkan Java, menjadikannya pilihan strategis untuk pengembangan aplikasi lintas platform.
Ekosistem Kotlin Berbicara mengenai ekosistem, di Indonesia sendiri Kotlin mulai ramai digunakan sejak tahun 2017. Pada tahun itu juga Kotlin ditetapkan sebagai bahasa pemrograman resmi pada salah satu platform yang juga sangat terkenal, yaitu Android. Walaupun sebenarnya sebelum tahun 2017 juga ada developer yang sudah mulai menuliskan kodenya dengan Kotlin. Selain dikenal sebagai bahasa pemrograman yang ringkas dan praktis, dukungan multiplatform pada Kotlin mampu membuat Kotlin mudah diterima di berbagai kalangan developer. Untuk developer yang mempunyai latar belakang sebagai programer Java, C#, JavaScripts, Scala, maupun Groovy, mereka akan bisa mudah beradaptasi dengan Kotlin, karena Kotlin memang terinspirasi dari beberapa bahasa pemrograman tersebut. Beberapa perusahaan besar seperti  Square ,  Pinterest ,  Basecamp  dan  Corda  pun sudah menggunakan Kotlin dan dengan bangga mengumumkannya secara publik. Sejak diumumkannya Kotlin sebagai bahasa pemrograman untuk Android pada Google I/O 2017, tak sedikit developer Android yang mencoba untuk mempelajari Kotlin. Apalagi di tahun 2019 ini semua update terbaru pada Android selalu menggunakan Kotlin pada dokumentasinya. Tentu saja banyak developer Android yang juga sudah beralih dari Java ke Kotlin. Sepertinya pengumuman dari Google tersebut sangat berpengaruh terhadap animo developer Android dalam menggunakan Kotlin. Bahkan sampai ada yang mengira bahwa Google-lah yang mengembangkan Kotlin. Tak hanya di luar negeri, di Indonesia pun Kotlin dikenal sangat melekat dengan Android. Ini ditunjukkan dengan banyaknya developer yang berdiskusi di komunitas online maupun offline mayoritas adalah developer Android. Antusiasme developer Android di Indonesia untuk belajar Kotlin sangatlah besar.  Saat ini, banyak aplikasi yang dikembangkan dengan Kotlin. Mulai dari startup yang baru mulai dirintis sampai perusahaan yang sudah memiliki title  Unicorn  seperti GO-JEK, Tokopedia, dan Bukalapak. https://developer.android.com/kotlin Selanjutnya, hal yang juga sangat berpengaruh pada perkembangan ekosistem Kotlin adalah Komunitas. Baik di luar negeri atau pun di Indonesia, setiap harinya komunitas online selalu ramai dengan diskusi-diskusi seputar Kotlin. Tak jarang juga komunitas yang mengadakan acara offline secara rutin. Ini pertanda komunitas Kotlin, sangat kuat. Dengan banyaknya developer expert yang peduli membagikan ilmunya, akan mempermudah teman-teman developer yang baru untuk mulai belajar Kotlin. Berikut adalah beberapa kanal komunitas yang bisa Anda ikuti untuk mendapatkan update rutin seputar Kotlin: Kotlin Indonesia Kotlinlang Antonioleiva.com  Kotlin Weekly Kotlin.link The Daily Kotlin Talking Kotlin Banyaknya komunitas yang berkontribusi untuk Kotlin membuat bahasa tersebut berkembang sangat pesat. Kotlin dinobatkan sebagai “ Fastest growing languages ” oleh  GitHub Octoverse 2018  mengalahkan Rust, Go, dll. GitHub Octoverse 2018 Kami harap semoga akademi ini juga bisa berkontribusi untuk mengembangkan ekosistem Kotlin di Indonesia.;Ekosistem Kotlin berkembang pesat sejak 2017 setelah ditetapkan sebagai bahasa resmi Android. Didukung multiplatform dan kompatibilitas tinggi dengan bahasa pemrograman lain, Kotlin cepat diadopsi perusahaan besar seperti GO-JEK, Tokopedia, dan Pinterest. Komunitas global yang kuat, termasuk di Indonesia, mendorong pertumbuhannya. Kotlin dinobatkan sebagai bahasa tercepat berkembang oleh GitHub Octoverse 2018, menawarkan kemudahan bagi developer Android dan lintas platform untuk beradaptasi dan berinovasi.
Pada sub-modul sebelumnya kita sudah berkenalan dengan Kotlin, mulai dari sejarah, karakteristik yang dimilikinya, hingga ke ekosistemnya di kalangan developer. Kini saatnya kita masuk  topik selanjutnya. Bagaimana cara untuk membangun dan menjalankan program Kotlin?  Di sini kita akan belajar membuat sebuah program -benar-benar dari awal- dengan hanya memanfaatkan  text editor , terminal, dan  build tools,  sebelum nantinya menggunakan IDE. Lalu peralatan apa saja kah yang kita dibutuhkan? Mari kita siapkan terlebih dahulu. Persiapan dan Instalasi Pada tahap pertama, tentunya kita perlu menyiapkan beberapa tools yang dibutuhkan untuk membangun program dengan Kotlin. Beberapa tools itu bisa kita kategorikan ke dalam SDK, IDE, dan  build tools . Software Development Kit (SDK) SDK merupakan seperangkat alat pengembangan perangkat lunak yang digunakan untuk mempermudah pengembangan aplikasi dalam platform tertentu. Setiap platform biasanya menyediakan SDK khusus, misalnya Android dengan Android SDK-nya, iOS dengan iOS SDK-nya, ataupun Java dengan JDK-nya. Dengan SDK tersebut, developer dapat mengakses fitur khusus dari masing-masing platform. Terdapat juga SDK di luar platform seperti Google SDK, Facebook SDK, dll yang bisa diintegrasikan ke aplikasi. Untuk Kotlin, karena ia berjalan diatas JVM, maka ia sama seperti Java. Kotlin menggunakan JDK sebagai SDK-nya dan JRE untuk menjalankan program aplikasi. JDK, JRE dan JVM sendiri terlihat sama karena ketiganya merupakan inti dari bahasa pemrograman Java. Meski terlihat sama, masing-masing dari ketiganya, punya peran sendiri-sendiri. JDK ( Java Development Kit ) adalah sebuah perangkat lunak yang menyediakan beberapa  tools  untuk pengembangan dan berkas binari yang diperlukan untuk proses kompilasi dari kode Java ke  bytecode . Selanjutnya, JVM atau  Java Virtual Machine  bertanggung jawab untuk melakukan konversi  bytecode  kedalam bahasa mesin. JVM juga menyediakan fungsi inti dari Java seperti  memory management ,  garbage collection ,  security  dan sebagainya. JVM disebut virtual karena memiliki antar muka yang tidak bergantung pada sistem operasi dan perangkat keras yang menjadi dasar dari JVM itu sendiri. Terakhir, JRE atau  Java Runtime Environment , merupakan implementasi dari JVM yang menyediakan sebuah platform untuk menjalankan program. Berbeda dengan JDK dan JVM, JRE tidak menyediakan  tools  untuk pengembangan seperti kompiler,  debugger  dan sebagainya. Tetapi JRE diperlukan untuk menjalankan program. Pada dasarnya setiap JDK yang bisa kita gunakan, punya basis OpenJDK dan bersifat open-source. Yang membedakannya adalah bagaimana JDK tersebut didistribusikan. Contoh distribusinya bisa dari Oracle (OracleJDK), OpenJDK Distribution atau Azul Zulu JDK.  Pada akademy ini kita akan menggunakan JDK yang didistribusi oleh OpenJDK Distribution karena bisa digunakan secara gratis dengan lisensi personal. Nah untuk JRE, kita tidak perlu melakukan instalasi secara terpisah karena sudah terdapat di dalam paket instalasi OpenJDK. Build Tools Selanjutnya adalah  build tools , perangkat lunak yang akan kita gunakan untuk membantu mengotomatisasi proses. Seperti misalnya pemaketan dari proyek yang kita akan kembangkan. Selain kompiler  command line  dan IntelliJ IDEA, Anda juga dapat menggunakan Ant, Maven, dan Gradle sebagai  build tools -nya. Dari ketiga  build tools  tersebut, Gradle lah yang paling sering digunakan. Pasalnya, ia cukup fleksibel dalam membantu proses kompilasi. Gradle sendiri merupakan sebuah perangkat lunak  open-sources  yang bisa kita gunakan untuk berbagai macam keperluan dalam pengembangan aplikasi  [3] . Dalam menuliskan skrip Gradle, kita bisa menggunakan Groovy atau Kotlin DSL. Gradle mendukung proses pengunduhan dan konfigurasi secara otomatis dari sebuah dependensi atau  library  lain. Selain itu, Gradle berfokus pada fleksibilitas dan kinerja sehingga memungkinkan kita untuk membangun sebuah aplikasi dengan mudah.  Gradle memiliki beberapa fitur yang cukup penting, seperti performa yang cukup stabil dan sudah didukung oleh beberapa IDE terkenal seperti Eclipse, Android Studio dan Intellij IDEA. Untuk mengetahui lebih dalam tentang keunggulan dalam penggunaan Gradle, silakan membacanya pada  tautan ini . Integrated Development Environment (IDE) Proses pengembangan aplikasi tak lepas dari bantuan IDE. Memang tanpa IDE kita tetap bisa membuat program dengan  text editor.  Namun, fitur-fitur yang IDE tawarkan akan membuat proses pengembangan menjadi jauh lebih mudah dan efisien.  Pada umumnya IDE menyediakan beberapa fitur seperti  text editor  yang akan kita gunakan untuk menulis kode,  tools  untuk mengotomatisasi proses  build  dari program yang kita buat dan sebuah  debugger  yang akan membantu kita mendeteksi dan memperbaiki kesalahan yang terdapat pada program. Terdapat berbagai macam IDE yang mendukung pengembangan dengan bahasa pemrograman Kotlin seperti  IntelliJ IDEA ,  Android Studio , dan  Eclipse . Dari semua IDE tersebut, IntelliJ IDEA dan Android Studio lah yang paling direkomendasikan. Anda bisa menggunakan IntelliJ IDEA untuk pengembangan aplikasi secara umum dan Android Studio untuk pengembangan aplikasi Android. Pada akademi ini kita akan fokus menggunakan IntelliJ IDEA. IntelliJ IDEA dikembangkan oleh pengembang yang sama dengan Kotlin, yaitu JetBrains. Tentunya ada kompatibilitas yang lebih antara keduanya. Bahkan JetBrains juga menyediakan tutorial khusus untuk memulai Kotlin menggunakan IntelliJ IDEA. Anda bisa membacanya di  tautan ini . Dengan dukungan fitur yang mumpuni, IntelliJ IDEA dapat membantu kita menyelesaikan program yang sedang kita kembangkan dengan cepat. Intellij IDEA memiliki dua versi yang dapat kita gunakan untuk pengembangan aplikasi, yaitu versi  Ultimate  dan  Community . Versi Ultimate ditujukan untuk pengembangan aplikasi lebih lanjut. Pada akademi ini kita akan menggunakan versi Community untuk belajar Kotlin.;Untuk membangun program Kotlin, dibutuhkan tiga komponen utama: SDK (JDK), build tools (Gradle), dan IDE (IntelliJ IDEA). JDK berperan menjalankan program di Java Virtual Machine, Gradle membantu otomatisasi proses pengembangan, sementara IntelliJ IDEA menyediakan lingkungan pengembangan lengkap dengan fitur text editor, build tools, dan debugger. Kombinasi ketiganya memudahkan pengembangan aplikasi Kotlin secara efisien.
"Instalasi OpenJDK (Linux dan macOS) Instalasi OpenJDK dapat dilakukan dengan beberapa cara, tergantung dengan sistem operasi yang kita gunakan. OpenJDK dapat berjalan di semua sistem operasi berbasis  Linux ,  macOS , maupun  Windows . Untuk mengikuti kelas ini, kita akan menggunakan OpenJDK versi  1.8  yang didistribusikan oleh  Azul Zulu  untuk menghindari kesalahan yang mungkin saja terjadi.  Okey, untuk proses instalasinya akan kita mulai terlebih dahulu untuk sistem operasi  Linux  dan  macOS . Bahasan sistem operasi Windows akan kita simak pada sub-modul berikutnya. Untuk itu, langsung saja ikuti panduan instalasinya berikut. Instalasi SDKMAN Cara untuk menginstal OpenJDK pada  Linux  dan  macOS  bisa dikatakan mirip karena pada dasarnya kedua sistem operasi tersebut berbasiskan  Unix . Instalasinya bisa kita lakukan secara manual, melalui  PPA  atau bisa juga dengan  SDKMAN . Dari ketiga cara tersebut, cara yang paling kami rekomendasikan adalah dengan menggunakan SDKMAN. SDKMAN sendiri adalah sebuah  tools  yang bisa digunakan untuk mengatur versi dari SDK secara paralel. Ia tersedia di sebagian besar sistem operasi berbasiskan  Unix , termasuk Linux dan macOS. Apa keunggulannya? Dengan SDKMAN, kita tidak perlu melakukan konfigurasi saat ingin menginstall SDK. Tinggal jalankan perintah instalasi, dan kita bisa langsung menggunakan SDK tersebut. Sebelum melakukan instalasi OpenJDK dengan SDKMAN, kita akan menginstal terlebih dahulu SDKMAN tersebut. Langung saja ikuti beberapa langkah instalasinya di bawah ini: Pastikan Anda sudah melakukan instalasi paket  Curl . Caranya jalankan perintah berikut pada terminal: curl --version Jika ternyata belum, jalankan perintah berikut pada terminal untuk menginstal curl: sudo apt install curl Ikuti instruksinya sampai proses instalasi selesai. Untuk macOS, instalasi  Curl  bisa memanfaatkan  homebrew  dengan perintah di bawah ini: brew install curl Setelah itu, jalankan perintah berikut untuk instalasi SDKMAN: curl -s ""https://get.sdkman.io"" | bash Kemudian, jalankan perintah berikut: source ""$HOME/.sdkman/bin/sdkman-init.sh"" Untuk memastikan SDKMAN berhasil diinstal, gunakan perintah berikut: sdk version Seharusnya terminal akan menampilkan versi SDKMAN seperti di bawah ini: SDKMAN 5.11.0+644 Instalasi OpenJDK Nah untuk instalasi OpenJDK via SDKMAN, caranya sangat sederhana. Anda hanya perlu menjalankan perintah berikut pada terminal: sdk install java 8.0.332-zulu Tunggu hingga proses instalasi selesai dan Anda telah berhasil menginstal OpenJDK. Untuk melihat semua versi JDK yang dapat diinstal, kita bisa menjalankan perintah berikut: sdk list java Terminal akan menampilkan daftar versi JDK kurang lebih seperti berikut: Pada gambar di atas terdapat keterangan bahwa komputer kita sedang menggunakan JDK versi  8.0.256-zulu . Jika Anda ingin mengganti versi JDK yang sebelumnya sudah pernah diinstal, Anda bisa menggunakan perintah berikut: sdk default java <another-version> Ubah  <another-version>  dengan versi yang Anda inginkan, misalnya  11 .0.8-open . Lalu periksa kembali menggunakan perintah berikut: sdk current java Terminal akan menampilkan pesan seperti berikut: Using java version 11.0.8-open Untuk memastikan apakah kita sudah berhasil melakukan instalasi, Anda bisa menjalankan perintah  java -version . Pastikan terminal menampilkan versi dari OpenJDK kurang lebih seperti berikut: Yeay! Proses instalasi telah berhasil untuk sistem operasi  Linux  dan  macOS . Di sub-modul berikutnya yuk kita bahas bagaimana konfigurasi dan instalasi  JDK  pada sistem operasi  Windows.";"Instalasi OpenJDK di Linux dan macOS menggunakan SDKMAN sangat mudah. Pertama, install Curl, kemudian jalankan perintah curl -s ""https://get.sdkman.io"" | bash. Setelah SDKMAN terinstal, gunakan perintah sdk install java 8.0.332-zulu untuk menginstal OpenJDK versi 8. Periksa instalasi dengan java -version. SDKMAN memudahkan manajemen versi SDK secara paralel, mendukung berbagai sistem operasi berbasis Unix."
Instalasi Gradle (Linux dan macOS) Setelah selesai dengan instalasi OpenJDK pada sub-modul sebelumnya, mari kita lanjut dengan instalasi Gradle. Di sini tidak ada prasyarat khusus. Kita hanya harus memastikan terlebih dahulu apakah OpenJDK ada pada sistem operasi yang akan kita gunakan. Inilah alasan mengapa kita mempraktikkan instalasinya di awal. Sama seperti instalasi  OpenJDK , instalasi Gradle akan menggunakan SDKMAN untuk  Linux  dan  macOS . Instalasi Gradle via SDKMAN Sama seperti instalasi  OpenJDK  sebelumnya, Untuk bisa melihat daftar versi dari Gradle, Anda bisa menggunakan perintah berikut: sdk list gradle Ketika dijalankan, maka terminal akan menampilkan hasil seperti berikut: Tanpa berlama-lama, lansung saja jalankan perintah di bawah ini pada terminal untuk instalasi Gradle. Tunggu hingga proses instalasinya selesai.   sdk install gradle 8.0.2 Catatan: Gunakan versi Gradle terbaru untuk best-practice. Cukup mudah bukan? Untuk memastikan Gradle berhasil diinstal, bisa dengan jalankan perintah  gradle -v  pada terminal seperti berikut: Instalasi selesai! Cukup mudah bukan? Ini karena kita menggunakan SDKMAN untuk instalasi di mana semua konfigurasi sudah diterapkan secara otomatis ketika proses instalasi berjalan. Nah, lalu bagaimana dengan instalasi Gradle pada Windows? Yuk lanjut ke sub-modul selanjutnya untuk proses instalasi dan konfigurasinya.;Instalasi Gradle di Linux dan macOS menggunakan SDKMAN sangat sederhana. Cukup jalankan perintah sdk install gradle 8.0.2 pada terminal setelah OpenJDK terinstal. Untuk melihat daftar versi Gradle, gunakan perintah sdk list gradle. Pastikan instalasi berhasil dengan menjalankan gradle -v. SDKMAN memudahkan proses instalasi dan konfigurasi Gradle secara otomatis, tanpa perlu konfigurasi manual.
Instalasi IntelliJ IDEA Sebelum melakukan instalasi IntelliJ IDEA, ketahui terlebih dahulu beberapa syarat di masing-masing sistem operasi sebagai berikut: Windows Microsoft Windows 10/8/7/Vista/2003/XP (incl.64-bit) 2 GB RAM minimum, 4 GB RAM direkomendasikan 1.5 GB ruang kosong pada penyimpanan 1024x768 minimal resolusi layar macOS macOS 10.8.3 atau lebih tinggi 2 GB RAM minimum, 4 GB RAM direkomendasikan 1.5 GB ruang kosong pada penyimpanan 1024x768 minimal resolusi layar Linux GNOME atau KDE desktop 2 GB RAM minimum, 4 GB RAM direkomendasikan 1.5 GB ruang kosong pada penyimpanan 1024x768 minimal resolusi layar Pastikan komputer Anda memenuhi syarat di atas. Jika sudah, unduhlah berkas instalasi IntelliJ IDEA berdasarkan sistem operasi dengan versi yang kami sarankan yaitu versi  2020.3.1 Community  yang dapat diunduh pada tautan  IntelliJ IDEA download page .  Anda bisa mencari versi yang dimaksud dengan memilih menu dropdown seperti berikut: Selanjutnya ikuti langkah-langkah instalasi sesuai sistem operasi yang digunakan. Linux Setelah berhasil mengunduh berkas, ekstrak berkas tersebut dengan menggunakan perintah yang dijalankan pada terminal berikut: tar xvf ideaIC-2020.3.1.tar.gz Lanjut, masuk ke dalam folder  bin  dengan menggunakan perintah: cd idea-IC-203.6682.168/bin/ Terakhir, jalankan  shell script idea.sh  dengan menggunakan perintah. ./idea.sh Ikuti instruksi pada jendela yang tampil untuk menyelesaikan proses instalasi. Windows dan macOS Berbeda dengan Linux, jika menggunakan Windows atau macOS, Anda tidak perlu mengekstrak hasil unduhan. Anda bisa langsung menjalankan berkas  idealC-2020.3.1.exe  (Windows) atau  idealC-2020.3.1.dmg  (macOS). Lalu ikuti instruksi pada jendela yang tampil untuk menyelesaikan proses instalasi. Konfigurasi Intellij IDEA Pada dasarnya jika sebelumnya komputer kita sudah terinstal JDK, kita tidak perlu melakukan konfigurasi pada Intellij IDEA. Apa pasal? JDK akan secara otomatis terdeteksi sehingga Anda bisa langsung menggunakannya untuk membuat proyek baru. Untuk mengenal IntelliJ IDEA lebih lanjut, Anda bisa membaca blog berikut:  Berkenalan Dengan IntelliJ IDEA;Instalasi IntelliJ IDEA berbeda di setiap sistem operasi. Di Linux, unduh versi 2020.3.1 Community, ekstrak dengan perintah tar xvf ideaIC-2020.3.1.tar.gz, masuk folder bin, lalu jalankan ./idea.sh. Di Windows dan macOS, cukup jalankan file installer idealC-2020.3.1.exe atau .dmg. Prasyarat minimal: 2 GB RAM, 1.5 GB ruang penyimpanan, resolusi 1024x768. JDK terdeteksi otomatis, sehingga tidak perlu konfigurasi tambahan saat membuat proyek baru.
"Jika semua  tools  sudah Anda siapkan, kini Anda bisa mulai mencoba untuk membuat dan menjalankan program dengan Kotlin. Seperti yang sudah disampaikan, Kotlin memiliki dukungan  tools  yang memadai. Ketika Anda ingin membuat sebuah program dengan Kotlin, Anda bisa memilih berbagai macam  tools  mulai dari yang paling dasar hingga tingkat lanjut. Pada dasarnya semua program aplikasi bisa dikembangkan hanya dengan bantuan  text editor  dan  build tools . Lalu adanya  IDE  adalah untuk mempermudah dan mempercepat proses pengembangan. Pada sub-modul ini kita akan mempelajari bersama perihal bagaimana membuat program dengan Kotlin dari cara yang paling dasar hingga memanfaatkan bantuan IDE. Membuat Program Dengan Gradle Guna membuat program dengan Gradle, kita akan membutuhkan sebuah plugin yaitu  Gradle Init Build Plugin . Kita tidak perlu menambahkannya secara manual karena plugin tersebut merupakan bawaan dari paket instalasi Gradle. Sebelum membuat project, terlebih dahulu buat folder baru yang akan digunakan sebagai folder project yang nantinya akan kita buat. Setelah selesai, silakan buka  terminal  atau  command prompt  dari dalam folder tersebut. Untuk Anda yang menggunakan sistem operasi Windows, gunakan pintasan dengan menulisakan  cmd  pada  search bar  untuk membuka  Command Prompt  dari dalam folder project seperti berikut: Setelah terminal atau command prompt terbuka, langsung saja jalankan perintah  gradle init  untuk membuat project baru seperti seperti berikut: Untuk pembuatan folder project di atas, berilah nama kotlin-starter. Silakan sesuaikan namanya sesuai kehendak Anda. Lebih lanjut, setelah kita menjalankan perintah seperti di atas, terminal akan menampilkan daftar jenis-jenis proyek yang bisa kita pilih. Kita bisa memilih jenis dari proyek yang ingin kita kembangkan dengan cara memilih angka yang ada pada daftar tersebut. Karena kita akan membuat proyek dengan tipe  application  maka masukkan angka  2  dan tekan  enter . Berikutnya kita akan diminta untuk memilih bahasa yang akan kita gunakan. Karena kita akan membuat proyek dengan Kotlin, langsung saja masukkan angka  4  dan tekan  enter .  Setelah itu, Anda juga bisa menentukan tipe dari  build script , nama proyek dan juga  package name  yang akan digunakan. Selengkapnya bisa Anda lihat pada gambar berikut:      Sampai di sini kita telah memiliki proyek Kotlin baru dengan nama  kotlin-starter ,  package name   com.dicoding.kotlin  dan menggunakan  Kotlin DSL  sebagai  build script -nya. Sebenarnya kita bisa meringkas langkah-langkah tersebut dengan cara langsung menuliskan perintah seperti berikut: gradle init --type kotlin-application --dsl kotlin --project-name kotlin-starter --package com.dicoding.kotlin Jika Anda membuka proyek tersebut, maka Anda akan melihat struktur proyek seperti di bawah ini: Mari kita pelajari satu per satu dari masing-masing berkas tersebut. Gradle Wrapper Di dalam folder  gradle/wrapper/  kita akan menemukan 2 (dua) berkas yaitu  gradle-wrapper.jar  dan  gradle-wrapper.properties . Berkas Wrapper JAR merupakan sebuah  library  yang berisi kode untuk mengunduh distribusi Gradle. Sedangkan  gradle-wrapper.properties  adalah sebuah properti yang bisa kita gunakan untuk mengonfigurasi  behaviour  dari Wrapper runtime seperti mengatur versi Gradle dari proyek dll. Berikut adalah konfigurasi yang terdapat pada berkas tersebut: distributionBase=GRADLE_USER_HOME distributionPath=wrapper/dists distributionUrl=https\://services.gradle.org/distributions/gradle-6.2.2-bin.zip zipStoreBase=GRADLE_USER_HOME zipStorePath=wrapper/dists Terdapat juga berkas  gradlew  dan  gradlew.bat  pada folder  root,  yaitu sebuah  shell script  dan  Windows batch script  yang digunakan untuk menjalankan  build  dengan Wrapper. Build Scripts Selanjutnya, di dalam proyek tersebut juga terdapat 2 (dua) berkas  gradle scripts  yaitu  settings.gradle.kts  dan  build.gradle.kts . Kedua berkas tersebut merupakan  Gradle Kotlin DSL  yang bisa kita gunakan untuk mengatur konfigurasi dari Gradle. Gradle mendukung 2 (dua) jenis  build script  yaitu  Groovy  dan  Kotlin DSL . Namun pada akademi ini kita hanya akan fokus menggunakan Kotlin DSL. Beberapa hal yang menjadi alasan kenapa kita memilih Kotlin DSL adalah: Memungkinkan kita untuk memaksimalkan fitur  auto-completion  pada IDE nantinya; Membuat kita tidak perlu mempelajari 2 bahasa (Groovy + Kotlin); Untuk DSL Konfigurasi, pengembangan Gradle kedepan akan lebih fokus ke penggunaan Kotlin dibandingkan dengan Groovy. Di dalam berkas  settings.gradle.kts  kita akan menemukan konfigurasi berikut: /*  * This file was generated by the Gradle 'init' task.  *  * The settings file is used to specify which projects to include in your build.  *  * Detailed information about configuring a multi-project build in Gradle can be found  * in the user manual at https://docs.gradle.org/6.2.2/userguide/multi_project_builds.html  */  rootProject.name = ""kotlin-starter"" Konfigurasi tersebut digunakan untuk mengatur nama dari proyek kita. Ke depannya, di dalam berkas ini kita bisa menambahkan beberapa konfigurasi seperti pengaturan sub-modul dan sebagainya. Kemudian berkas  build.gradle.kts : /*  * This file was generated by the Gradle 'init' task.  *  * This generated file contains a sample Kotlin application project to get you started.  */   plugins {      // Apply the Kotlin JVM plugin to add support for Kotlin.      id(""org.jetbrains.kotlin.jvm"") version ""1.3.61""       // Apply the application plugin to add support for building a CLI application.      application   }    repositories {      // Use jcenter for resolving dependencies.     // You can declare any Maven/Ivy/file repository here.      jcenter()   }    dependencies {      // Align versions of all Kotlin components      implementation(platform(""org.jetbrains.kotlin:kotlin-bom""))       // Use the Kotlin JDK 8 standard library.      implementation(""org.jetbrains.kotlin:kotlin-stdlib-jdk8"")       // Use the Kotlin test library.      testImplementation(""org.jetbrains.kotlin:kotlin-test"")       // Use the Kotlin JUnit integration.      testImplementation(""org.jetbrains.kotlin:kotlin-test-junit"")  }   application {      // Define the main class for the application.      mainClassName = ""com.dicoding.kotlin.AppKt"" } Di dalam berkas tersebut terdapat berbagai macam konfigurasi seperti pengaturan  plugins ,  repositories ,  dependencies  dan lain sebagainya. Biasanya kita akan sering menggunakan berkas ini ketika kita ingin menambahkan  dependency  atau  library  baru. Pada proyek baru tersebut kita terdapat beberapa  library  yang secara otomatis sudah ditambahkan. Source (src) Folder  src  merupakan tempat kita menyimpan berbagai macam sumber daya untuk pengembangan aplikasi. Di dalamnya Anda akan melihat 2 (dua) folder lagi yaitu  main  dan  test . Mari kita mulai dari folder  main  terlebih dahulu. Folder ini merupakan folder utama tempat di mana kita meletakkan berkas kode dan  resources  lainnya. Di dalam folder  main  terdapat folder  Ko tlin , lalu di dalam Kotlin terdapat  package name  dari proyek kita yaitu  com.dicoding.kotlin . Pada  package name  ini lah kita bisa menambahkan berkas kode nantinya. Saat ini kita sudah memiliki 1 berkas bernama  App.kt : /*  * This Kotlin source file was generated by the Gradle 'init' task.  */ package com.dicoding.kotlin  class App {     val greeting: String         get() {             return ""Hello world.""         } }  fun main(args: Array<String>) {     println(App().greeting) } Selanjutnya adalah folder  test  yang berisi berkas-berkas kode pengujian aplikasi. Sama dengan folder  main , di dalam  test  juga terdapat folder  kotlin  dan  package name  dari proyek kita. Di sana terdapat berkas  AppTest.kt  yang merupakan sebuah kelas pengujian. Berikut kode di dalamnya: /*  * This Kotlin source file was generated by the Gradle 'init' task.  */ package com.dicoding.kotlin  import kotlin.test.Test import kotlin.test.assertNotNull  class AppTest {     @Test fun testAppHasAGreeting() {         val classUnderTest = App()         assertNotNull(classUnderTest.greeting, ""app should have a greeting"")     } } Semua kode di atas dibuat secara otomatis saat kita membuat proyek dengan Gradle.  Menjalankan Program Gradle Setelah mengetahui struktur dari proyek yang dibuat, selanjutnya kita akan menjalankan program tersebut. Caranya sangat sederhana. Pada terminal kita cukup menjalankan 1 (satu) perintah Gradle berikut: gradle run Lalu Gradle akan melakukan proses build pada proyek tersebut. Secara otomatis ia akan mengeksekusi kode di dalam berkas  App.kt . Jika berhasil, maka terminal akan menampilkan pesan seperti di bawah ini: Jika proses build berlangsung lama, itu adalah hal normal karena baru pertama kali dijalankan pada suatu proyek di mana compiler akan mengunduh beberapa library pendukung agar program dapat dijalankan dengan baik. Langkah-langkah di atas sama persis ketika kita menggunakan sistem operasi Windows sehingga kita tidak perlu khawatir. Namun pastikan bahwa saat Anda menjalankan perintah  gradle init.  perintah tersebut dijalankan dari dalam folder project baru. Karena jika dijalankan di dalam folder project yang sebelumnya sudah menjalankan perintah tersebut,  command prompt  akan menampilkan eror dan tak akan berlanjut ke langkah-langkah berikutnya. Perintah  gradle run  di atas juga bisa juga Anda gunakan pada system operasi Windows. Berikut contoh jika perintah tersebut dijalankan:";Membuat program Kotlin dengan Gradle dimulai dengan perintah gradle init untuk membuat struktur project. Pilih tipe application, bahasa Kotlin, dan konfigurasikan nama project. Struktur project mencakup Gradle Wrapper, build scripts, dan folder source. Build scripts (settings.gradle.kts dan build.gradle.kts) mengatur konfigurasi project, dependencies, dan plugins. Folder src berisi kode utama dan pengujian. Untuk menjalankan program, gunakan perintah gradle run yang akan melakukan build otomatis dan mengeksekusi kode di App.kt. Gradle menyediakan kemudahan dalam manajemen project, dependency, dan proses build lintas platform.
"Membuat Program Dengan IntelliJ IDEA Di sub-modul sebelumnya kita sudah belajar bagaimana membuat proyek baru dengan memanfaatkan perintah dari Gradle. Selanjutnya kita akan mencoba membuat proyek baru menggunakan IntelliJ IDEA. Langsung saja, buka IntelliJ IDEA pada komputer Anda. Berikut adalah tampilan utama dari IntelliJ IDEA: Untuk membuat proyek baru, Anda bisa memilih menu  New Project . Anda akan melihat jendela baru kurang lebih seperti berikut: Karena kita tetap akan menggunakan Gradle sebagai  build tools , maka pada panel sebelah kiri pilihlah Gradle. Berikan tanda  checklist  pada  Kotlin DSL build script  untuk menetapkan Kotlin DSL sebagai  build script  yang akan digunakan pada proyek. Pada  Additional Libraries and Frameworks , pilih  Kotlin/JVM  dan  Java  dengan memberikan tanda  checklist . Dengan begitu IntelliJ IDEA akan melakukan  setup  proyek secara otomatis. Klik tombol  Next  dan isikan  GroupId  dan  ArtifactId  seperti gambar di bawah ini: Beberapa informasi yang kita masukkan tersebut akan menjadi identitas project yang akan kita kembangkan. Secara  default , Intellij IDEA sudah menentukan nama proyek (sesuai dengan  ArtifactId ) dan juga lokasi proyek. Namun Anda bisa menggantinya sesuai kebutuhan. Jika sudah sesuai, klik tombol  Finish  dan Intellij IDEA akan membuatkan Anda sebuah proyek baru. Berikut adalah tampilan dari proyek tersebut: Struktur proyek yang diberikan, tidak jauh berbeda dengan proyek buatan perintah Gradle. Hanya saja, pada IntelliJ IDEA belum dibuatkan berkas kode secara otomatis, sehingga program belum bisa dijalankan. Anda perlu menambahkannya secara manual pada folder  main/kotlin/ . Buatlah  package   com.dicoding.kotlin  dengan melakukan klik kanan pada folder  kotlin  dan pilih  New - Package . Selanjutnya, klik kanan pada  package   name  tersebut dan pilih  New - Kotlin File/Class  untuk menambahkan berkas Kotlin. Berikan nama pada berkas tersebut  App.kt  dan tambahkan kode berikut: fun main() {    println(""Hello Kotlin!"") } Setelah menambahkan kode tersebut, maka proyek Anda dapat dijalankan. Menjalankan Program IntelliJ IDEA Seperti yang sudah disampaikan sebelumnya, salah satu kelebihan dari menggunakan IDE adalah dukungannya terhadap  GUI . Perintah-perintah yang biasanya mengharuskan kita untuk menuliskannya pada terminal kini bisa digantikan dengan tombol interaktif pada IDE. Seperti halnya tombol untuk menjalankan program berikut: Tombol  run  tersebut hanya akan muncul di samping fungsi dengan nama  main() . Klik tombol tersebut atau tekan  Ctrl  +  Shift  + F10  untuk menjalankan program. Kompiler pada IntelliJ IDEA akan mengeksekusi kode di dalam fungsi  main().   Jika berhasil, IIntelliJ IDEA akan menampilkan panel  Run  seperti di bawah ini:";"Membuat program Kotlin di IntelliJ IDEA dimulai dengan memilih ""New Project"" dan memilih Gradle dengan Kotlin DSL. Pilih Kotlin/JVM dan Java, lalu isi GroupId dan ArtifactId. Setelah proyek terbentuk, buat package dan file Kotlin (App.kt) secara manual di folder main/kotlin. Tambahkan fungsi main() dengan kode sederhana, misalnya println. Jalankan program menggunakan tombol run di samping fungsi main() atau shortcut Ctrl+Shift+F10. IntelliJ IDEA akan mengeksekusi kode dan menampilkan hasilnya di panel Run. Proses ini lebih mudah dibandingkan menggunakan terminal, dengan dukungan GUI yang interaktif."
"Kita sudah tahu cara  membangun dan menjalankan program Kotlin. Kini di sub-modul ini kita akan mempelajari konsep-konsep dasar (fundamental) pada Kotlin. Kita akan belajar bersama mengenai  data types ,  function ,  expression  dan juga  nullability  pada Kotlin. Hello Kotlin! Sebelum ke topik-topik fundamental tersebut, mari kita awali dengan pembahasan tentang program  Hello Kotlin! . Pada sub-modul sebelumnya kita telah berjumpa dengan sebuah proyek yang menampilkan sebuah teks  Hello World!  dan juga  Hello Kotlin! . Buat Anda yang pernah belajar pemrograman sebelumnya, tentu tak asing dengan program ini.  Hello World!  sering digunakan untuk menunjukkan sintaks dasar pada sebuah bahasa pemrograman. Karena kita sedang belajar bahasa pemrograman Kotlin, maka kita mengganti namanya dengan  Hello Kotlin! . Hello Kotlin!  merupakan sebuah program sederhana yang digunakan untuk mencetak sebuah teks “ Hello Kotlin! ” ke dalam layar atau konsol. Berikut adalah contoh kode dari program tersebut: // main function fun main() {    println(""Hello Kotlin!"") } Baris pertama dari kode di atas adalah komentar yang ditandai dengan tanda  // . // main function Sebuah komentar akan dilewatkan ketika proses kompilasi, sehingga tidak akan mempengaruhi alur program yang kita tulis. Komentar bisa kita gunakan untuk mendokumentasikan kode yang kita tulis agar ketika suatu saat kita membukanya kembali, kita bisa mengetahui fungsi dari kode yang kita beri komentar tersebut. Terdapat dua jenis komentar yang bisa kita gunakan. Pertama adalah  single line comment  yaitu komentar satu baris yang diawali dengan tanda  //  dan berakhir di akhir baris komentar tersebut. // single line comment Yang kedua adalah  multi-line comment  yang diawali dengan tanda  /*  dan diakhiri dengan tanda  */ . /*    multi line comment    Hello Kotlin */ Dengan  multi-line comment  kita bisa menuliskan beberapa baris komentar. Selanjutnya adalah fungsi yang bernama  main() , fungsi yang wajib kita definisikan ketika membuat sebuah program. Fungsi  main()  merupakan sebuah  entry point  yang    otomatis akan dipanggil ketika program dijalankan. Pada sub-modul berikutnya kita akan belajar lebih dalam tentang bagaimana mendefinisikan sebuah fungsi. Kemudian fungsi  println(),  fungsi yang akan kita gunakan untuk mencetak teks ke dalam layar atau konsol. Fungsi  println()  membutuhkan satu argumen berupa message dengan tipe data yang dikehendaki. Tipe data yang didukung untuk kita masukkan ke dalam fungsi  println()  ada di  tautan ini . Selain fungsi  println() , terdapat juga fungsi  print()  yang berfungsi sama seperti fungsi  println() . Bedanya,  println()  akan menambahkan baris baru setelah selesai mencetak argumen yang diberikan, sementara fungsi  print()  tidak melakukan apapun ketika argumen yang diberikan, selesai dicetak. Untuk memahaminya lebih dalam, coba jalankan kode berikut: fun main() {    val name = ""Alfian""     print(""Hello my name is "")    println(name)    print(if (true) ""Always true"" else ""Always false"") }  /*    output:        Hello my name is Alfian        Always true */ Fungsi  println()  dan  print()  secara internal memanggil fungsi  system.out.print(message) . @kotlin.internal.InlineOnly public actual inline fun print(message: Any?) {     System.out.print(message) } Kegunaan utama dari fungsi  system.out.print(message)  adalah untuk menampilkan pesan yang diberikan ke  standard output stream . Selain menampilkan pesan yang diberikan secara eksplisit, fungsi tersebut juga dapat digunakan untuk menampilkan nilai dari sebuah  expression  atau variabel seperti yang dicontohkan di atas.";Program Hello Kotlin! adalah contoh sederhana untuk memperkenalkan sintaks dasar Kotlin. Terdiri dari fungsi main() sebagai entry point program, menggunakan println() untuk mencetak teks ke konsol. Kotlin mendukung dua jenis komentar: single-line (//) dan multi-line (/* */). Fungsi println() mencetak teks dan menambah baris baru, sementara print() tidak menambah baris baru. Keduanya memanfaatkan system.out.print() untuk menampilkan output. Program ini mendemonstrasikan cara dasar menulis dan menjalankan kode Kotlin, termasuk deklarasi variabel, penggunaan kondisional, dan fungsi cetak.
"Data Types & Variable Data types atau tipe data adalah sebuah pengklasifikasian data berdasarkan jenis data tersebut. Untuk mengembangkan sebuah program, ada beberapa tipe data yang akan kita pelajari. Di antaranya adalah  Character ,  String ,  Array ,  Numbers  dan  Booleans . Semuanya akan kita bahas sejelas dan sesederhana mungkin di dalam sub-modul ini. Namun sebelumnya, ada satu hal yang kita perlu tahu terlebih dahulu, yaitu  Variabel . Umumnya variabel digunakan untuk menyimpan informasi atau nilai yang akan dikelola di dalam sebuah program. Sebuah variabel akan membutuhkan kata kunci  var  atau  val ,  identifier ,  type  dan  initialization . Kira-kira strukturnya seperti berikut: var identifier: Type = initialization Berikut adalah contoh variabel dengan tipe String: var company: String = ""Dicoding"" Mari kita ulas setiap bagian pada struktur variabel di atas. var   atau   val var  atau  val  digunakan untuk mengontrol nilai dari sebuah variabel. Dengan kata kunci  var  kita bisa mengubah nilai yang sudah kita inisialisasikan. Sebagai contoh: var company: String = ""Dicoding"" company = ""Dicoding Academy"" Variabel  company  yang awalnya memiliki nilai  “Dicoding”  sekarang sudah diubah menjadi  “Dicoding Academy” . Sedangkan jika kita menggunakan kata kunci  val , kita tidak bisa mengubah nilai yang sebelumnya sudah kita inisialisasi. Jika kita memaksa untuk mengubahnya, maka akan terjadi eror seperti berikut: val company: String = ""Dicoding"" company = ""Dicoding Academy"" //Val cannot be reassigned Identifier Identifier  merupakan nama dari sebuah variabel. Pada contoh kode di atas yang merupakan  identifier  adalah  company . Perlu diketahui bahwa di dalam sebuah program kita tidak bisa membuat lebih dari 1 (satu) variabel dengan nama sama. Type Pada bagian inilah kita menentukan tipe data dari variabel tersebut. Tipe data dibutuhkan agar kompiler dapat mengetahui bagaimana sebuah data akan digunakan. Tipe data dari contoh variabel di atas adalah String. Karena Kotlin mendukung  type inference  maka kita diperbolehkan untuk tidak menuliskan tipe data secara eksplisit: val company = ""Dicoding"" Initialization Dan yang terakhir adalah  initialization  atau nilai awal dari sebuah variabel. Pada contoh di atas yang berperan sebagai  initialization  adalah  “Dicoding”  dan  “Dicoding Academy” . Tipe data juga menentukan operasi apa saja yang dapat dilakukan pada sebuah variabel dan bagaimana nilai dari sebuah variabel disimpan. Contoh, ketika kita menggunakan operator  +  terhadap dua variabel yang bertipe String seperti berikut: fun main() {     val firstWord = ""Dicoding ""     val lastWord = ""Academy""     print(firstWord + lastWord) } /*    output: Dicoding Academy */ Maka kedua nilai dari variabel  firstWord  dan  lastWord  akan digabungkan menjadi satu nilai. Berbeda ketika kita menggunakan operator  +  pada variabel yang bertipe Int seperti berikut: fun main() {     val valueA: Int = 10     val valueB = 20     print(valueA + valueB) } /*    output: 30 */ Kompiler akan menjalankan operasi aritmatika, seperti pada contoh di atas di mana nilai dari variabel  valueA  dan  valueB  akan dijumlahkan lalu menghasilkan nilai baru.";Variabel adalah cara menyimpan informasi dalam program, menggunakan kata kunci var (bisa diubah) atau val (tidak bisa diubah). Struktur dasar: var/val identifier: Type = initialization. Kotlin mendukung type inference, memungkinkan penulisan tipe data secara otomatis. Tipe data utama meliputi String, Int, dan tipe lainnya. Operator + pada String akan menggabungkan nilai, sedangkan pada angka akan melakukan operasi matematika. Variabel memiliki empat komponen penting: kata kunci (var/val), identifier (nama), tipe data, dan inisialisasi nilai. Setiap variabel harus memiliki nama unik dalam satu ruang lingkup program.
"Ketika kita mengembangkan sebuah program kita pasti membutuhkan variabel dengan tipe data yang mampu menyimpan nilai berbentuk teks. Terdapat dua (2) tipe data yang bisa kita gunakan, yaitu  Char  dan  String . Char Characters direpresentasikan menggunakan tipe  Char . Untuk mendefinisikan sebuah variabel dengan tipe data Char kita bisa menggunakan tanda kutip tunggal  ( ' ' )  seperti berikut: val character = 'A' Tipe data Char hanya dapat kita gunakan untuk menyimpan karakter tunggal. Sebaliknya jika kita memasukkan lebih dari 1 (satu) karakter, akan terjadi eror: val character: Char = 'ABC' // Incorrect character literal Yang menarik, kita bisa melakukan operasi  increment  ( ++ ) dan  decrement  ( -- ) pada sebuah variabel dengan tipe data Char seperti berikut: fun main() {     var vocal = 'A'      println(""Vocal "" + vocal++)     println(""Vocal "" + vocal++)     println(""Vocal "" + vocal++)     println(""Vocal "" + vocal--)     println(""Vocal "" + vocal--)     println(""Vocal "" + vocal--)     println(""Vocal "" + vocal--) }  /*    output:        Vocal A        Vocal B        Vocal C        Vocal D        Vocal C        Vocal B        Vocal A */ Operasi  increment  dan  decrement  sendiri merupakan operasi yang bisa kita gunakan pada tipe data  Number . Lalu kenapa kita bisa menggunakannya pada tipe Char? Karena pada dasarnya setiap Characters merupakan representasi dari  Unicode . Contoh Unicode  A  adalah  0041.  Ketika kita melakukan  increment  maka hasilnya adalah  0042  yang mana merupakan Unicode dari  B .";Char dalam Kotlin adalah tipe data untuk menyimpan karakter tunggal, ditulis dengan tanda kutip tunggal seperti 'A'. Berbasis Unicode, Char memungkinkan operasi increment (++) dan decrement (--), yang mengubah karakter sesuai urutan Unicode. Setiap karakter memiliki kode unik, misalnya 'A' adalah 0041. Saat di-increment, 'A' berubah menjadi 'B' (0042). Char hanya dapat menyimpan satu karakter, sehingga penggunaan lebih dari satu karakter akan menghasilkan error. Tipe data ini berguna untuk manipulasi karakter individual dalam pemrograman Kotlin.
"String String merupakan tipe data yang mirip dengan Char. Ia dapat digunakan untuk menyimpan nilai berupa teks. Perbedaannya, String bisa menampung beberapa karakter di dalamnya. String direpresentasikan menggunakan tipe String. Nilai yang berada di dalam sebuah variabel dengan tipe data String merupakan kumpulan dari beberapa karakter. Kita bisa mendefinisikan variabel tersebut dengan tanda petik ganda ( "" "" ) seperti berikut: val textString  = ""Kotlin"" Pada dasarnya sekumpulan karakter dalam String tersebut berbentuk Array, sehingga kita bisa mendapatkan karakter tunggal dengan mudah. Caranya, manfaatkan  indexing  seperti berikut: fun main() {     val text  = ""Kotlin""     val firstChar = text[0]      print(""First character of $text is $firstChar"") }  /*   output : First character of Kotlin is K */ Apa itu Indexing? Indexing  merupakan sebuah cara yang memudahkan kita untuk mengakses  elemen  yang berada di dalam sebuah Collection dengan memanfaatkan  index  atau posisi dari elemen tersebut. Posisi dari sebuah elemen pada umumnya dimulai dari angka  0 . Untuk materi tentang Collection akan sama-sama kita pelajari pada sub-modul berikutnya. Semangat! Nilai  0  yang berada pada  indexing  di atas adalah posisi karakter yang akan diakses. Selain itu, kita juga dapat melakukan iterasi terhadap objek String dengan menggunakan  for-loop  seperti berikut: fun main() {     val text  = ""Kotlin""     for (char in text){         print(""$char "")     } }  /*   output : K o t l i n  */ Escaped String Kotlin memiliki dua jenis tipe  Literal String , yang pertama adalah  Escaped String  yang memungkinkan kita untuk mengurangi ambiguitas nilai yang berada di dalam sebuah String. Misalnya ketika kita mendefinisikan sebuah String berikut: val statement = ""Kotlin is Awesome!"" Kemudian kita ingin menambahkan tanda petik ganda di dalam sebuah String seperti berikut: val statement = ""Kotlin is ""Awesome!"""" Maka akan terjadi ambiguitas nilai pada variabel  statement  karena kompiler tidak dapat mengetahui akhir dari baris nilai untuk variabel  statement . Untuk mengatasinya, kita bisa melakukan  escaped  dengan menambahkan karakter  backslash  ( \ ) sebelum tanda petik ganda seperti berikut: val statement = ""Kotlin is \""Awesome!\"""" Selain  \”  di atas, terdapat beberapa karakter lain yang dapat digunakan untuk melakukan  escaped  di dalam sebuah String, antara lain:   \t : menambah tab ke dalam teks. \n : membuat baris baru di dalam teks. \’ : menambah karakter  single quote  kedalam teks. \” : menambah karakter  double quote  kedalam teks. \\ : menambah karakter  backslash  kedalam teks. Selain itu, kita juga bisa menambahkan sebuah  Unicode  ke dalam sebuah String seperti berikut: fun main() {     val name = ""Unicode test: \u00A9""     print(name) }  /*    output: Unicode test : © */ Raw String Kedua, adalah  Raw String  yang memungkinkan kita menuliskan  multiline  dan  arbitrary text . Ketika ingin membuat beberapa baris String biasanya kita melakukan  escaped  terhadap String dengan memanfaatkan karakter  escape   \n  seperti berikut: val line = ""Line 1\n"" +         ""Line 2\n"" +         ""Line 3\n"" +         ""Line 4\n"" Dengan Raw String, kita dapat membuatnya dengan cara yang lebih mudah yaitu seperti berikut: fun main() {     val line = """"""         Line 1         Line 2         Line 3         Line 4     """""".trimIndent()      print(line) }  /*     output:         Line 1         Line 2         Line 3         Line 4  */ Pada kode di atas, kita mendefinisikan sebuah Raw String menggunakan  triple quote  ( """""" """""" ). Raw String memungkinkan kita untuk membuat beberapa baris String tanpa penggabungan ( concatenation ) dan penggunaan karakter  escaped .";"String adalah tipe data untuk menyimpan teks yang dapat berisi beberapa karakter. Didefinisikan dengan tanda petik ganda, seperti ""Kotlin"". Mendukung indexing untuk mengakses karakter individual, misalnya text[0] mengambil karakter pertama. Dapat ditelusuri menggunakan for-loop. Memiliki dua jenis literal: Escaped String (menggunakan backslash untuk karakter khusus) dan Raw String (menggunakan triple quote untuk multiline). Escaped String memungkinkan penggunaan karakter khusus seperti \n (baris baru), \t (tab), sedangkan Raw String memudahkan penulisan teks multiline tanpa konkatenasi. Dukungan Unicode juga tersedia, memungkinkan penggunaan karakter khusus dalam string."
"Arrays Selanjutnya adalah Array, yakni tipe data yang memungkinkan kita untuk menyimpan beberapa objek di dalam sebuah variabel. Array di Kotlin direpresentasikan oleh kelas  Array  yang memiliki fungsi  get  dan  set  serta properti  size . Untuk membuat sebuah Array kita bisa memanfaatkan sebuah library function  arrayOf()  seperti berikut: val array = arrayOf(1, 3, 5, 7) Kita juga dapat memasukkan nilai dengan berbagai jenis tipe data ke dalam  arrayOf()  misalnya: val mixArray = arrayOf(1, 3, 5, 7 , ""Dicoding"" , true) Kotlin juga memungkinkan kita untuk membuat Array dengan tipe data primitif dengan memanfaatkan beberapa fungsi spesifik berikut: intArrayOf() : IntArray booleanArrayOf() : BooleanArray charArrayOf() : CharArray longArrayOf() : LongArray shortArrayOf() : ShortArray byteArrayOf() : ByteArray Jika kita ingin membuat Array yang hanya bisa dimasukkan nilai dengan tipe data  Int,  gunakan  intArrayOf() , misalnya:  val intArray = intArrayOf(1, 3, 5, 7) Kita juga bisa mendapatkan nilai tunggal dari sekumpulan nilai yang berada di dalam sebuah Array dengan memanfaatkan  indexing  seperti berikut: fun main() {     val intArray = intArrayOf(1, 3, 5, 7)     print(intArray[2]) }  /*    Output: 5 */ Nilai  2  pada kode di atas merupakan indeks atau posisi dari nilai tunggal yang ingin kita dapatkan. Perlu diketahui bahwa sebuah indeks selalu dimulai dari  0 . Selain mendapatkan nilai tunggal, dengan  indexing  kita juga bisa mengubah nilai tunggal tersebut. Sebagai contoh: fun main() {     val intArray = intArrayOf(1, 3, 5, 7)  // [1, 3, 5, 7]     intArray[2] = 11                       // [1, 3, 11, 7]      print(intArray[2]) }  /*    Output: 11 */";"Array adalah tipe data untuk menyimpan kumpulan objek dalam satu variabel. Dapat dibuat menggunakan fungsi arrayOf() yang mendukung berbagai tipe data, seperti arrayOf(1, 3, 5, 7) atau campuran arrayOf(1, ""Dicoding"", true). Kotlin menyediakan fungsi khusus untuk array tipe primitif: intArrayOf(), booleanArrayOf(), charArrayOf(), dll. Akses elemen array menggunakan indexing, dimulai dari indeks 0. Contohnya, intArray[2] mengambil elemen ketiga. Array dapat dimodifikasi dengan mengubah nilai pada indeks tertentu. Fleksibel dan powerful untuk menyimpan koleksi data dengan tipe seragam atau beragam."
"Functions Function atau fungsi merupakan sebuah prosedur yang memiliki keterkaitan dengan pesan dan objek. Ketika kita memanggil sebuah fungsi maka sebuah  mini-program  akan dijalankan. Fungsi sendiri bisa diartikan sebagai cara sederhana untuk mengatur program buatan kita. Sebuah fungsi dapat kita gunakan untuk mengembalikan nilai. Pemanggilan sebuah fungsi sendiri, bisa diberi argumen atau tidak. Pada sub-modul ini kita akan belajar bagaimana membuat sebuah fungsi pada Kotlin dan mencoba beberapa poin di atas. fun functionName(param1: Type1, param2: Type2, ...): ReturnType {     return result } Pendeklarasian fungsi pada Kotlin diawali dengan kata kunci  fun  kemudian dilanjutkan dengan nama fungsi yang dikehendaki. Selanjutnya adalah parameter yang berada pada fungsi yang dideklarasikan. Awali dengan nama parameter dan ikuti dengan tipe parameter itu sendiri yang dipisahkan oleh karakter colon ( : ). Setiap parameter yang berada pada sebuah fungsi dipisahkan oleh karakter koma dan berada di dalam tanda kurung.  fun setUser(name: String, age: Int) Setelah menentukan nama dan parameter, selanjutnya adalah menentukan tipe kembalian dari fungsi yang dibuat. Perlu diketahui fungsi pada Kotlin selalu mengembalikan nilai. Tipe kembalian adalah nilai yang akan dikembalikan ketika fungsi tersebut dipanggil. fun setUser(name: String, age: Int):  String Fungsi di atas akan mengembalikan nilai berupa String. Setelah menentukan tipe nilai kembalian, barulah kita menentukan  function body  di mana di dalamnya terdapat  expression  atau  statement  untuk dijalankan.  Function body  berada di dalam  curly braces  ( {} ) setelah tipe nilai kembalian. fun setUser(name: String, age: Int): String  {       return ""Your name is $name, and you $age years old""  } Nilai yang akan dikembalikan diikuti oleh kata kunci  return . Jika di dalam suatu fungsi hanya memiliki satu  expression  untuk menentukan nilai kembalian, maka fungsi tersebut bisa diubah menjadi  expression body . Kita hanya perlu menambahkan tanda  =  dan menuliskannya seperti berikut: fun setUser(name: String, age: Int): String  =  ""Your name is $name, and you $age years old"" Dengan  expression body , kompiler dapat menentukan tipe kembalian dari fungsi yang dibuat. Sehingga kita tidak perlu menentukan tipe nilai kembalian secara eksplisit: fun setUser(name: String, age: Int) = ""Your name is $name, and you $age years old"" Jika kita tidak ingin fungsi yang dibuat mengembalikan nilai, kita bisa menggunakan  Unit  sebagai tipe nilai kembaliannya. Contohnya seperti berikut: fun printUser(name: String):  Unit  {     print(""Your name is $name"") } Ketika menggunakan tipe kembalian  Unit , Kotlin memungkinkan kita untuk menghilangkannya. Kenapa demikian? Kompiler akan mendeteksinya sebagai tipe kembalian yang  redundant : fun printUser(name: String) {     print(""Your name is $name"") } Pemanggilan fungsi, bisa dilakukan dengan pendekatan tradisional seperti berikut: fun main() {     val user = setUser(""Alfian"", 19)     println(user)      printUser(""Alfian"") }  fun setUser(name: String, age: Int) = ""Your name is $name, and you $age years old""  fun printUser(name: String) {     println(""Your name is $name"") }  /* output : Your name is Alfian, and you 19 years old Your name is Alfian */";Fungsi adalah blok kode yang dapat dipanggil untuk menjalankan tugas tertentu. Dideklarasikan menggunakan kata kunci 'fun', diikuti nama fungsi, parameter, dan tipe kembalian. Contoh: fun setUser(name: String, age: Int): String. Fungsi dapat memiliki body lengkap dengan kurung kurawal atau expression body menggunakan tanda '='. Tipe kembalian Unit digunakan untuk fungsi tanpa nilai balik. Pemanggilan fungsi dilakukan dengan menyebutkan nama dan memberikan argumen sesuai parameter. Fungsi memungkinkan pengorganisasian kode, modularitas, dan pengulangan tugas dengan mudah. Kotlin mendukung deklarasi fungsi yang ringkas dan fleksibel.
"If Expressions Saat mengembangkan sebuah program, kita pasti bertemu dengan alur program yang perlu sebuah kondisi untuk menjalankan sebuah  statement  atau  expression . Contoh ketika kita ingin menginisialisasi nilai dari sebuah variabel berdasarkan suatu kondisi. Untuk menyelesaikannya, gunakan  If Expression . If expression direpresentasikan dengan kata kunci  if . If akan kita perlukan untuk menyelesaikan kasus di atas, dimana if akan digunakan untuk menguji suatu kondisi untuk menjalankan sebuah proses. If akan mengeksekusi sebuah  statement  atau  expression  jika hasil evaluasi dari  expressions  yang diberikan pada blok if bernilai  true . Sebaliknya, jika bernilai  false  maka proses yang ditentukan akan dilewatkan. val openHours = 7 val now = 20 if (now > openHours){     println(""office already open"") } Kode di atas adalah contoh sederhana penggunaan if dengan memanfaatkan operator  greater than  untuk membandingkan nilai. Jika if digunakan untuk mengembalikan nilai atau menetapkan nilai dari sebuah variabel maka if wajib memiliki  branch   else . Contohnya seperti berikut: val openHours = 7 val now = 20 val office: String if (now > openHours) {     office = ""Office already open"" } else {     office = ""Office is closed"" }  print(office) Else akan dijalankan jika hasil evaluasi pada  expression  yang diberikan menghasilkan nilai  false . If merupakan sebuah  expressions  yang dapat mengembalikan nilai, sehingga kita dapat menyimpan hasilnya ke dalam sebuah variabel. val openHours = 7 val now = 20 val office: String office = if (now > openHours) {     ""Office already open"" } else {     ""Office is closed"" }  print(office) Pada kode di atas, kita hanya menggunakan If untuk menguji 2 (dua) kondisi. Lalu bagaimana jika kita memiliki beberapa kondisi? Kita bisa menggabungkan  else  dan  if  seperti berikut: val openHours = 7 val now = 7 val office: String office = if (now > 7) {     ""Office already open"" } else if (now == openHours){     ""Wait a minute, office will be open"" } else {     ""Office is closed"" }  print(office) Blok  else if  akan dijalankan jika hasil evaluasi pada  branch  sebelumnya bernilai  false . Jika hasil evaluasi pada  branch   else if  juga bernilai nilai  false , maka lanjut ke evaluasi  branch  selanjutnya. Perlu diketahui bahwa Kotlin tidak mendukung  ternary operator  ( condition ? then : else ), karena peran dari operator tersebut sudah digantikan dengan if expressions.";If Expressions di Kotlin adalah struktur kontrol untuk menjalankan kode berdasarkan kondisi tertentu. Menggunakan kata kunci 'if', memungkinkan pengujian kondisi dengan sintaks sederhana: if (kondisi) { kode } else { kode }. Dapat mengembalikan nilai dan mendukung multiple kondisi dengan else if. Berbeda dengan bahasa lain, Kotlin memperlakukan if sebagai expression, bukan sekadar statement, sehingga bisa langsung menetapkan nilai variabel. Fleksibel, mudah dibaca, dan menggantikan kebutuhan ternary operator tradisional.
"Pada sub-modul sebelumnya kita telah belajar tentang  I f expressions  yang menggunakan  Boolean expressions . Kini saatnya kita belajar apa itu  Boolean?  Boolean adalah sebuah tipe data yang hanya memiliki dua nilai, yaitu  true  dan  false . Terdapat 3 (tiga) operator yang dapat digunakan pada Boolean. Conjunction atau AND (&&) Operator AND (&&) akan mengembalikan nilai  true  jika semua hasil evaluasi  expression  yang diberikan bernilai  true . fun main() {     val officeOpen = 7     val officeClosed = 16     val now = 20      val isOpen = if (now >= officeOpen && now <= officeClosed){         true     } else {         false     }      print(""Office is open : $isOpen"")      /*         Output : Office is open : false      */ } Fungsi di atas menguji apakah jam sekarang berada di antara jam waktu buka kantor dan jam tutup kantor. If expressions di atas bisa Anda sederhanakan jadi seperti berikut: fun main() {     val officeOpen = 7     val officeClosed = 16     val now = 20      val isOpen = now >= officeOpen && now <= officeClosed      print(""Office is open : $isOpen"")     /*         Output : Office is open : false      */ } Disjunction atau OR (||) Berbeda dengan operator AND (&&), operator OR (||) akan mengembalikan nilai  true  jika hasil evaluasi dari salah satu  expressions  yang diberikan bernilai  true . fun main() {     val officeOpen = 7     val officeClosed = 16     val now = 20      val isClose = now < officeOpen || now > officeClosed      print(""Office is closed : $isClose"")     /*         Output : Office is closed : true      */ } Variabel  isClose  di atas bernilai  true.  Alasannya, hasil evaluasi salah satu  expression  yang diberikan, bernilai  true , yaitu  expression  disebelah kanan. Negation atau NOT (!)  Berbeda dengan operator AND (&&) dan operator OR(||), operator NOT(!) digunakan untuk melakukan negasi pada hasil evaluasi  expression  yang diberikan. Contoh, Jika hasil  expressions  setelah dievaluasi bernilai true, maka operator NOT akan mengembalikan nilai  false . fun main() {     val officeOpen = 7     val now = 10     val isOpen = now > officeOpen      if (!isOpen) {         print(""Office is closed"")     } else {         print(""Office is open"")     }      /*         Output : Office is open      */ } Hasil evaluasi  expression  di atas adalah  true.  Tapi ketika menggunakan operator NOT maka akan dinegasikan menjadi nilai  false . Sehingga statement pada  branch   else -lah yang akan dijalankan.";Boolean dalam Kotlin adalah tipe data dengan dua nilai: true dan false. Menggunakan tiga operator utama: AND (&&) yang mengembalikan true jika semua kondisi true, OR (||) yang mengembalikan true jika salah satu kondisi true, dan NOT (!) yang membalik nilai boolean. Operator ini memungkinkan kombinasi dan pemeriksaan kondisi kompleks dalam ekspresi logika, membantu pengambilan keputusan dalam program dengan cara ringkas dan jelas, mendukung logika pemrograman yang efisien dan mudah dibaca.
"Numbers Pada sub-modul tipe data kita sudah mempelajari tentang beberapa tipe seperti  Character  dan  String  . Sekarang kita akan mempelajari beberapa tipe data yang termasuk ke dalam tipe  Number . Number adalah sebuah tipe data yang khusus digunakan untuk menyimpan nilai dalam bentuk numerik. Di Kotlin, tipe data Number disimpan dengan cara yang berbeda. Beberapa tipe bawaan yang merepresentasikan Numbers adalah  Double ,  Long ,  Int ,  Short  dan  Byte . Setiap tipe data Number memiliki ukuran (satuan Bit) berbeda-beda, tergantung besaran nilai yang dapat simpan. Int (32 Bit) Int adalah tipe data yang umumnya digunakan untuk menyimpan nilai numerik. Int dapat menyimpan data dari  range  -2^31 sampai +2^31-1. Dengan ukuran 32 Bit kita bisa menggunakannya untuk menyimpan nilai yang besar. Catatannya, tetap lihatlah batasan nilai maksimal yang dapat dimasukkan. val intNumber = 100 Long (64 Bit) Long adalah tipe data yang digunakan untuk menyimpan nilai numerik yang lebih besar yaitu dari  range  -2^63 sampai +2^63-1. Long bisa didefinisikan secara eksplisit: val longNumber: Long = 100 Atau dengan menambahkan  suffix   L  seperti berikut: val longNumber = 100L Short (16 Bit) Short merupakan sebuah bilangan bulat yang hanya dapat menyimpan nilai yang kecil karena hanya berukuran 16 Bit. val shortNumber: Short = 10 Byte (8 Bit) Dengan ukuran yang kecil, Byte hanya mampu menyimpan nilai yang kecil sama halnya seperti Short. Byte biasa digunakan untuk keperluan proses membaca dan menulis data dari sebuah  stream file  atau jaringan. val byteNumber = 0b11010010 Double (64 Bit) Sama halnya dengan Long yang memiliki ukuran yang besar, Double mampu menyimpan nilai numerik yang besar pula. Pada umumnya Double digunakan untuk menyimpan nilai numerik pecahan sampai dengan maksimal 15-16 angka di belakang koma. val doubleNumber: Double = 1.3 Float (32 Bit) Sama seperti Double, namun memiliki ukuran yang lebih kecil, yakni hanya sampai 6-7 angka di belakang koma. val floatNumber: Float = 0.123456789f //yang terbaca hanya 0.1234567 Untuk mengetahui nilai maksimal yang dapat disimpan oleh suatu tipe Number, kita bisa menggunakan properti  MAX_VALUE.   Sementara untuk mengetahui nilai minimal yang dapat disimpan, gunakan properti  MIN_VALUE.     fun main() {     val maxInt = Int.MAX_VALUE     val minInt = Int.MIN_VALUE      println(maxInt)     println(minInt)      /*      output :             2147483647             -2147483648      */ } Jika kita memasukan nilai melebihi nilai maksimal yang dapat disimpan, maka akan terjadi  overflow.  Nilai yang akan dikembalikan adalah nilai minimal yang dapat disimpan. fun main() {     val maxInt = Int.MAX_VALUE     val overRangeInt = Int.MAX_VALUE + 1 // This operation has led to an overflow      println(""Max Int: $maxInt"")     println(""Over range Int: $overRangeInt"") }  /* Output :  Max Int: 2147483647 Over range Int: -2147483648 */ Terdapat beberapa operator matematika pada tipe data Number seperti penjumlahan ( + ), pengurangan ( - ), perkalian ( * ) , pembagian ( / ) dan modulus ( % , atau sisa hasil bagi). // main function fun main() {     val numberOne = 1     val numberTwo = 2      print(numberOne + numberTwo)     /*         output : 3      */ } Perlu diketahui, hasil operasi pembagian pada tipe data Int akan dibulatkan kebawah. Contohnya seperti berikut: // main function fun main() {     val numberOne: Int = 27     val numberTwo: Int = 10      print(numberOne / numberTwo)     /*         output : 2      */ } Sama seperti perhitungan matematika di mana operasi perkalian dan pembagian didahulukan, demikian halnya perhitungan pada Kotlin. fun main() {     print(5 + 4 * 4)     /*      output: 21      */ } Operasi  4 * 4  akan dilakukan terlebih dahulu, kemudian diikuti  5 + 16 . Jika ingin operasi  5 + 4  dilakukan terlebih dahulu, gunakan tanda kurung: fun main() {     print((5 + 4) * 4)     /*      output: 36      */ } Di Kotlin kita tidak bisa melakukan konversi secara langsung. Contoh, ketika ingin melakukan konversi dari tipe data Byte ke tipe data Int. fun main() {    val byteNumber: Byte = 1    val intNumber: Int = byteNumber // compile error } Kode akan gagal dikompilasi dengan log eror berikut: Error:(4, 18) Kotlin: Type mismatch: inferred type is Byte but Int was expected Untuk mengatasinya, lakukan konversi dengan bantuan beberapa fungsi seperti  toInt()  berikut: fun main() {     val byteNumber: Byte = 10     val intNumber: Int = byteNumber.toInt() // ready to go } Kode di atas menggunakan fungsi  toInt()  untuk melakukan konversi secara eksplisit dari tipe data Byte ke tipe data Int. Adapun beberapa fungsi konversi yang dapat kita gunakan antara lain: toByte(): Byte toShort(): Short toInt(): Int toLong(): Long toFloat(): Float toDouble(): Double toChar(): Char Contoh lain penggunaan konversi adalah sebagai berikut: fun main() {     val stringNumber = ""23""     val intNumber = 3      print(intNumber + stringNumber.toInt())     /*      output: 26      */ } Dengan fungsi konversi di atas, nilai  23  yang semula bertipe String di konversi ke tipe Int yang kemudian dimasukan ke dalam operasi matematika. Dengan Kotlin kita juga bisa menuliskan nilai numerik yang “ readable ” dengan menggunakan tanda  underscores  seperti berikut: fun main() {     val readableNumber = 1_000_000     print(readableNumber)      /*      output : 1000000      */ }";Numbers adalah tipe data numerik dengan berbagai jenis: Int (32-bit), Long (64-bit), Short (16-bit), Byte (8-bit), Double (64-bit floating point), dan Float (32-bit floating point). Setiap tipe memiliki range nilai berbeda. Mendukung operasi matematika dasar (+, -, *, /, %) dengan aturan prioritas perhitungan. Konversi antar tipe dilakukan menggunakan fungsi khusus seperti toInt(), toLong(). Kotlin memungkinkan penulisan angka yang mudah dibaca dengan underscore, memudahkan pembacaan angka besar.
Ketika mengembangkan sebuah program, ada satu hal yang tak boleh kita abaikan. Ia adalah  NullPointerException (NPE) , sebuah kesalahan yang terjadi saat ingin mengakses atau mengelola nilai dari sebuah variabel yang belum diinisialisasi atau variabel yang bernilai  null . Karena sangat umum terjadi dan bisa berakibat fatal,  NPE  terkenal dengan istilah  “The Billion Dollar Mistake” . Dalam penanganannya, kita harus berhati-hati karena NPE menyebabkan aplikasi yang kita kembangkan, rusak saat dijalankan. Pada Kotlin kita dimudahkan untuk mengelola variabel  nullable  sehingga dapat meminimalisir terjadinya  NullPointerException . Kotlin hadir dengan penanganan  n ullability  yang mudah. Kotlin mampu membedakan objek yang boleh bernilai  null  dan objek yang tidak boleh bernilai null pada saat objek tersebut dibuat.  val text: String = null // compile time error Kotlin akan memaksa kita untuk menentukan nilai awal dari sebuah objek ketika dibuat dan tidak boleh bernilai  null . Jika  ingin sebuah objek bisa bernilai  null , kita bisa menambahkan tanda  ?  setelah menentukan tipe dari objek tersebut: val text: String? = null // ready to go Namun kita tidak bisa langsung mengakses atau mengelola nilai dari objek yang sudah kita tandai sebagai  nullable . Sebagai contoh: val text: String? = null val textLength = text.length // compile time error Ketika kita menuliskan kode di atas, maka akan gagal dikompilasi dengan log eror berikut: Error:(4, 26) Kotlin: Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type String? Lalu bagaimana cara kita mengakses atau mengelola nilai dari objek yang ditandai sebagai  nullable ? Cara mudahnya, periksa objek tersebut apakah bernilai  null  atau tidak:  val text: String? = null  //val textLength = text.length // compile time error  if (text != null){     val textLength = text.length // ready to go } Dengan cara tradisional menggunakan  if/else  seperti di atas, kompiler akan mengizinkan kita untuk mengelola nilai dari sebuah variabel yang kita tandai sebagai  nullable . Pada sub-modul selanjutnya kita akan mempelajari penanganan objek yang ditandai sebagai  nullable  dengan cara yang lebih mudah. Kita akan menggunakan  Safe Calls  dan  Elvis Operator  di Kotlin.;"Kotlin menangani NullPointerException dengan konsep nullability, membedakan variabel yang bisa null dan tidak bisa null. Variabel non-nullable tidak dapat diassign null, sedangkan variabel nullable ditandai dengan tanda tanya (?). Untuk mengakses variabel nullable, harus dilakukan pengecekan null terlebih dahulu menggunakan if-else atau metode safe call. Tujuannya mencegah terjadinya NullPointerException yang dikenal sebagai ""The Billion Dollar Mistake"". Kotlin memaksa pengembang untuk secara eksplisit menangani kemungkinan null pada variabel."
Di sub-modul sebelumnya kita sudah mengenal tentang  NullPointerException  dan cara penanganannya. Kini kita akan belajar bagaimana menangani objek  nullable  dengan cara yang lebih mudah, yaitu menggunakan  Safe Calls  dan  Elvis Operator . Safe calls operator (?.) Yang pertama akan kita pelajari adalah  Safe Calls . Seperti namanya, safe call akan menjamin kode yang kita tulis aman dari  NullPointerException . Dalam menggunakan safe call, kita akan mengganti tanda titik ( . ) dengan tanda ( ?. ) saat mengakses atau mengelola nilai dari objek  nullable.  Seperti ini:  val text: String? = null text?.length Dengan safe call, kompiler akan melewatkan proses jika objek tersebut bernilai  null . Elvis Operator (?:) Elvis operator  memungkinkan kita untuk menetapkan  default value  atau nilai dasar jika objek bernilai  null . val text: String? = null val textLength = text?.length ?: 7 Kode di atas sebenarnya sama seperti ketika kita menggunakan  if/else  berikut: val textLength = if (text != null) text.length else 7 Elvis akan mengembalikan nilai  text.length  jika  text  tidak bernilai  null.  Sebaliknya, jika  text  bernilai  null  maka  default value  yang akan dikembalikan. Sebelum lanjut ke sub-modul selanjutnya terdapat satu hal yang perlu diperhatikan dalam penanganan objek  nullable . Perhatikan penggunaan operator  non-null assertion  ( !! ), misalnya seperti berikut: val text: String? = null val textLength = text!!.length // ready to go ??? Dengan menggunakan  non-null assertion  kompiler akan mengizinkan kita untuk mengakses atau mengelola nilai dari sebuah objek  nullable . Namun penggunaan operator tersebut sangat tidak disarankan karena akan memaksa sebuah objek menjadi  non-null.  Sehingga ketika objek tersebut bernilai  null , Anda tetap akan berjumpa dengan  NullPointerException .;Safe Calls (?.) memungkinkan akses aman pada variabel nullable dengan mengganti titik (.) dengan (?.), sehingga kompiler akan melewatkan proses jika objek bernilai null. Elvis Operator (?:) menetapkan default value jika objek null, mirip penggunaan if-else. Contoh: val textLength = text?.length ?: 7. Non-null assertion (!!) tidak direkomendasikan karena memaksa objek non-null dan berpotensi menimbulkan NullPointerException. Kedua operator ini membantu mengelola variabel nullable secara lebih ringkas dan aman, mengurangi risiko error pada saat runtime.
"String Template Di beberapa sub-modul sebelumnya Anda sudah melihat bagaimana sebuah String ditulis seperti berikut: ""First character of $text is $firstChar"" Lantas dinamakan apakah mekanisme penulisan String seperti di atas? Kotlin mendukung sebuah fitur bernama  String Template . Sebuah fitur yang memungkinkan kita untuk menyisipkan sebuah variabel ke dalam sebuah String tanpa  concatenation  (penggabungan objek String menggunakan  + ) seperti berikut: fun main() {     val name = ""Kotlin""     print(""My name is "" + name) } /*    output : My name is Kotlin */ Untuk menggunakan string template, kita hanya perlu menambahkan karakter  $  sebelum nama variabel yang akan disisipkan seperti berikut: fun main() {     val name = ""Kotlin""     print(""My name is $name"") } /*    output : My name is Kotlin */ Variabel yang dapat disisipkan tidak sebatas String. Kita juga bisa menyisipkan objek lain misal  Int  atau  Double  seperti berikut: fun main() {     val name = ""Kotlin""     val old = 3     print(""My name is $name, im $old years old"") } /*    output : My name is Kotlin, im 3 years old */ Tidak hanya sampai disitu, Anda juga bisa menyisipkan sebuah  expression  ke dalam sebuah string template. Caranya, sisipkan  expression  ke dalam  curly braces  yang diikuti karakter  $ . fun main() {     val hour = 7     print(""Office ${if (hour > 7) ""already close"" else ""is open""}"") } /*    output : Office is open */ Dengan string template, kita lebih mudah membuat objek String yang dinamis.";String Template di Kotlin adalah fitur canggih untuk menyisipkan variabel atau ekspresi langsung ke dalam string menggunakan karakter $ (dollar). Memungkinkan pengembang membuat string dinamis dengan mudah tanpa concatenation, mendukung berbagai tipe data dan ekspresi kompleks. Cukup tambahkan $ sebelum variabel atau gunakan ${expression} untuk menyisipkan nilai, membuat kode lebih ringkas, mudah dibaca, dan ekspresif dibandingkan metode tradisional penggabungan string.
Kita telah belajar mengenai  If Expression  pada sub-modul sebelumnya. If Expression merupakan salah satu bagian dari  Control Flow . Pada sub-modul ini kita akan mempelajari tentang apa itu control flow dan juga beberapa bagian lain yang ada di dalamnya. Apa itu Control Flow? Ketika kita mengembangkan sebuah program, tentu kita harus tahu seperti apa alurnya. Control flow adalah cara kita mengontrol alur dari sebuah program berdasarkan kondisi saat program tersebut berjalan. Terdapat beberapa bagian dari control flow yang akan kita pelajari, antara lain: When Expression Expression & Statement While and Do While Range and For Loop Break and Continue Labels Kita akan mempelajari seperti apa dan bagaimana cara menerapkan beberapa control flow di atas.;Control Flow di Kotlin adalah mekanisme pengaturan alur program melalui struktur kendali yang memungkinkan programmer mengendalikan eksekusi kode berdasarkan kondisi tertentu. Mencakup berbagai metode seperti percabangan (if, when), perulangan (while, for), dan pengendali alur (break, continue) untuk membuat algoritma lebih dinamis, fleksibel, dan responsif terhadap berbagai skenario pemrograman.
"Enumeration Enumeration merupakan salah satu fitur yang bisa kita gunakan untuk menyimpan kumpulan objek yang telah didefinisikan menjadi tipe data konstanta. Enumeration dapat ditetapkan sebagai nilai ke dalam sebuah variabel dengan cara yang lebih efisien. Selain itu, Enumeration juga dapat digunakan untuk meminimalisir kesalahan dalam pengetikan nilai sebuah variabel, misalnya: val colorRed = 0xFF0000 val colorGreen = 0x00FF00 val colorBlue = 0x0000FF Nilai dari beberapa variabel di atas berpotensi salah atau tertukar dengan nilai variabel lain. Untuk meminimalisir kesalahan, kita memerlukan Enumeration. Anda bisa melakukannya seperti ini:  fun main() {     val colorRed = Color.RED     val colorGreen = Color.GREEN     val colorBlue = Color.BLUE }  enum class Color(val value: Int) {     RED(0xFF0000),     GREEN(0x00FF00),     BLUE(0x0000FF) } Selain meminimalisir terjadinya kesalahan pengetikan, Enumeration juga membuat kode yang kita tulis jadi lebih bersih dan mudah dibaca. Untuk mendefinisikan sebuah kelas  Enum , kita bisa menggunakan kata kunci  enum  dan setiap objek yang berada di dalamnya dipisahkan oleh karakter koma ( , ). Selain itu, objek yang berada di dalam Enum secara implisit bersifat  static  dan  final  sehingga kita tidak dapat mengubahnya setelah dideklarasikan. Berikut contoh implementasi yang paling mendasar dari sebuah Enum: enum class Color{     RED, GREEN, BLUE } Objek yang telah didefinisikan menjadi tipe data  Enum  dapat mengakses  attribute  atau  method  di dalam kelas  Enum  itu sendiri. Konsep ini sama halnya seperti Array. Bedanya, Enum berbentuk  constant . Berikut contoh ketika kita ingin mengakses objek yang berada di dalam kelas  Enum : fun main() {     val color : Color = Color.RED     print(color) }  enum class Color{     RED, GREEN, BLUE }  /*    output: RED */ Seperti yang dicontohkan di awal, setiap objek yang dideklarasikan merupakan  instance  dari kelas  Enum  tersebut. Kita bisa menginisialisasinya seperti berikut: enum class Color(val value: Int) {     RED(0xFF0000),     GREEN(0x00FF00),     BLUE(0x0000FF) } Selain itu, kita juga dapat menambahkan perintah yang lebih spesifik dengan menambahkan abstract function dan mendeklarasikan  anonymous class  untuk setiap objek Enum, misalnya:  enum class Color(val value: Int) {     RED(0xFF0000) {         override fun printValue() {             println(""value of RED is $value"")         }     } ,     GREEN(0x00FF00) {         override fun printValue() {             println(""value of GREEN is $value"")         }     } ,     BLUE(0x0000FF) {         override fun printValue() {             println(""value of BLUE is $value"")         }     } ;       abstract fun printValue()  } Catatan: Konsep tentang abstract dan anonymous class akan dijelaskan pada modul selanjutnya. Setiap  enum class  memiliki sebuah  synthetic method  yang memungkinkan kita mendapatkan daftar objek Enum dan nama dari tiap Enum itu sendiri. fun main() {     val colors: Array<Color> = Color.values()     colors.forEach { color ->         print(""$color "")     } }   enum class Color(val value: Int) {     RED(0xFF0000),     GREEN(0x00FF00),     BLUE(0x0000FF) }  /*    output : RED GREEN BLUE  */ Perhatikan. Untuk mendapatkan daftar objek Enum kita bisa menggunakan fungsi  values() . Sedangkan untuk mendapatkan nama dari objek Enum kita bisa menggunakan fungsi  valueOf()  seperti berikut: fun main() {     val color: Color = Color.valueOf(""RED"")     println(""Color is $ color "")     println(""Color value is ${ color.value .toString(16)}"") }  enum class Color(val  value : Int) {     RED(0xFF0000),     GREEN(0x00FF00),     BLUE(0x0000FF) }  /*    output :     Color is RED    Color value is ff0000 */ Anda juga bisa mendapatkan property yang di dalam class Color seperti contoh  value  pada kode di atas dengan cara  color.value . Khusus pada kasus di atas, kita menambahkan toString(16) untuk menampilkan angka yang berupa HexaDesimal. Saat menggunakan fungsi  valueOf()  , perhatikan argumen yang kita masukkan ke dalam fungsi tersebut. Jika argumen yang kita masukan tidak sama dengan salah satu objek enum maka akan terjadi kesalahan  IllegalArgumentException . Apa itu IllegalArgumentException? IllegalArgumentException  adalah sebuah kondisi di mana saat ingin menggunakan sebuah fungsi, kita menyematkan argumen yang tidak sesuai ke dalam fungsi tersebut  [4] . Selain menggunakan fungsi  values()  dan fungsi  valueOf() , kita bisa mendapatkan daftar objek Enum dan nama dari objek Enum dengan cara yang lebih umum. Caranya, gunakan fungsi  enumValues()  dan fungsi  enumValueOf() . Contoh penggunaan kedua fungsi tersebut adalah sebagai berikut: fun main() {     val colors: Array<Color> = enumValues()     colors.forEach {color ->         println(color)     }      val color: Color = enumValueOf(""RED"")     println(""Color is $color"") }  enum class Color(val value: Int) {     RED(0xFF0000),     GREEN(0x00FF00),     BLUE(0x0000FF) }  /*    output :        RED        GREEN        BLUE        Color is RED  */ Konsep dari Enumeration sendiri sama seperti Array. Oleh karena itu, selain mendapatkan daftar dan nama dari tiap objek Enum, kita juga bisa mendapatkan posisi tiap objek menggunakan properti  ordinal  seperti berikut: fun main() {     val color: Color = Color.GREEN      print(""Position GREEN is ${color.ordinal}"") }  enum class Color(val value: Int) {     RED(0xFF0000),     GREEN(0x00FF00),     BLUE(0x0000FF) }  /*    output : Position GREEN is 1  */ Di atas telah disebutkan bahwa setiap objek merupakan instance dari  enum class  yang kita definisikan. Lantas bagaimana cara kita mengecek  instance  dari Enum itu sendiri? Nah, untuk mengeceknya, gunakan  When Expression  seperti berikut: fun main() {     val color: Color = Color.GREEN      when(color){         Color.RED -> print(""Color is Red"")         Color.BLUE -> print(""Color is Blue"")         Color.GREEN -> print(""Color is Green"")     } }  enum class Color(val value: Int) {     RED(0xFF0000),     GREEN(0x00FF00),     BLUE(0x0000FF) }  /*    output : Color is Green  */ Ketika menggunakan  when  untuk mengecek  instance  dari Enum, lebih baik masukkan setiap objek Enum yang kita definisikan. Jika kita melewatkan salah satu objek,  peringatan berikut akan muncul:  ‘when' expression on enum is recommended to be exhaustive";Enumeration di Kotlin adalah fitur untuk mendefinisikan kumpulan objek konstan dengan tipe data khusus, membantu mengurangi kesalahan pengetikan dan membuat kode lebih terstruktur. Enum class dapat memiliki konstruktor, properti, dan metode, serta mendukung berbagai operasi seperti values(), valueOf(), dan ordinal. Setiap objek enum bersifat statis dan final, memungkinkan penggunaan yang fleksibel dalam berbagai skenario pemrograman untuk representasi data konstan.
"When Expressions Untuk menentukan  statement  atau  expression  kita menggunakan  If Expression.   Selain itu kita juga bisa gunakan   When Expression,   yakni mekanisme yang memungkinkan nilai dari sebuah variabel/ expression,  mampu mengubah alur program. Contoh sederhana dalam penggunaan when expression adalah seperti berikut: fun main() {     val value = 7      when(value){         6 -> println(""value is 6"")         7 -> println(""value is 7"")         8 -> println(""value is 8"")     } }  /*    output: value is 7 */ when  akan mencocokan semua argumen yang berada di setiap  branch  secara berurutan sampai salah satu kondisi terpenuhi. Di dalam  when  kita juga bisa menambahkan  branch   else  seperti berikut: fun main() {     val value = 20      when(value){         6 -> println(""value is 6"")         7 -> println(""value is 7"")         8 -> println(""value is 8"")         else -> println(""value cannot be reached"")     } }  /*    output: value cannot be reached */ else  akan dievaluasi jika tiada satupun kondisi yang terpenuhi pada  branch  sebelumnya. Sama halnya seperti if expression, when expression dapat mengembalikan nilai dan dapat disimpan di dalam sebuah variabel seperti berikut: fun main() {     val value = 7     val stringOfValue = when (value) {         6 -> ""value is 6""         7 -> ""value is 7""         8 -> ""value is 8""         else -> ""value cannot be reached""     }      println(stringOfValue) }  /*    output : value is 7 */ else  adalah hal wajib jika kita menggunakan when expression untuk mengembalikan nilai. Bagaimana jika kita melewatkannya? Akan tampil eror berikut: 'when' expression must be exhaustive, add necessary 'else' branch Jika kita memiliki dua atau lebih baris kode yang akan kita jalankan di setiap  branch , kita bisa memindahkannya ke dalam  curly braces  seperti berikut: fun main() {     val value = 7     val stringOfValue = when (value) {         6 -> {             println(""Six"")             ""value is 6""         }         7 -> {             println(""Seven"")             ""value is 7""         }         8 -> {             println(""Eight"")             ""value is 8""         }         else -> {             println(""undefined"")             ""value cannot be reached""         }     }      println(stringOfValue) }  /*    output :              Seven             value is 7  */ when  juga memungkinkan kita untuk memeriksa  instance  dengan tipe tertentu dari sebuah objek menggunakan  is  atau  !is . Contohnya seperti berikut: fun main() {     val anyType : Any = 100L     when(anyType){         is Long -> println(""the value has a Long type"")         is String -> println(""the value has a String type"")         else -> println(""undefined"")     } }  /*    output : the value has a Long type */ Selain itu, when expression juga bisa kita gunakan untuk memeriksa nilai yang terdapat pada sebuah  Range  atau  Collection . Range sendiri merupakan salah satu tipe data yang unik di mana kita dapat menentukan nilai awal dan nilai akhir. Range dan Collection akan dibahas terpisah pada sub-modul berikutnya.  Berikut adalah contoh saat kita hendak mengecek apakah sebuah nilai ada di dalam sebuah Range atau tidak. fun main() {     val value =  27     val ranges = 10..50      when(value){         in ranges -> println(""value is in the range"")         !in ranges -> println(""value is outside the range"")         else -> println(""value undefined"")     } }  /*    output : value is in the range */ Branch  pertama pada contoh kode di atas akan memeriksa apakah nilai dari  value  terdapat di cakupan nilai  ranges . Kemudian untuk  branch  kedua akan memeriksa apakah nilai dari  value  tidak terdapat pada nilai yang dicakup oleh  ranges . Sedangkan  branch   else  akan mengevaluasi jika dua kondisi sebelumnya tidak terpenuhi. Sejak Kotlin  1.3 , kita dapat menangkap subjek dari when expression di dalam sebuah variabel. Contohnya seperti berikut: fun main() {     val registerNumber = when(val regis = getRegisterNumber()){         in 1..50 -> 50 * regis         in 51..100 -> 100 * regis         else -> regis     } }  fun getRegisterNumber() = Random.nextInt(100) Perhatikan. Cakupan variabel yang dapat ditangkap, terbatas di dalam  body  when expression. Jika kita melihat penjelasan dan contoh penggunaan dari  when expression  di atas, ia memiliki kesamaan dengan  if expression . Lantas disituasi seperti apa kita menggunakannya?  if expression  sebaiknya digunakan ketika kondisi yang diberikan tidak lebih dari 2 (dua) dan kondisi yang diberikan tidak terlalu rumit. val anyType : Any = 100L if (anyType is Long){     println(""the value has a Long type"") } else {     println(""the value is not Long type"") } Berbeda dengan  when expression , ia bisa digunakan ketika kondisi yang diberikan lebih dari 2 (dua).  val anyType: Any = 100L when (anyType) {     is Long -> println(""the value has a Long type"")     is Int -> println(""the value has a Int type"")     is Double -> println(""the value has a Double type"")     else -> println(""undefined"") }";When Expression di Kotlin adalah struktur kontrol untuk mencocokkan nilai dengan berbagai kondisi secara fleksibel. Mendukung multiple branch, mengembalikan nilai, memeriksa tipe data, rentang, dan variabel. Lebih ringkas dibanding if expression, cocok untuk pengecekan kompleks dengan sintaks sederhana dan mudah dibaca, memungkinkan pengembang menulis kode yang lebih efisien dan ekspresif.
"Ketika mempelajari sebuah bahasa pemrograman, kita selalu dihadapkan dengan istilah  expressions  dan  statement.  Ini adalah 2 (dua) istilah yang kadang salah dipahami.  Untuk lebih mudah memahaminya, marilah kita lihat contoh kode  If  sebagai  statement  berikut: val openOffice = 7 val now = 8  if (now > openOffice)      print(""Office already open"") else      print(""Office close"") Pada contoh kode di atas, if dikatakan sebagai statement karena ia tidak mengembalikan nilai apapun, hanya sebagai percabangan pada bahasa Kotlin. Namun, yang menarik  If  pada bahasa Kotlin juga bisa digunakan sebagai  expression . Yang dimaksud dengan  expression  adalah statement yang dapat mengembalikan nilai dan bisa kita simpan ke dalam sebuah variabel seperti contoh berikut: val openOffice = 7 val now = 8  val office = if (now > openOffice) ""Office already open"" else ""Office close""  print(office) Pada kode di atas, If akan mengembalikan nilai kedalam variabel  office . Apabila kondisi pada if terpenuhi maka variabel  office  akan berisi  ""Office already open""  dan jika tidak maka akan berisi  ""Office close"" . Jadi, sudah paham kan perbedaan antara statement dan expression? Nah, perlu Anda ketahui bahwa di dalam sebuah  expression  juga bisa terdapat sebuah  expression  lagi. Contohnya seperti berikut: fun main() {     sum(1 , 1 * 4) }  fun sum(value1: Int, value2: Int) = value1 + value2 Pada kode diatas  1 * 4  merupakan sebuah  expression  yang ada pada pemanggilan fungsi  sum()  alias fungsi yang mengembalikan nilai. Setiap fungsi selalu mengembalikan nilai. Alhasil, pemanggilan sebuah fungsi merupakan sebuah  expression . Contoh lain dari  statement  adalah inisialisasi sebuah variabel seperti berikut: fun main() {     val value1 = 10     val value2 = 10      sum(value1, value2) }  fun sum(value1: Int, value2: Int) = value1 + value2 Pada kode di atas deklarasi variabel  value1  dan  value2  merupakan sebuah  statement . Sedangkan pemanggilan fungsi  sum  seperti yang dijelaskan di atas, merupakan sebuah  expression .";Statement dan Expression dalam Kotlin adalah konsep fundamental yang membedakan antara kode yang hanya menjalankan aksi dan kode yang menghasilkan nilai. Statement adalah instruksi yang melakukan suatu tindakan tanpa mengembalikan nilai, seperti deklarasi variabel atau perintah print. Expression adalah kode yang menghasilkan atau mengembalikan nilai, dapat disimpan dalam variabel, seperti operasi matematika, pemanggilan fungsi, atau kondisional if-else. Perbedaan ini memungkinkan pengembang menulis kode lebih fleksibel dan ekspresif.
"Bayangkan ketika kita ditugaskan untuk mencetak beberapa baris teks yang sama ke dalam konsol seperti berikut: Hello World Hello World Hello World Hello World Hello World Kita pasti langsung terpikir akan menulis programnya seperti berikut: fun main() {     println(""Hello World"")     println(""Hello World"")     println(""Hello World"")     println(""Hello World"")     println(""Hello World"") } Think! Bagaimana jika teks yang harus ditampilkan berjumlah banyak? Tentu kita tidak mungkin menuliskan fungsi  println()  sesuai dengan jumlah yang kita ingin tampilkan.  Nah, untuk mengatasinya kita bisa menggunakan perulangan. Perulangan adalah proses perulangan blok yang sama tanpa henti sampai kondisi yang diberikan tidak terpenuhi atau bernilai  false .  Perulangan terdiri dari  While ,  Do While  dan  For Loop . Sub-modul ini akan membahas While dan Do While. Sementara For Loop akan dibahas terpisah pada sub-modul berikutnya. While Untuk menggunakan While, kita membutuhkan kata kunci  while,  lanjut ke kondisi di dalam tanda kurung, dan diakhiri oleh blok  body  dari  while  itu sendiri. Berikut adalah contoh dari penggunaan While: fun main() {     var counter = 1     while (counter <= 7){         println(""Hello, World!"")         counter++     } } /*    output :        Hello, World!        Hello, World!        Hello, World!        Hello, World!        Hello, World!        Hello, World!        Hello, World! */ Perhatikan kondisi dari While di atas, selama nilai dari variabel counter kurang dari sama dengan  7  maka kode yang di dalamnya akan terus dilakukan. Lalu ketika kondisi tersebut sudah tak terpenuhi maka proses perulangan akan dihentikan. While bersifat  Entry Controlled Loop.  Artinya, kondisi yang diberikan akan dievaluasi terlebih dahulu. Jika kondisi tersebut terpenuhi maka proses perulangan akan dijalankan. Jika kondisi yang diberikan tidak terpenuhi sejak awal maka proses perulangan tidak akan dijalankan. Untuk mengujinya Anda bisa menulis dan menjalankan kode berikut: fun main() {     var counter = 8     while (counter <= 7){         println(""Hello, World!"")         counter++     } } Dengan While kita tidak perlu menuliskan fungsi  println()  secara berulang untuk mencetak teks ke dalam konsol seperti contoh kasus di awal. Do While Selain menggunakan While, kita juga bisa menggunakan Do While untuk melakukan perulangan seperti berikut: fun main() {     var counter = 1     do {         println(""Hello, World!"")         counter++     } while (counter <= 7) }  /*    output:        Hello, World!        Hello, World!        Hello, World!        Hello, World!        Hello, World!        Hello, World!        Hello, World! */ Berbeda dengan While, Do While bersifat  Exit Controlled Loop  di mana proses perulangan akan langsung dijalankan di awal. Jika telah selesai, barulah kondisi yang diberikan akan dievaluasi. Saat menggunakan While dan Do While perhatikan  infinite loop , yaitu kondisi di mana proses perulangan berlangsung terus menerus sampai aplikasi menjadi  crash . Contoh dari infinite loop adalah seperti berikut: fun main() {     var value = 'A'     do {         print(value)     } while (value <= 'Z') } Infinite loop  terjadi jika kondisi yang diberikan selamanya terpenuhi atau bernilai  true . While dan Do While sendiri tidak dapat digunakan untuk melakukan perulangan pada rentan angka. Untuk melakukannya kita bisa menggunakan  For Loop  yang akan kita pelajari pada sub-modul selanjutnya.";Perulangan (Loop) dalam Kotlin terdiri dari While dan Do While, mekanisme untuk mengeksekusi blok kode berulang kali berdasarkan kondisi tertentu. While merupakan Entry Controlled Loop yang memeriksa kondisi sebelum menjalankan blok kode, artinya jika kondisi awal tidak terpenuhi maka perulangan tidak akan dijalankan. Sementara Do While adalah Exit Controlled Loop yang menjalankan blok kode terlebih dahulu baru kemudian memeriksa kondisi. Keduanya memiliki risiko terjadinya infinite loop jika kondisi tidak diatur dengan benar, sehingga memerlukan penanganan variabel pengendali dengan hati-hati.
"Range Seperti yang disampaikan sebelumnya, Range merupakan salah satu tipe yang unik pada kotlin. Kita dapat menentukan nilai awal dan nilai akhir pada Range. Range direpresentasikan dengan operator  ..  atau dengan fungsi  rangeTo()  dan  downTo() . Terdapat beberapa cara untuk membuat Range di Kotlin. Pertama, seperti berikut: val rangeInt = 1..10 Kode diatas menggunakan operator  ..  untuk membuat Range. Variabel  rangeInt  di atas mencakup nilai  1, 2, 3, 4, 5, 6, 7, 8, 9, 10 . Jarak antara dua nilai yang dicakup, ditentukan oleh  step . Secara default, step bernilai 1. Untuk mendapatkan step kita bisa menggunakan properti  step  seperti contoh berikut: fun main() {     val rangeInt = 1..10     print(rangeInt.step) }  /*    output: 1 */ Dan untuk mengubah nilai dari step bisa dilakukan ketika kita menginisialisasi nilai yang dicakup Range itu sendiri: fun main() {     val rangeInt = 1..10 step 2     rangeInt.forEach {         print(""$it "")     }     println(rangeInt.step) }  /*    output: 1 3 5 7 9 2 */ Pada kode di atas kita menentukan nilai step adalah  2 , maka nilai yang dicakup variabel rangeInt adalah  1, 3, 5, 7,  9 . Selanjutnya adalah menggunakan fungsi  rangeTo() : val rangeInt = 1.rangeTo(10) Kode di atas, operator  ..  digantikan dengan fungsi  rangeTo()  untuk membuat Range . Nilai yang dicakup pada kode di atas sama seperti kode sebelumnya ketika menggunakan operator  .. . Kita juga bisa menentukan nilai yang dicakup pada Range dengan urutan terbalik seperti berikut: val downInt = 10.downTo(1) Kode di atas menggunakan fungsi  downTo()  untuk menentukan nilai dengan urutan terbalik. Variabel  downInt  di atas mencakup nilai  10, 9, 8, 7, 6, 5, 4, 3, 2, 1 . Kita juga bisa memeriksa apakah suatu nilai ada pada cakupan nilai Range. fun main() {     val tenToOne = 10.downTo(1)     if (7 in tenToOne) {         println(""Value 7 available"")     } } /*    output: Value 7 available */ Pada kode di atas kita menggunakan kata kunci  in  untuk memeriksa apakah 7 berada diantara kisaran  1  sampai  10 .  Expression  yang dievaluasi pada  if  di atas sama seperti ketika menggunakan  expression  berikut: fun main() {     if (1 <= 7 && 7 <= 10){         println(""Value 7 available"")     } } /*    output: Value 7 available */ Nah,  di atas kita telah memeriksa apakah suatu nilai  ada  pada nilai cakupan Range. Sebaliknya, kita juga bisa memeriksa apakah suatu nilai  tidak ada  pada nilai cakupan Range tersebut. Kita bisa menggunakan kata kunci  !in  seperti ini: fun main() {     val tenToOne = 10.downTo(1)     if (11 !in tenToOne) {         println(""No value 11 in Range "")     } } /*    output: No value 11 in Range */ Range pada Kotlin mendukung beberapa tipe integral seperti  IntRange ,  LongRange  dan  CharRange . Sehingga selain nilai numerik, kita juga bisa menentukan tipe  Character  sebagai nilai yang dicakup oleh Range: val rangeChar = 'A'.rangeTo('F') Nilai pada variable  rangeChar  di atas mencakup  A, B, C, D, E, F . Sebagai referensi lebih lanjut mengenai beberapa konsep Kotlin yang sudah dipelajari, Anda dapat melihat video berikut. Kotlin under the hood: Understand the internals (Google I/O'19)";Range di Kotlin adalah cara unik untuk mendefinisikan rentang nilai dengan menggunakan operator .. atau fungsi rangeTo() dan downTo(). Memungkinkan pembuatan rentang nilai numerik atau karakter dengan step default 1, dan dapat dimodifikasi. Contoh: 1..10 mencakup nilai 1 hingga 10, sedangkan 10.downTo(1) membuat rentang terbalik. Fitur in dan !in memungkinkan pemeriksaan keberadaan nilai dalam rentang. Range mendukung tipe integral seperti IntRange, LongRange, dan CharRange, memberikan fleksibilitas dalam manipulasi rentang nilai.
"For Loop Sama seperti  While  dan  Do While ,  For  merupakan konsep perulangan pada blok yang sama selama hasil evaluasi kondisi yang diberikan terpenuhi atau bernilai  true . For dapat digunakan pada  Ranges ,  Collections ,  Arrays   dan apapun yang menyediakan  iterator . Contoh dari For loop sendiri adalah sebagai berikut: fun main() {     val ranges = 1..5     for (i in ranges){         println(""value is $i!"")     } }  /*    output :        value is 1!        value is 2!        value is 3!        value is 4!        value is 5!  */ Kode di atas merupakan contoh ketika melakukan perulangan pada Ranges dengan menggunakan range expression yang sudah kita pelajari sebelumnya. Karena menggunakan range expression, kita juga dapat menuliskannya seperti berikut: fun main() {     val ranges = 1.rangeTo(5)     for (i in ranges){         println(""value is $i!"")     } }  /*    output :        value is 1!        value is 2!        value is 3!        value is 4!        value is 5!  */ Selain itu, kita juga dapat menuliskan For loop menggunakan range expression seperti berikut: fun main() {     val ranges = 1.rangeTo(10) step 3     for (i in ranges ){         println(""value is $i!"")     } }  /*    output :        value is 1!        value is 4!        value is 7!        value is 10! */ Pada kode di atas, kita menambahkan ekstensi  step  yang akan mengembalikan nilai baru dengan tipe  IntProgression  dengan jarak nilai sebelumnya adalah  3 . Kita juga dapat mengakses indeks untuk setiap elemen yang ada pada Ranges dengan memanfaatkan fungsi  withIndex()  seperti berikut: fun main() {     val ranges = 1.rangeTo(10) step 3     for ((index, value) in ranges.withIndex()) {         println(""value $value with index $index"")     } } /*    output :        value 1 with index 0        value 4 with index 1        value 7 with index 2        value 10 with index 3 */ Kita menggunakan kata kunci  for  untuk memulai proses perulangan. Untuk tujuan yang sama, kita juga bisa loh, memanfaatkan salah satu ekstensi pada Kotlin yaitu  forEach . Contohnya seperti berikut: fun main() {     val ranges = 1.rangeTo(10) step 3     ranges.forEach { value ->         println(""value is $value!"")     } }  /*    output :        value is 1!        value is 4!        value is 7!        value is 10! */ forEach  pada kode di atas merupakan sebuah lambda expression yang hanya memiliki satu argumen yaitu nilai tunggal yang dicakup pada  ranges . Jika kita mendapatkan indeks dari tiap nilai yang dicakup kita bisa menggunakan ekstensi  forEachIndexed  seperti berikut: fun main() {      val ranges = 1.rangeTo(10) step 3     ranges.forEachIndexed { index, value ->         println(""value $value with index $index"")     } } /*    output :        value 1 with index 0        value 4 with index 1        value 7 with index 2        value 10 with index 3 */ forEachIndexed  memiliki dua argumen. Pertama adalah  index  yang merupakan indeks dari tiap nilai. Kedua adalah  value  yang merupakan nilai tunggal yang dicakup oleh  ranges  itu sendiri. Jika kita hanya ingin menggunakan argumen  index , maka kita bisa mengubah argumen  value  menjadi  _  seperti berikut: fun main() {     val ranges = 1.rangeTo(10) step 3     ranges.forEachIndexed { index, _ ->         println(""index $index"")     } } /*    output :        index 0        index 1        index 2        index 3 */ Sebenarnya ini merupakan sebuah aturan di mana ketika argumen dari sebuah  lambda expression  tidak digunakan, kita disarankan agar mengubahnya menjadi  _  untuk menggantikan nama dari argumen tersebut";For Loop dalam Kotlin adalah metode perulangan yang fleksibel untuk mengiterasi rentang nilai, kumpulan, atau array. Mendukung berbagai sintaks seperti range (1..5), step, withIndex(), dan lambda expression. Dapat menggunakan forEach() atau forEachIndexed() dengan kemampuan mengakses nilai dan indeks. Memungkinkan penggunaan underscore (_) untuk argumen tidak terpakai, memberikan cara ringkas dan ekspresif dalam melakukan iterasi dibandingkan metode perulangan tradisional.
"Break dan Continue Ketika melakukan perulangan, terkadang kita dihadapkan dengan data yang tak sesuai harapan. Contoh, seperti berikut: fun main() {     val listOfInt = listOf(1, 2, 3, null, 5, null, 7)     for (i in listOfInt) {         print(i)     } } /*    output: 123null5null7 */ Proses perulangan pada kode di atas akan menghasilkan nilai  null . Jika kita mengelola nilai tersebut, ada potensi  NullPointerException  di sana. Lalu bagaimana kita melewatkan atau menghentikan proses perulangan jika nilai yang dihasilkan bernilai  null ? Nah, di sini kita bisa menggunakan  Break  dan  Continue . Continue digunakan untuk melewatkan proses iterasi dan lanjut dengan proses iterasi berikutnya. Sementara itu, Break digunakan untuk menghentikan proses iterasi. Berikut adalah contoh proses iterasi pada kode di atas. Kita akan coba melewatkannya jika nilai yang dihasilkan adalah  null . fun main() {     val listOfInt = listOf(1, 2, 3, null, 5, null, 7)      for (i in listOfInt) {         if (i == null) continue         print(i)     } } /*    output: 12357 */ Pada kode di atas kita menggunakan kata kunci  continue . Jika hasil evaluasi  expression  yang diberikan bernilai  true , maka proses iterasi akan dilewatkan dan lanjut ke proses iterasi berikutnya. Berikut adalah contoh jika kita ingin menghentikan proses iterasi ketika nilai yang dihasilkan bernilai  null . fun main() {     val listOfInt = listOf(1, 2, 3, null, 5, null, 7)      for (i in listOfInt) {         if (i == null) break         print(i)     } } Penggunaan  break  pada kode di atas akan langsung menghentikan proses iterasi jika variabel  i  bernilai  null . Break dan Continue Labels Pada Kotlin, sebuah  expression  dapat ditandai dengan sebuah label. Label pada Kotlin memiliki sebuah  identifier  yang diikuti dengan tanda  @ . Contoh dari sebuah label adalah  foo@  atau  bar@ . Untuk melabeli sebuah  expression , kita cukup menempatkan label di depannya. Contohnya seperti berikut: fun main() {     loop@ for (i in 1..10) {         println(""Outside Loop"")          for (j in 1..10) {             println(""Inside Loop"")             if ( j > 5) break@loop         }     } }  /*    output :        Outside Loop        Inside Loop        Inside Loop        Inside Loop        Inside Loop        Inside Loop        Inside Loop */ Pada kode diatas,  break  yang sudah ditandai dengan label akan dilompati ke titik awal proses perulangan yang sudah ditandai dengan label.  break  akan menghentikan proses perulangan terluar dari dalam proses perulangan, di mana break tersebut dipanggil.";Break dan Continue di Kotlin adalah mekanisme kontrol alur perulangan. Continue digunakan untuk melewati iterasi saat ini dan lanjut ke iterasi berikutnya, sementara Break menghentikan seluruh proses perulangan. Keduanya dapat digunakan dengan atau tanpa label untuk mengontrol nested loop. Contohnya, dalam sebuah list berisi null, Continue dapat melewati nilai null, sedangkan Break dapat menghentikan perulangan saat menemui null. Dengan label, Break dapat melompat ke loop tertentu dalam struktur nested loop, memberikan fleksibilitas dalam mengontrol alur iterasi.
"Data Class Pada sub-modul ini, kita akan mempelajari sebuah fitur menarik pada Kotlin, yaitu  Data Class . Kotlin mengenalkan konsep data class yang merupakan sebuah kelas sederhana yang bisa berperan sebagai data  container . Data class adalah sebuah kelas yang tidak memiliki logika apapun dan juga tidak memiliki fungsionalitas lain selain menangani data. Kenapa disebut dengan kelas sederhana? Seperti yang sudah kita ketahui, Kotlin memungkinkan kita untuk menulis kode dengan ringkas dan lebih efisien. Dalam membuat sebuah data class, kita tidak perlu menuliskan banyak kode yang seharusnya dibutuhkan untuk mengelola sebuah data. Data class mampu menyediakan beberapa fungsionalitas yang biasanya kita butuhkan untuk mengelola data hanya dengan sebuah  keyword   data . data class User(val name : String, val age : Int) Hanya dengan satu baris kode di atas, kompiler akan secara otomatis menghasilkan  constructor ,  toString() ,  equals() ,  hashCode() ,  copy()  dan juga fungsi  componentN() . Tentunya ini jauh lebih mudah dan bersih dibandingkan kita harus menuliskan banyak kode secara manual. Beberapa hal yang perlu diperhatikan dalam membuat sebuah data class adalah: Konstruktor utama pada kelas tersebut harus memiliki setidaknya satu parameter; Semua konstruktor utama perlu dideklarasikan sebagai  val  atau  var ; Modifier dari sebuah data class tidak bisa  abstract ,  open ,  sealed , atau  inner.";"Data Class dalam Kotlin adalah kelas sederhana untuk menyimpan data dengan sintaks ringkas. Dengan menggunakan keyword ""data"", kompiler secara otomatis menghasilkan metode penting seperti toString(), equals(), hashCode(), copy(), dan componentN() tanpa menulis kode manual. Persyaratannya: konstruktor utama minimal satu parameter, parameter dideklarasikan sebagai val/var, dan tidak bisa menggunakan modifier abstract, open, sealed, atau inner. Contoh:"
"Penggunaan Data Class Sebelum kita masuk ke dalam pembahasan tentang apa saja yang bisa data class lakukan, mari kita perhatikan dulu kode berikut: class User(val name : String, val age : Int) Kode di atas merupakan sebuah kelas yang umumnya digunakan untuk menampung sebuah data. Kelas tersebut memiliki sebuah konstruktor yang berisi beberapa properti yang bisa kita akses, baik itu  create  maupun  read . Selanjutnya, perhatikan juga kelas berikut: data class DataUser(val name : String, val age : Int) Kelas hampir sama dengan sebelumnya, namun memiliki  keyword   data  yang menandakan bahwa kelas tersebut merupakan sebuah data class. Lalu, apakah perbedaan antara keduanya? Untuk mengetahuinya, bukalah Intellij IDEA dan buat sebuah berkas Kotlin dengan nama  DataClasses.kt . Ketikkan kedua kelas tadi di dalamnya dan buat juga fungsi  main  sebagai tempat di mana kita akan mencoba mengelola atau mengoperasikan kedua kelas tersebut. class User(val name : String, val age : Int)  data class DataUser(val name : String, val age : Int)  fun main(){  } Untuk mengetahui perbedaan yang pertama, kita akan menggunakan fungsi  println()  untuk menampilkan 2 buah objek yang akan dibuat dari kelas  User  dan  DataUser . Tambahkan kode berikut di dalam fungsi  main() : val user = User(""nrohmen"", 17) val dataUser = DataUser(""nrohmen"", 17)  println(user) println(dataUser) Jalankan fungsi main dan lihatlah hasil yang ditampilkan pada konsol: oo.User@4d7e1886 DataUser(name=nrohmen, age=17) Bisa kita perhatikan, bahwa objek  user  menghasilkan teks  oo.User@4d7e1886  dimana  oo  merupakan nama  package  tempat kelas  User  berada.  User  adalah nama dari kelas itu sendiri, dan  @4d7e1886  adalah  memory address  dari kelas tersebut. Sedangkan, objek  dataUser  menghasilkan teks  DataUser(name=nrohmen, age=17) , yaitu nama kelas disertai dengan semua properti di dalamnya dan  value  dari properti tersebut.  Dengan begitu, Anda bisa langsung mengetahui semua informasi dari  dataUser  hanya dengan melihat  value  dari properti yang ada. Mengapa demikian? Karena seperti yang sudah disampaikan sebelumnya,  data class akan secara otomatis menghasilkan fungsi  toString()  di dalamnya. Tanpa data class, kita perlu membuat fungsi  toString()  secara manual untuk mendapatkan informasi seperti yang diberikan oleh objek  dataUser . Sebagai contoh, untuk menampilkan informasi yang jelas dari objek  user , maka kita perlu menambahkan fungsi  toString()  seperti berikut: class User(val name : String, val age : Int){      override fun toString(): String {         return ""User(name=$name, age=$age)""     } } Dengan menambahkan fungsi  toString()  seperti di atas, maka objek user akan bisa menghasilkan teks yang sama dengan objek  dataUser . Coba jalankan kembali fungsi  main() . User(name=nrohmen, age=17) DataUser(name=nrohmen, age=17) Selanjutnya, kelebihan lain dari data class adalah ia sudah memiliki fungsi  equals()  secara otomatis. Maka jika Anda ingin melakukan komparasi konten antara 2 buah objek, lakukanlah dengan mudah seperti contoh di bawah ini: fun main(){     val dataUser = DataUser(""nrohmen"", 17)     val dataUser2 = DataUser(""nrohmen"", 17)     val dataUser3 = DataUser(""dimas"", 24)      println(dataUser.equals(dataUser2))     println(dataUser.equals(dataUser3))  } Konsol akan langsung memberi tahu apakah kedua objek tersebut sama atau tidak ketika Anda menjalankan fungsi  main() : true false Lain halnya jika kita melakukan komparasi pada 2 buah objek yang bukan dari data class. Kita tidak bisa mendapatkan hasil yang akurat karena konsol akan selalu menghasilkan nilai  false . Sebagai contoh, perhatikanlah kode berikut: fun main(){     val user = User(""nrohmen"", 17)     val user2 = User(""nrohmen"", 17)     val user3 = User(""dimas"", 24)      println(user.equals(user2))     println(user.equals(user3)) } Maka hasilnya akan sama saja,  false  semua. Hal ini karena dia tidak membandingkan kontennya, melainkan lokasi object (referensi) pada memory.  false false Dan jika Anda menginginkan hasil yang akurat seperti pada data class, maka Anda perlu membuat fungsi  equals()  secara manual: class User(val name : String, val age : Int){      override fun equals(other: Any?): Boolean {         if (this === other) return true         if (javaClass != other?.javaClass) return false          other as User          if (name != other.name) return false         if (age != other.age) return false          return true     }      override fun hashCode(): Int {         var result = name.hashCode()         result = 31 * result + age         return result     } } Anda perlu menuliskan beberapa  boilerplate code  di atas untuk mendapatkan hasil yang sesuai. Belum lagi ketika Anda menambahkan fungsi  equals() , Anda juga perlu menambahkan fungsi  hashCode() .";"Data Class dalam Kotlin adalah cara ringkas untuk membuat kelas data dengan fitur otomatis. Dengan keyword ""data"", kompiler secara otomatis menghasilkan metode seperti toString(), equals(), hashCode(), dan copy(). Kelas ini memudahkan pembuatan objek untuk menyimpan data dengan sintaks minimal, mengurangi boilerplate code, dan memberikan fungsionalitas bawaan seperti perbandingan objek berdasarkan konten. Cukup mendefinisikan properti dalam konstruktor utama, dan Kotlin akan menghasilkan implementasi standar yang dibutuhkan untuk mengelola data dengan efisien."
"Menyalin dan Memodifikasi Data Class Data class juga memungkinkan kita untuk menyalin sebuah objek dengan sangat mudah hanya dengan memanfaatkan fungsi  copy()  di dalamnya. Untuk mencobanya, buatlah objek baru dari kelas  DataUser  seperti berikut: fun main(){     val dataUser = DataUser(""nrohmen"", 17)     val dataUser2 = DataUser(""nrohmen"", 17)     val dataUser3 = DataUser(""dimas"", 24)     val dataUser4 = dataUser.copy()      println(dataUser4) } Jalankan fungsi  main()  dan seharusnya nilai dari  dataUser4  akan sama dengan nilai dari  dataUser . Menariknya, dengan fungsi  copy()  kita juga bisa memodifikasi objek tersebut dengan nilai yang baru. Sebagai contoh, kita akan mengubah nilai dari properti  age  menjadi  18.  Cukup tuliskan kode seperti berikut: val dataUser5 = dataUser.copy(age = 18) Maka seharusnya konsol akan menampilkan teks berikut: DataUser(name=nrohmen, age=18) Tanpa data class, untuk melakukan tugas seperti ini kita memerlukan sebuah  instance  baru untuk mengubah nilai dari suatu objek. Dengan demikian kita harus memodifikasi properti yang kita maksud. Tugas ini akan berulang dan membuat kode yang kita tulis, jauh dari paradigma  clean code .";"Data Class dalam Kotlin menyediakan fungsi copy() yang memungkinkan penyalinan dan modifikasi objek dengan mudah. Dengan copy(), Anda dapat membuat salinan objek persis sama atau memodifikasi sebagian properti tanpa mengubah objek asli. Misalnya:Fitur ini menghemat kode, membuat manipulasi objek lebih sederhana dan bersih dibandingkan cara tradisional.



"
"Destructuring Declarations Destructuring Declaration adalah proses memetakan objek menjadi sebuah variabel. Ini bisa dengan mudah kita lakukan pada data class. Dengan fungsi  componentN()  yang ada pada data class, kita bisa menguraikan sebuah objek menjadi beberapa properti yang dimilikinya. Sebagai contoh, kita ingin menguraikan objek  dataUser : fun main(){     val dataUser = DataUser(""nrohmen"", 17)      val name = dataUser.component1()     val age = dataUser.component2()      println(""My name is $name, I am $age years old"") } Maka jika kode di atas dijalankan, konsol akan menampilkan teks berikut: My name is nrohmen, I am 17 years old Fungsi  component1()  dan  component2()  dihasilkan sesuai dengan jumlah properti yang ada pada data class tersebut. Maka jika sebuah data class memiliki sejumlah  N  properti, maka secara otomatis  componentN()  akan dihasilkan. Kita juga dapat membuat beberapa variabel dari objek secara langsung dengan kode seperti berikut: fun main(){     val dataUser = DataUser(""nrohmen"", 17)     val (name, age) = dataUser      println(""My name is $name, I am $age years old"") } Jika dijalankan, seharusnya konsol akan menampilkan hasil yang sama seperti kode sebelumnya. Kesimpulannya, seperti aspek - aspek lain dari Kotlin, data class bertujuan untuk mengurangi jumlah kode  boilerplate  yang Anda tuliskan. Dan perlu diketahui bahwa data class tidak hanya sekedar untuk mengelola properti yang ada di dalamnya. Ketika mempunyai data yang sangat kompleks, kita juga bisa menerapkan sebuah  behaviour  di dalam data class. Contoh sederhananya, kita bisa membuat fungsi di dalam data class seperti berikut: data class DataUser(val name : String, val age : Int){     fun intro(){         println(""My name is $name, I am $age years old"")     } } Dan langsung mengaksesnya dari fungsi  main() : fun main(){     val dataUser = DataUser(""nrohmen"", 23)     dataUser.intro() }";Destructuring Declarations dalam Data Class Kotlin memungkinkan penguraian objek menjadi variabel individual dengan mudah. Menggunakan componentN() atau destructuring langsung, Anda dapat dengan cepat mengekstrak properti dari objek. Misalnya, val (name, age) = dataUser secara otomatis membuat variabel name dan age sesuai properti objek. Fitur ini mengurangi kode boilerplate, membuat manipulasi data lebih sederhana dan intuitif, serta meningkatkan keterbacaan kode.
"Collections Setelah berkenalan dan mempelajari data class, selanjutnya kita akan mencoba untuk mempelajari  collection . Bayangkan ketika kita ingin menyimpan dan memanipulasi sebuah objek. Kita perlu sebuah komponen yang mampu menambahkan, menghapus, mencari, bahkan mengurutkan sebuah data. Semua tugas itu bisa kita lakukan dengan bantuan collection. Collections sendiri merupakan sebuah objek yang bisa menyimpan kumpulan objek lain termasuk data class. Dengan collection kita bisa menyimpan banyak data sekaligus. Di dalam collections terdapat beberapa objek turunan, di antaranya adalah  List ,  Set , dan  Map . Mari kita pelajari satu per satu objek turunan tersebut. List Yang pertama adalah List. Dengan List kita dapat menyimpan banyak data menjadi satu objek. Sebagai contoh, kita bisa membuat sebuah List yang berisi sekumpulan data angka, karakter atau yang lainnya. Yang menarik, sebuah List tidak hanya bisa menyimpan data dengan tipe yang sama. Namun juga bisa berisi bermacam - macam tipe data seperti  Int ,  String ,  Boolean  atau yang lainnya. Cara penulisannya pun sangat mudah. Perhatikan saja beberapa contoh kode berikut. val numberList : List<Int> = listOf(1, 2, 3, 4, 5) Kode di atas adalah contoh dari satu objek List yang berisi kumpulan data dengan tipe Integer. Karena kompiler bisa mengetahui tipe data yang ada dalam sebuah objek List, maka tak perlu kita menuliskannya secara eksplisit. Ini tentunya akan menghemat kode yang kita ketikkan: val numberList = listOf(1, 2, 3, 4, 5) val charList = listOf('a', 'b', 'c') Sedangkan untuk membuat List dengan tipe data yang berbeda, cukup masukkan saja data tersebut seperti kode berikut: val anyList = listOf('a', ""Kotlin"", 3, true) Karena setiap objek pada Kotlin merupakan turunan dari kelas  Any , maka variabel anyList tersebut akan memiliki tipe data  List<Any> . Jika kita tampilkan list di atas maka konsol akan menampilkan: [a, Kotlin, 3, true] Bahkan kita pun bisa memasukkan sebuah data class ke dalam List tersebut: val anyList = listOf('a', ""Kotlin"", 3, true, User()) Ketika bermain dengan sebuah List, tentunya ada saat di mana kita ingin mengakses posisi tertentu dari List tersebut. Untuk melakukannya, kita bisa menggunakan fungsi  indexing  seperti berikut: println(anyList[3]) Perhatikan kode di atas. Fungsi  indexing  ditandai dengan tanda  [ ] . Jika Anda mengira bahwa konsol akan menampilkan angka  3 , maka tebakan Anda kurang tepat. Karena dalam sebuah List, indeks dimulai dari  0 . Maka ketika kita akan mengakses data pada  anyList  yang berada pada indeks ke- 3,  artinya data tersebut merupakan data pada posisi ke- 4 . Jadi data yang akan ditampilkan pada konsol adalah  true . Lalu apa yang akan terjadi jika kita berusaha menampilkan item dari List yang berada di luar dari ukuran List tersebut? Sebagai contoh, Anda ingin mengakses indeks ke- 5  dari  anyList : println(anyList[5]) Hasilnya adalah eror! Kompiler akan memberitahukan bahwa perintah itu tidak bisa dijalankan. Berikut pesan eror yang akan muncul: Exception in thread ""main"" java.lang.ArrayIndexOutOfBoundsException: 5 Pesan di atas memberitahu kita bahwa List telah diakses dengan indeks ilegal. Ini akan terjadi jika indeks yang kita inginkan negatif atau lebih besar dari atau sama dengan ukuran List tersebut. Informasi Tambahan: Sejauh ini kita baru belajar menginisialisasikan atau mengakses data dari sebuah List. Pastinya Anda bertanya, apakah bisa kita memanipulasi data pada List tersebut? Jawabannya  tidak . Apa pasal? List tersebut bersifat  immutable  alias tidak bisa diubah. Namun jangan khawatir. Kotlin  standard library  juga menyediakan collection dengan tipe  mutable . Artinya kita melakukan perubahan pada nilainya dengan cara seperti menambah, menghapus, atau mengganti nilai yang sudah ada. Caranya pun cukup mudah. Anda hanya perlu menggunakan fungsi  mutableListOf  seperti berikut: val anyList = mutableListOf('a', ""Kotlin"", 3, true, User()) Dengan begitu,  anyList  sekarang merupakan sebuah List yang bersifat mutable dan kita bisa memanipulasi data di dalamnya. anyList.add('d') // menambah item di akhir list anyList.add(1, ""love"") // menambah item pada indeks ke-1 anyList[3] = false // mengubah nilai item pada indeks ke-3 anyList.removeAt(0) // menghapus item pada indeks ke-0";Collections di Kotlin adalah struktur data yang memungkinkan penyimpanan dan manipulasi kumpulan objek. Terdapat tiga tipe utama: List, Set, dan Map. List dapat menyimpan berbagai tipe data, baik immutable (listOf()) maupun mutable (mutableListOf()). Dengan List, Anda dapat mengakses elemen menggunakan indexing, menambah, menghapus, atau mengubah data. Keunggulan utamanya adalah fleksibilitas dalam penyimpanan dan pengelolaan data, dengan dukungan penuh untuk berbagai operasi manipulasi koleksi.
Set Selanjutnya kita akan membahas objek turunan yang kedua, yaitu  Set . Set merupakan sebuah collection yang hanya dapat menyimpan nilai yang unik. Ini akan berguna ketika Anda menginginkan tidak ada data yang sama atau duplikasi dalam sebuah collection. Kita bisa mendeklarasikan sebuah Set dengan fungsi  setOf . val integerSet = setOf(1, 2, 4, 2, 1, 5) Perhatikan kode di atas. Di sana terdapat beberapa angka yang duplikat, yaitu angka  1  dan  2 . Silakan tampilkan pada konsol dan lihat hasilnya. println(integerSet)  // Output: [1, 2, 4, 5] Secara otomatis fungsi  setOf  akan membuang angka yang sama, sehingga hasilnya adalah  [1, 2, 4, 5] . Selain itu urutan pada Set bukanlah sesuatu yang penting, sehingga apabila kita bandingkan dua buah Set yang memiliki nilai yang sama dan urutan yang berbeda, akan tetap dianggap sama. val setA = setOf(1, 2, 4, 2, 1, 5) val setB = setOf(1, 2, 4, 5) println(setA == setB)  // Output: true Kita juga dapat melakukan pengecekan apakah sebuah nilai ada di dalam Set dengan menggunakan kata kunci  in . print(5 in setA)  // Output: true Kemudian ada juga fungsi union dan  intersect  untuk mengetahui gabungan dan irisan dari 2 (dua) buah Set. Sebagai contoh: val setC = setOf(1, 5, 7) val union = setA.union(setC) val intersect = setA.intersect(setC)  println(union) println(intersect)  // union: [1, 2, 4, 5, 7] // intersect: [1, 5] Informasi Tambahan: Pada Mutable Set kita bisa menambah dan menghapus item namun tak bisa mengubah nilai seperti pada List. val mutableSet = mutableSetOf(1, 2, 4, 2, 1, 5) //mutableSet[2] = 6 // tidak bisa mengubah set immutable mutableSet.add(6) // menambah item di akhir set mutableSet.remove(1) //menghapus item yang memiliki nilai 1;Set di Kotlin adalah koleksi yang hanya menyimpan nilai unik tanpa duplikasi. Dideklarasikan menggunakan setOf(), Set secara otomatis menghilangkan elemen yang sama. Urutan elemen tidak penting, sehingga Set dengan elemen sama namun berbeda urutan dianggap identik. Mendukung operasi seperti union, intersect, dan pengecekan keanggotaan dengan kata kunci 'in'. Mutable Set memungkinkan penambahan dan penghapusan elemen, namun tidak dapat mengubah nilai secara langsung. Berguna untuk menyimpan kumpulan data unik dan melakukan operasi set matematis.
"Map Turunan yang ketiga adalah  Map , yakni sebuah collection yang dapat menyimpan data dengan format  key-value . Perhatikan contoh berikut: val capital = mapOf(     ""Jakarta"" to ""Indonesia"",     ""London"" to ""England"",     ""New Delhi"" to ""India"" ) String yang berada pada sebelah kiri dari kata kunci  to  adalah sebuah  key , sedangkan yang di sebelah kanan merupakan  value -nya. Lalu untuk mengakses nilai dari Map tersebut, kita bisa menggunakan key yang sudah dimasukkan. Misalnya, kita bisa menggunakan key  “Jakarta”  untuk mendapatkan value  “Indonesia” : println(capital[""Jakarta""])  // Output: Indonesia Atau bisa juga menggunakan fungsi  getValue() : println(capital.getValue(""Jakarta""))  // Output: Indonesia Hasilnya sama saja. Namun sebenarnya terdapat sebuah perbedaan antara keduanya. Saat menggunakan simbol  [ ]  atau yang kita kenal dengan  indexing , konsol akan menampilkan hasil  null  saat key yang dicari tidak ada di dalam Map. Sedangkan saat kita menggunakan  getValue() , konsol akan memberikan sebuah  Exception . println(capital[""Amsterdam""])  // Output: null   println(capital.getValue(""Amsterdam""))  // Output: Exception in thread ""main"" java.util.NoSuchElementException: Key Amsterdam is missing in the map. Kita dapat menampilkan key apa saja yang ada di dalam Map dengan menggunakan fungsi  keys() . Fungsi ini akan mengembalikan nilai berupa Set karena key pada Map haruslah unik. val mapKeys = capital.keys  // mapKeys: [Jakarta, London, New Delhi] Sedangkan untuk mengetahui nilai apa saja yang ada di dalam Map kita bisa menggunakan fungsi  values() . Fungsi ini akan mengembalikan collection sebagai tipe datanya. val mapValues = capital.values  // mapValues: [Indonesia, England, India] Informasi Tambahan: Untuk menambahkan  key-value  ke dalam map, kita perlu memastikan bahwa map yang digunakan adalah  mutable . Mari kita ubah map  capital  yang sudah kita buat sebelumnya menjadi  mutable . val mutableCapital = capital.toMutableMap() Selanjutnya kita bisa menambahkan  key-value  baru menggunakan fungsi  put() . mutableCapital.put(""Amsterdam"", ""Netherlands"") mutableCapital.put(""Berlin"", ""Germany"") Namun perlu diperhatikan   bahwa menggunakan mutable collection itu  tidak disarankan.  Apabila terdapat sebuah mutable collection yang diubah oleh lebih dari 1 proses, hasil nya akan sulit untuk diprediksi. Untuk itu, sebaiknya gunakan immutable sebisa mungkin, jika memang dibutuhkan untuk diubah, baru gunakan mutable.";Map di Kotlin adalah koleksi key-value yang menyimpan data dengan pasangan kunci unik dan nilainya. Dideklarasikan menggunakan mapOf(), memungkinkan akses nilai melalui key dengan [ ] atau getValue(). Mendukung operasi seperti mengambil keys() dan values(). Mutable Map (mutableMapOf()) memungkinkan penambahan key-value baru dengan put(). Namun, penggunaan mutable collection tidak direkomendasikan karena risiko perubahan yang tidak terduga. Sebaiknya gunakan immutable Map sebisa mungkin, beralih ke mutable hanya jika benar-benar diperlukan.
"Collections Operations Selain memiliki beberapa turunan yang baru saja kita bahas, Collection juga mempunyai beberapa fungsi operasi yang bisa kita gunakan untuk mengakses data di dalamnya. Sekarang saatnya kita akan mempelajari fungsi-fungsi yang dimaksud.  filter() dan filterNot() Mari kita mulai dari fungsi  filter()  dan  filterNot()  terlebih dahulu. Kedua fungsi tersebut akan menghasilkan list baru dari seleksi berdasarkan kondisi yang kita berikan. Sesuai dengan namanya, untuk mem- filter  atau menyaring suatu data dalam sebuah collection. Contohnya dapat Anda lihat pada kode berikut: val numberList = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) val evenList = numberList.filter { it % 2 == 0 }  // evenList: [2, 4, 6, 8, 10] Pada kode di atas, kita telah menggunakan  filter()  untuk menyaring bilangan yang habis dibagi 2 (dua) atau biasa disebut dengan bilangan genap. Selain itu kita juga dapat mem-filter list berdasar hasil yang tak sesuai dengan kondisi yang diberikan. Caranya adalah dengan menggunakan fungsi  filterNot() . val numberList = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) val notEvenList = numberList.filterNot { it % 2 == 0 }  // notEvenList: [1, 3, 5, 7, 9] Jadi, bisa disimpulkan bahwa  filterNot()  merupakan kebalikan dari  filter() . map() Fungsi yang akan sering dipakai berikutnya adalah  map() . Fungsi ini akan membuat collection baru sesuai perubahan yang akan kita lakukan dari collection sebelumnya. Kita ambil contoh dari  numberList  yang sudah ada. Lalu kita buat collection baru yang isinya adalah hasil kali 5 (lima) dari masing-masing item. Maka Anda bisa menggunakan kode seperti berikut: val numberList = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) val multipliedBy5 = numberList.map { it * 5 }  // multipliedBy5: [5, 10, 15, 20, 25, 30, 35, 40, 45, 50] it  pada kode di atas akan merepresentasikan masing masing item pada  numberList . count() Fungsi  count()  dapat kita gunakan untuk menghitung jumlah item yang ada di dalam collection. Kembali gunakan contoh  numberList , kita akan menampilkan jumlah item yang ada di dalamnya. val numberList = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) print(numberList.count())  // Output: 10 Cukup sederhana, bukan? Di dalam fungsi  count()  kita juga bisa menambahkan sebuah parameter berupa lambda yang berisi sebuah kondisi. Sebagai contoh kali ini kita akan menampilkan jumlah item pada  numberList  yang merupakan kelipatan dari  3 . val numberList = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) print(numberList.count { it % 3 == 0 })  // Output: 3 Pada kode di atas konsol akan menampilkan  3  sebagai jumlah item yang merupakan kelipatan  3 , yaitu:  3 ,  6 , dan  9 . find(), firstOrNull(), & lastOrNull() Selanjutnya adalah fungsi yang digunakan untuk mencari item pada sebuah collection. Untuk mencari item pertama yang sesuai dengan kondisi yang kita tentukan, kita bisa menggunakan fungsi  find() . Contoh, kita perlu mencari angka ganjil pertama dari  numberList  maka kodenya akan seperti berikut: val numberList = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) val firstOddNumber = numberList.find { it % 2 == 1 } val firstOrNullNumber = numberList.firstOrNull { it % 2 == 3 }  // firstOddNumber: 1 // firstOrNullNumber: null Fungsi  find()  ini memiliki cara kerja yang sama dengan fungsi  firstOrNull().  Artinya, jika di dalam collection tidak ditemukan data yang sesuai, maka fungsi akan mengembalikan nilai  null . Tidak seperti fungsi  filter()  atau  map()  yang akan melakukan iterasi terhadap seluruh item, fungsi  find()  dan  firstOrNull()  ini akan langsung mengembalikan nilai ketika kondisi terpenuhi. Kemudian jika Anda ingin mencari item terakhir, gunakan fungsi  lastOrNull() . first() & last() Hampir sama seperti fungsi  firstOrNull()  dan  lastOrNull() , fungsi  first()  dan  last()  digunakan untuk menyaring item pertama atau terakhir dari sebuah collection. Kita juga bisa menambahkan sebuah kondisi dengan parameter lambda. Namun perlu diperhatikan jika kita menambahkan kondisi padahal kondisi tersebut tidak terpenuhi, apa hasilnya?  E xception!  Lihat saja contohnya pada kode berikut: val numberList = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) val moreThan10 = numberList.first { it > 10 } print(moreThan10)  // Output: Exception in thread ""main"" java.util.NoSuchElementException: Collection contains no element matching the predicate. sum() Mungkin Anda sudah tahu fungsi ini. Fungsi  sum()  khusus hanya bisa digunakan untuk collection yang bertipe angka. Fungsi ini akan menjumlahkan setiap data yang ada pada collection. val numberList = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) val total = numberList.sum()  // total: 55 sorted() sorted()  digunakan untuk mengurutkan item yang ada di dalam collection. Secara default fungsi  sorted()  ini akan mengurutkan data secara  ascending . Perhatikan kode di bawah ini: val kotlinChar = listOf('k', 'o', 't', 'l', 'i', 'n') val ascendingSort = kotlinChar.sorted() println(ascendingSort)  // ascendingSort: [i, k, l, n, o, t] Sedangkan untuk sorting secara  descending , kita dapat menggunakan fungsi  sortedDescending() . val kotlinChar = listOf('k', 'o', 't', 'l', 'i', 'n') val descendingSort = kotlinChar.sortedDescending() println(descendingSort)  // descendingSort: [t, o, n, l, k, i]";Collection Operations di Kotlin menawarkan fungsi-fungsi powerful untuk manipulasi data, seperti filter() untuk menyaring elemen, map() untuk transformasi, count() untuk menghitung, find() untuk pencarian, sorted() untuk pengurutan, dan sum() untuk penjumlahan. Setiap fungsi memiliki kemampuan untuk mengolah data dengan lambda expression, memungkinkan operasi kompleks dalam satu baris kode. Fungsi-fungsi ini bekerja pada berbagai jenis koleksi seperti List, Set, dan lainnya, memberikan fleksibilitas dan kemudahan dalam pemrosesan data di Kotlin.
"Sequences Tiga (3) jenis collection yang sudah kita pelajari sebelumnya merupakan jenis collection yang menjalankan  eager evaluation . Berbeda dengan itu, Sequence merupakan collection yang bisa dikategorikan ke dalam  lazy evaluation . Jika  eager evaluation  mengevaluasi seluruh item yang ada pada collection  [5] ,  lazy evaluation  hanya akan mengevaluasi  item jika benar-benar diperlukan  [6] . Kita ambil contoh.. Misalnya Anda mempunyai collection dengan jumlah data  10  atau  100  , itu mungkin tidak akan memberi pengaruh besar terhadap performa program. Namun apa yang terjadi jika data yang ada pada collection mencapai ratusan ribu atau jutaan? Waktu proses pada sebuah program akan bertambah signifikan jika semua datanya harus dievaluasi.  fun main() {     val list = (1..1000000).toList()     list.filter { it % 5 == 0 }.map { it * 2 }.forEach { println(it) } } Pada contoh kode di atas, kita memiliki data collection sejumlah 1 juta item, kemudian masing-masing data akan disaring berdasarkan angka yang merupakan kelipatan 5 lalu dikalikan 2 dan akhirnya ditampilkan pada konsol. Dengan  eager evaluation  atau dikenal dengan  horizontal evaluation , list akan menyelesaikan proses filter terhadap 1 juta data baru kemudian melakukan mapping data sampai akhirnya ditampilkan pada konsol. Untuk menerapkan  lazy   atau  vertical evaluation  maka kita perlu mengubah list menjadi Sequence. Caranya sangat sederhana, yaitu dengan memanggil fungsi  asSequence() . fun main() {     val list = (1..1000000).toList()     list.asSequence().filter { it % 5 == 0 }.map { it * 2 }.forEach { println(it) } } Dengan sequence, operasi akan dilakukan secara vertikal atau per item, misalnya dimulai angka 1. Karena tidak memenuhi kondisi pada filter maka operasi tidak akan dilanjutkan ke  map().  Sampai dengan iterasi ke-5 akan dilakukan  mapping , angka 5 akan dikalikan 2 dan ditampilkan pada konsol, setelah itu akan dilanjutkan ke iterasi berikutnya sampai dengan iterasi ke-1 juta. Untuk membuat objek Sequence, kita bisa menggunakan fungsi yang tersedia pada  standard library  yaitu  generateSequence() . val sequenceNumber = generateSequence(1) { it + 1 } Pada kode di atas kita telah membuat variabel  sequenceNumber  dengan menggunakan fungsi  generateSequence()  Fungsi ini memiliki 2 parameter. Parameter pertama adalah item pertama yang ada di dalam collection. Parameter kedua adalah lambda expression berisi perubahan pada masing-masing item. Pada contoh kode tadi, setiap item merupakan item sebelumnya ditambah 1. Fungsi  generateSequence()  akan membuat collection sequence secara tak terbatas. Alhasil, kita perlu menambahkan fungsi  take()  supaya program tidak mengalami  infinite loop . fun main() {     val sequenceNumber = generateSequence(1) { it + 1 }     sequenceNumber.take(5).forEach { print(""$it "") } } // Output: 1 2 3 4 5";Sequences di Kotlin adalah koleksi dengan lazy evaluation, yang berarti elemen hanya dievaluasi ketika diperlukan. Berbeda dengan eager evaluation yang memproses seluruh data sekaligus, Sequences memproses data secara bertahap per item, menghemat memori dan waktu komputasi. Dapat dibuat menggunakan asSequence() atau generateSequence(), Sequences sangat efisien untuk operasi pada kumpulan data besar, mengurangi beban komputasi dengan memproses data secara vertikal dan hanya ketika dibutuhkan.
Functional Programming Seperti yang sudah disampaikan di awal akademi. Kotlin adalah sebuah  multiparadigm programming language.  Artinya selain merupakan bahasa pemrograman berorientasi objek, dalam penulisan sintaksnya Kotlin menggunakan gaya  functional programming . Untuk mengawalinya, perhatikan kode berikut: val list = getListUser()  fun getUsername(): List<String>{     val name = mutableListOf<String>()     for (user in list){         name.add(user.name)     }     return name } Kode di atas biasanya kita tuliskan untuk mendapatkan nilai tertentu dari sebuah list. Karena kode pada Kotlin bisa dituliskan dengan gaya fungsional, maka kode di atas cukup dituliskan seperti berikut: fun getUsername(): List<String>{     return list.map {         it.name     } } Itu adalah salah satu contoh kenapa Kotlin termasuk ke dalam  functional programming . Untuk lebih memahaminya, kita akan belajar tentang fitur atau komponen pada Kotlin yang terkait dengan  functional programming . Anda akan mempelajari lebih detail tentang anatomi dari sebuah fungsi pada Kotlin, bagaimana fungsi Kotlin berperilaku,  lambda ,  higher-order   function  dan konsep fungsional lainnya.;Functional Programming di Kotlin adalah paradigma pemrograman yang menekankan penggunaan fungsi murni, immutability, dan operasi tanpa efek samping. Kotlin mendukung gaya fungsional dengan fitur seperti lambda expressions, higher-order functions, dan transformasi data menggunakan fungsi seperti map(), filter(), dan reduce(). Dibandingkan dengan pendekatan prosedural tradisional, gaya fungsional memungkinkan kode lebih ringkas, mudah dibaca, dan dapat diuji. Contohnya, mengubah perulangan tradisional menjadi transformasi fungsi sederhana yang lebih deklaratif dan ekspresif.
Object-Oriented Programming Pada s ub-modul  awal kita sudah mengetahui bahwa Kotlin memberi dukungan luas untuk mengembangkan program berorientasi objek. Sebabnya, OOP masih menjadi salah satu paradigma atau teknik pemrograman yang banyak digunakan dalam pengembangan aplikasi. Dengan paradigma OOP kita dapat mudah memvisualisasikan kode karena OOP sendiri mirip seperti skenario dalam kehidupan nyata.  Visualisasi di atas mencontohkan gambaran umum OOP di mana terdapat sebuah  blueprint  mobil, komponen yang dimiliki mobil, dan kemampuan yang dapat dilakukan oleh mobil. Dalam OOP  blueprint  tersebut dikenal dengan  C lass  (kelas), komponen dikenal dengan nama atribut, kemampuan yang dimiliki dikenal sebagai behaviour dan hasil realisasi dari sebuah  blueprint  tersebut disebut  object . Pada s ub-modul  ini kita akan membahas secara detail tentang  object ,  classes ,  attribute  dan  behaviour  yang ada pada OOP.;Object-Oriented Programming (OOP) di Kotlin adalah paradigma pemrograman yang mengorganisir kode berdasarkan objek, yang merupakan instance dari kelas. Kelas bertindak sebagai blueprint yang mendefinisikan atribut (properti) dan perilaku (metode) dari objek. Konsep inti OOP meliputi enkapsulasi, pewarisan, polimorfisme, dan abstraksi. Kotlin menyediakan dukungan penuh untuk OOP dengan fitur-fitur modern seperti data class, extension function, dan null safety. Pendekatan ini memungkinkan pengembang membuat kode yang terstruktur, modular, dan mudah dipelihara, dengan representasi yang dekat dengan dunia nyata.
"Pada s ub-modul  sebelumnya kita sudah belajar tentang Kotlin sebagai bahasa pemrograman yang bisa diklasifikasikan ke dalam  OOP  beserta konsep-konsep yang terdapat didalamnya. Kali ini kita akan mempelajari tentang  Generics , yaitu sebuah konsep yang memungkinkan suatu kelas atau  interface  menjadi tipe parameter yang dapat digunakan untuk berbagai macam tipe data. Berkenalan Dengan Generics Seperti yang kita ketahui, Kotlin termasuk dalam bahasa pemrograman  statically typed.  Ketika menambahkan variabel baru, maka secara otomatis tipe dari variabel tersebut dapat dikenali pada saat kompilasi.  Secara umum generic merupakan konsep yang digunakan untuk menentukan tipe data yang akan kita gunakan. Pendeklarasiannya ditandai dengan tipe parameter. Kita juga bisa mengganti tipe parameter menjadi tipe yang lebih spesifik dengan menentukan  instance  dari tipe tersebut. Sebelum kita mempelajari bagaimana cara kita mendeklarasikan sebuah kelas generic, ada baiknya jika kita melihat contoh bagaimana generic bekerja pada variabel dengan tipe  List . Kita perlu menentukan tipe dari nilai yang bisa disimpan di dalam variabel List tersebut: val contributor = listOf<String>(""jasoet"", ""alfian"",""nrohmen"",""dimas"",""widy"") Perhatikan kode di atas. Tipe parameter yang digunakan dalam pemanggilan fungsi  listOf()  adalah String maka nilai yang bisa kita masukkan adalah nilai dengan tipe String. Kita bisa menyederhanakannya dengan menghapus tipe parameter tersebut. Karena kompiler akan menetapkannya secara otomatis bahwa variabel yang kita buat adalah  String . val contributor = listOf(""alfian"",""nrohmen"",""dimas"",""widy"") Berbeda jika kita ingin membuat variabel list tanpa langsung menambahkan nilainya. Maka list tersebut tidak memiliki nilai yang bisa dijadikan acuan untuk kompiler menentukan tipe parameter. Alhasil, kita wajib menentukannya secara eksplisit seperti berikut: val contributor = listOf<String>() Selain itu, kita juga bisa mendeklarasikan lebih dari satu tipe parameter untuk sebuah kelas. Contohnya adalah kelas  Map  yang memiliki dua tipe parameter yang digunakan sebagai  key  dan  value . Kita bisa menentukannya dengan argumen tertentu, misalnya seperti berikut: val points = mapOf<String, Int>( ""alfian"" to 10 , ""dimas"" to 20 )";Generics dalam Kotlin adalah konsep pemrograman yang memungkinkan pembuatan kode fleksibel dengan parameter tipe data. Dengan generics, pengembang dapat membuat kelas, antarmuka, dan fungsi yang dapat bekerja dengan berbagai tipe data sambil mempertahankan keamanan tipe statis. Contohnya, dapat membuat list atau map dengan tipe spesifik seperti listOf<String>() atau mapOf<String, Int>(). Keuntungan utamanya adalah mengurangi duplikasi kode, memberikan pengecekan tipe saat kompilasi, dan meningkatkan keterbacaan serta fleksibilitas kode dalam pengembangan aplikasi.
Mendeklarasikan Kelas Generic Setelah mengetahui contoh bagaimana generic bekerja pada sebuah kelas, selanjutnya kita akan mempelajari bagaimana penerapan generic itu sendiri. Kita bisa menerapkannya dengan meletakkan tipe parameter ke dalam  angle brackets  ( <> ) seperti berikut: interface List<T>{     operator fun get(index: Int) : T } Pada kode di atas, tipe parameter  T  bisa kita gunakan sebagai tipe reguler yang mengembalikan tipe dari sebuah fungsi. Selanjutnya, jika kita mempunyai sebuah kelas yang mewarisi kelas atau  interface  generic, maka kita perlu menentukan tipe argumen sebagai tipe dasar dari parameter generic kelas tersebut. Parameternya bisa berupa tipe yang spesifik atau lainnya. Contohnya seperti berikut: class LongList : List< Long >{     override fun get(index: Int):  Long  {         return this[index]     } }  class ArrayList <T>  : List <T> {     override fun get(index: Int):  T  {         return this[index]     } } Pada kelas  LongList  di atas, Long digunakan sebagai tipe argumen untuk List, sehingga fungsi yang berada di dalamnya akan menggunakan Long sebagai tipe dasarnya. Berbeda dengan kelas  ArrayList , di mana tipe argumen untuk kelas List menggunakan  T . Dengan demikian ketika kita menggunakan kelas  ArrayList , kita perlu menentukan tipe argumen dari kelas tersebut saat diinisialisasi. fun main() {     val longArrayList = ArrayList<Long>()     val firstLong = longArrayList.get(0) }  class ArrayList<T> : List<T> {     override fun get(index: Int): T {         return this[index]     } }  interface List<T> {     operator fun get(index: Int): T } Yang perlu diperhatikan dari kelas  ArrayList  di atas adalah deklarasi dari tipe parameter  T . Tipe parameter tersebut berbeda dengan yang ada pada kelas  List , karena  T  adalah milik kelas  ArrayList  itu sendiri. Plus sebenarnya Anda pun bisa menggunakan selain  T  misalnya seperti berikut: class ArrayList<T> : List<T> {     override fun get(index: Int): T {         return this[index]     } }  interface List< P > {     operator fun get(index: Int):  P  };Kelas generic dalam Kotlin memungkinkan pembuatan struktur data fleksibel dengan tipe parameter yang dapat disesuaikan. Deklarasi dilakukan menggunakan angle brackets (<>) dengan tipe parameter seperti T atau P. Ketika mewarisi kelas atau interface generic, perlu menentukan tipe argumen sebagai tipe dasar, baik tipe spesifik maupun parameter. Contohnya, kelas LongList menggunakan Long sebagai tipe argumen, sementara ArrayList menggunakan tipe parameter T, yang dapat diganti sesuai kebutuhan saat inisialisasi.
Mendeklarasikan Fungsi Generic Setelah deklarasi generic pada sebuah kelas, apa berikutnya? Kita akan belajar bagaimana mendeklarasikan generic pada sebuah fungsi. Generic pada sebuah fungsi dibutuhkan ketika kita membuat sebuah fungsi yang berhubungan dengan List. Misalnya, list yang dapat digunakan untuk berbagai tipe dan tidak terpaku pada tipe tertentu.  Fungsi generic memiliki tipe parameternya sendiri. Tipe argumen dari parameternya ditentukan ketika fungsi tersebut dipanggil. Cara mendeklarasikannya sedikit berbeda dengan kelas generic, Tipe parameter yang berada di dalam angle bracket harus ditempatkan sebelum nama dari fungsi yang kita tentukan. Sebagai contoh: fun <T> run(): T {     /*...*/ } Contoh penerapan fungsi generic bisa kita lihat pada deklarasi fungsi  slice  yang merupakan  extensions function  dari kelas  List  berikut: public fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {     /*...*/ } Tipe parameter pada fungsi  slice()  di atas digunakan sebagai  receiver  dan  return type . Ketika fungsi tersebut dipanggil dari sebuah List dengan tipe tertentu, kita bisa menentukan tipe argumennya secara spesifik seperti berikut: fun main() {     val numbers = (1..100).toList()     print(numbers.slice<Int>(1..10)) }  /*    output : [2, 3, 4, 5, 6, 7, 8, 9, 10, 11] */ Seperti yang telah disebutkan sebelumnya, jika semua nilai yang berada di dalamnya memiliki tipe yang sama, kita bisa menyederhanakan. Caranya, hapus tipe parameter tersebut. fun main() {     val numbers = (1..100).toList()     print(numbers.slice(1..10)) }  /*    output : [2, 3, 4, 5, 6, 7, 8, 9, 10, 11] */;Fungsi generic dalam Kotlin memungkinkan pembuatan metode yang dapat bekerja dengan berbagai tipe data. Deklarasinya dilakukan dengan menempatkan tipe parameter dalam angle brackets (<>) sebelum nama fungsi, seperti fun <T> run(): T. Contoh nyata adalah fungsi slice() pada List, yang dapat mengambil subset data dari list dengan tipe apa pun. Tipe argumen ditentukan saat pemanggilan, dan jika tipe data konsisten, penulisan tipe parameter dapat disederhanakan atau dihilangkan.
"Constraint Type Parameter Dalam penerapan generic, kita bisa membatasi tipe apa saja yang dapat digunakan sebagai parameter. Untuk menentukkan batasan tersebut, bisa dengan menambahkan tanda titik dua ( : ) setelah tipe parameter yang kemudian diikuti oleh tipe yang akan dijadikan batasan. Contohnya seperti berikut: class ListNumber<T : Number> : List<T>{     override fun get(index: Int): T {         /* .. */     } } Pada kode di atas kita telah menentukan  Number  sebagai batasan tipe argumen. Dengan begitu, kita hanya bisa memasukkan tipe argumen Number pada kelas  ListNumber . Dan ketika kita memasukkan selain Number, maka akan terjadi eror seperti berikut: fun main() {     val numbers = ListNumber<Long>()     val numbers2 = ListNumber<Int>()     val numbers3 = ListNumber<String>() // error : Type argument is not within its bounds }  class ListNumber<T : Number> : List<T>{     override fun get(index: Int): T {         /* .. */     } } Contoh lain dari  constraint type parameter  adalah seperti berikut: fun <T : Number> List<T>.sumNumber() : T {     /* .. */ } Fungsi di atas merupakan  extensions function  dari kelas  List  yang mempunyai tipe parameter. Sama seperti deklarasi generic pada sebuah fungsi, tipe parameter  T  pada fungsi tersebut juga akan digunakan sebagai receiver dan  return type . Perbedaannya terletak pada cara memanggilnya. Fungsi tersebut akan tersedia pada variabel List dengan tipe argumen yang memiliki  supertype  Number. fun main() {     val numbers = listOf(1, 2, 3, 4, 5)     numbers.sumNumber()     val names = listOf(""dicoding"", ""academy"")     names.sumNumber() // error : inferred type String is not a subtype of Number }  fun <T : Number> List<T>.sumNumber() : T {     /* .. */ }";Constraint type parameter dalam Kotlin memungkinkan pembatasan tipe data yang dapat digunakan sebagai parameter generic. Pembatasan dilakukan dengan menambahkan titik dua (:) setelah tipe parameter, diikuti tipe batasan. Contohnya, class ListNumber<T : Number> hanya memperbolehkan tipe turunan Number seperti Long atau Int. Pada fungsi generic, constraint serupa dapat diterapkan, misalnya fun <T : Number> List<T>.sumNumber(), yang hanya dapat digunakan pada list berisi tipe numerik, mencegah penggunaan tipe yang tidak sesuai.
Variance Sebelumnya kita telah mempelajari bagaimana  generic  bekerja, bagaimana penerapannya, serta bagaimana kita bisa menentukan batasan tipe argumen yang bisa ditentukan terhadap tipe parameter. Selanjutnya kita akan belajar salah satu konsep dari generic yaitu variance. Apa itu variance? Variance adalah konsep yang menggambarkan bagaimana sebuah tipe yang memiliki subtipe yang sama dan tipe argumen yang berbeda saling berkaitan satu sama lain. Variance dibutuhkan ketika kita ingin membuat kelas atau fungsi generic dengan batasan yang tidak akan mengganggu dalam penggunaannya. Sebagai contoh, mari kita buat beberapa kelas seperti berikut: abstract class Vehicle(wheel: Int) class Car(speed: Int) : Vehicle(4) class MotorCycle(speed: Int) : Vehicle(2) Kemudian jalankan kode seperti berikut: fun main() {     val car = Car(200)     val motorCycle = MotorCycle(100)     var vehicle: Vehicle = car     vehicle = motorCycle } Bisa kita perhatikan pada kode di atas, variabel  car  dan  motorcycle  merupakan subtipe dari  Vehicle  sehingga kita bisa melakukan  assignment  antar dua variabel tersebut. Maka seharusnya kode tersebut akan berhasil dikompilasi. Selanjutnya mari kita masukkan salah satu kelas yang merupakan subtipe dari kelas  Vehicle  di atas kedalam generic list: fun main() {     val carList = listOf(Car(100) , Car(120))     val vehicleList = carList } Dari contoh di atas, kita melihat bagaimana variance menggambarkan keterkaitan antara  carList  dan  vehicleList  di mana  Car  merupakan subtipe dari  Vehicle .  Nah, itu adalah contoh sederhana bagaimana variance bekerja. Lalu bagaimana cara membuat kelas generic yang memiliki variance? Caranya sama seperti ketika kita membuat generic kelas pada umumnya. Namun untuk tipe parameternya kita membutuhkan kata kunci  out  untuk  covariant  atau kunci  in  untuk  contravariant . Covariant Contoh deklarasi generic dengan covariant bisa kita lihat saat kelas  List  pada Kotlin dideklarasikan seperti berikut: interface List<out E> : Collection<E> {     operator fun get(index: Int): E } Ketika kita menandai sebuah tipe parameter dengan kata kunci  out  maka nilai dari tipe parameter tersebut hanya bisa diproduksi seperti menjadikanya sebagai  return type.  Serta tidak dapat dikonsumsi seperti menjadikannya sebagai tipe argumen untuk setiap fungsi di dalam kelas tersebut.  Contravariant Berbanding terbalik dengan saat kita menandainya dengan kata kunci  out , bagaimana saat kita menandainya dengan dengan kata kunci  in  ?  Nilai dari tipe parameter tersebut bisa dikonsumsi dengan menjadikannya sebagai tipe argumen untuk setiap fungsi yang ada di dalam kelas tersebut dan tidak untuk diproduksi. Contoh dari deklarasinya bisa kita lihat pada kelas  Comparable  pada Kotlin berikut: interface Comparable<in T> {     operator fun compareTo(other: T): Int };Variance dalam Kotlin menggambarkan hubungan antara tipe generic yang memiliki subtipe yang sama namun berbeda tipe argumen. Ada dua jenis variance: covariant (out) dan contravariant (in). Covariant memungkinkan tipe parameter hanya sebagai return type, ditandai dengan kata kunci 'out', seperti pada interface List<out E>. Contravariant memungkinkan tipe parameter hanya sebagai argumen fungsi, ditandai dengan kata kunci 'in', seperti pada interface Comparable<in T>. Konsep ini membantu fleksibilitas dan keamanan tipe dalam pemrograman generic.
"Memasuki modul terakhir ini, kita akan mempelajari dasar concurrency pada Kotlin hingga alasan mengapa developer wajib mencoba  Kotlin Coroutines . Concurrency merupakan sebuah topik yang cukup dalam. Jika dibahas secara menyeluruh mungkin tidak akan cukup di akademi ini. Maka dari itu, modul ini adalah pengantarnya. Diharapkan setelah memahami materi ini, pembaca dapat mengetahui gambaran apa itu concurrency dan perbedaannya pada Kotlin dibandingkan bahasa pemrograman lainnya. Apa itu Concurrency? Concurrency adalah beberapa proses yang terjadi secara bersamaan dalam suatu sistem. Concurrency merupakan suatu fenomena alami yang umum terjadi. Seperti halnya di dunia nyata, banyak kegiatan yang dilakukan pada waktu yang bersamaan. Dengan demikian, ketika kita ingin mengembangkan sebuah sistem untuk membantu kegiatan nyata, tentunya kita harus peduli dengan yang namanya concurrency. Arus lalu lintas bisa menjadi ilustrasi yang tepat untuk menggambarkan proses concurrency. Lalu lintas paralel di jalan yang berbeda hanya akan menimbulkan interaksi dan potensi masalah yang kecil antar kendaraan. Berbeda dengan lalu lintas padat yang biasanya kita jumpai pada persimpangan. Pastinya interaksi dan potensi masalah antar kendaraan akan lebih besar dan membutuhkan koordinasi yang lebih. Begitu pula dalam sebuah sistem aplikasi. Proses paralel yang tidak saling berinteraksi hanya akan menyebabkan masalah concurrency yang sederhana. Berbeda dengan proses yang saling berinteraksi bahkan berbagi sumber daya. Masalahnya tentu lebih kompleks.  Penting untuk memperhatikan beberapa aspek saat berurusan dengan concurrency pada semua sistem. Aspek terpenting adalah mampu mendeteksi dan merespon peristiwa eksternal yang terjadi dalam urutan acak. Selain itu juga pastikan bahwa peristiwa tersebut dapat ditanggapi dalam interval waktu minimum yang diwajibkan. Faktor eksternal sering jadi pendorong dibutuhkannya concurrency. Dalam kehidupan sehari-hari, banyak hal yang terjadi secara bersamaan dan harus ditangani secara  real-time  oleh sistem. Oleh karena itu sistem harus "" reactive "" alias dituntut untuk menanggapi proses yang dihasilkan secara eksternal. Proses tersebut dapat terjadi pada waktu dan urutan yang tak bisa ditentukan. Membangun sistem konvensional untuk mengatasi tugas tersebut, tentunya sangat rumit.  Di dunia komputer, concurrency umumnya terkait dengan banyaknya core atau inti dari prosesor ( CPU ). Pada dasarnya, sebuah komputer memiliki mekanisme sequential atau berurutan untuk menjalankan tugas. Prosesor akan menjalankan satu perintah pada satu waktu. Dengan concurrency, kita bisa memanfaatkan kinerja prosesor dengan lebih optimal. Concurrency memungkinkan sebuah sistem untuk bisa dikendalikan dengan mudah. Sebagai contoh, suatu fungsi bisa dijalankan, dihentikan, ataupun dipengaruhi oleh fungsi lain yang jalan secara bersamaan.";Concurrency adalah konsep komputasi di mana beberapa proses terjadi secara simultan, memungkinkan sistem bereaksi terhadap peristiwa eksternal dengan cepat dan efisien. Terkait dengan jumlah core prosesor, concurrency mengubah mekanisme sequential menjadi paralel, memungkinkan fungsi dijalankan, dihentikan, atau dipengaruhi secara bersamaan. Konsep ini penting untuk mengembangkan sistem responsif yang dapat menangani tugas kompleks dengan optimal, mirip dengan dinamika lalu lintas yang membutuhkan koordinasi dan interaksi antar komponen.
Concurrency vs Parallelism Jika membahas concurrency, tentunya terkait dengan parallelism. Mungkin ada yang bingung mengenai perbedaan antara keduanya. Bagaimanapun, concurrency dan parallelism mempunyai arti yang mirip, yaitu 2 (dua) atau lebih proses yang berjalan pada satu waktu. Namun penting diketahui bahwa concurrency  bukanlah  parallelism. Baik concurrency maupun parallelism, biasanya melibatkan pembuatan thread-thread untuk menjalankan tugas. Thread-thread tersebut bisa dijalankan di satu atau lebih  core . Lalu apakah perbedaan dari keduanya? Concurrency terjadi apabila terdapat 2 (dua) atau lebih proses yang tumpang tindih dalam satu waktu. Ini bisa terjadi jika ada 2 (dua) atau lebih thread yang sedang aktif. Dan jika thread tersebut dijalankan oleh komputer yang hanya memiliki 1 (satu)  core , semua thread tidak akan dijalankan secara paralel. Concurrency memungkinkan sebuah komputer yang hanya memiliki 1 (satu)  core  tampak seakan mengerjakan banyak tugas sekaligus. Padahal sebenarnya tugas-tugas tersebut dilakukan secara bergantian. Sedangkan parallelism terjadi ketika 2 (dua) proses dijalankan pada titik waktu yang sama persis. Parallelism bisa dilakukan jika terdapat 2 (dua) atau lebih thread dan komputer juga memiliki 2 (dua)  core  atau lebih. Sehingga setiap  core  dapat menjalankan perintah dari masing-masing thread secara bersamaan.  Perhatikan beberapa ilustrasi berikut agar Anda lebih memahami perbedaan antara concurrency dan parallelism. Bayangkan Anda di warung kopi dan melihat antrian seperti yang digambarkan pada ilustrasi di atas. Pelanggan dengan masing-masing pesanannya pasti senang jika sang barista bisa melayani dengan tepat dan cepat. Jika pada warung kopi tersebut hanya terdapat seorang barista, otomatis sang barista harus melakukan cara untuk melayani semua pelanggan sekaligus. Pada situasi seperti inilah concurrency dibutuhkan. Karena hanya terdapat seorang barista, maka barista tersebut akan memproses lebih dari satu pesanan secara bersamaan. Hal ini sangat mungkin terjadi karena pembuatan kopi membutuhkan beberapa langkah, dan masing-masing langkah memakan waktu tersendiri. Misalnya menyiapkan air panas, menakar kopi, menyiapkan mesin  espresso , dll. Barista akan membagi langkah-langkah tersebut sehingga seolah-olah ia bisa mengerjakan pesanan secara bersamaan. Berbeda jika sang barista punya teman kerja untuk berbagi tugas. Pada situasi ini parallelism bisa dilakukan. Barista 1 hanya akan melayani beberapa pelanggan, dan sisanya akan dilayani oleh barista 2. Karena kedua barista tersebut telah berbagi tugas, maka mereka akan bertindak secara paralel sehubungan dengan tugas yang lebih besar dalam melayani pelanggan. Bagaimanapun, selama jumlah barista belum sama dengan jumlah pelanggan, concurrency masih tetap diperlukan pada masing-masing barista tersebut. Artinya, parallelism dapat menimbulkan concurrency, tetapi concurrency bisa terjadi tanpa parallelism.;Concurrency dan parallelism adalah konsep pemrosesan tugas, namun memiliki perbedaan signifikan. Concurrency terjadi saat proses tumpang tindih pada satu core, dengan tugas dijalankan bergantian seolah-olah bersamaan. Parallelism mensyaratkan minimal dua core untuk menjalankan proses secara simultan. Seperti seorang barista yang membagi tahapan membuat kopi (concurrency) dibandingkan dua barista yang melayani pelanggan berbeda pada saat yang sama (parallelism).
Process, Thread, I/O-Bound Saat kita mulai menjalankan sebuah aplikasi, sebenarnya sistem operasi akan membuat sebuah proses, kemudian melampirkan sebuah thread padanya, dan setelah itu mulai menjalankan thread tersebut. Semua aktivitas tersebut akan bergantung pada perangkat yang digunakan, terutama perangkat perangkat input dan output ( I/O ). Untuk bisa memahami dan juga menerapkan concurrency dengan benar, developer perlu mempelajari beberapa konsep dasar seperti  Process ,  Thread  dan  I/O bound . Ketiga konsep tersebut saling berhubungan. Oleh karena itu, kita akan mencoba mengulas semua konsep tersebut.  Process Sebuah proses (process) merupakan bagian dari aplikasi yang sedang dijalankan. Setiap kali aplikasi dijalankan, maka saat itu juga proses dijalankan. Tergantung pada sistem operasi yang digunakan, suatu proses dapat terdiri dari beberapa thread yang menjalankan instruksi secara bersamaan. Proses sering dianggap identik dengan program atau aplikasi. Namun, sebenarnya sebuah aplikasi adalah serangkaian proses yang saling bekerja sama. Untuk memfasilitasi komunikasi antar proses, sebagian besar sistem operasi mendukung sumber daya  Inter Process Communication (IPC) , seperti pipes dan soket. Biasanya sistem operasi modern sudah mendukung IPC. IPC digunakan tidak hanya untuk komunikasi antar proses pada sistem yang sama, melainkan juga untuk proses pada sistem yang berbeda. Kita pasti mengenal dengan sebuah konsep yang bernama multitasking atau melakukan banyak tugas secara bersamaan. Saat multitasking, sebenarnya sistem operasi hanya beralih di antara berbagai proses dengan sangat cepat untuk memberikan kesan bahwa proses ini sedang dijalankan secara bersamaan. Sebaliknya,  multiprocessing  adalah metode untuk menggunakan lebih dari satu CPU dalam menjalankan tugas. Dalam concurrency dan parallelism,  multiprocessing  mengacu pada pelaksanaan berbagai proses bersamaan dalam suatu sistem operasi, di mana setiap proses dieksekusi pada CPU terpisah. Oleh karena itu, multiprocessing merupakan tantangan tersendiri bagi developer dalam mengembangkan sebuah aplikasi. Thread Thread biasa dikenal dengan proses yang ringan. Membuat thread baru membutuhkan lebih sedikit sumber daya daripada membuat proses baru. Sebuah thread mencakup serangkaian instruksi untuk dijalankan oleh prosesor. Sehingga suatu proses akan memiliki setidaknya satu thread, yang dibuat untuk mengeksekusi fungsi utama dari sebuah aplikasi. Secara umum, thread tersebut disebut dengan  main thread , dan  life cycle  dari sebuah proses akan terikat padanya. Lebih dari satu thread dapat diimplementasikan dalam proses yang sama, dan dapat dieksekusi secara bersamaan. Perbedaan utama antara proses dan thread adalah bahwa thread biasanya merupakan komponen dari suatu proses. Selain itu, thread biasanya memungkinkan untuk berbagi sumber daya seperti memori dan data. Dimana 2 (dua) hal tersebut jarang dilakukan oleh sebuah proses. Setiap thread dapat mengakses dan memodifikasi sumber daya yang terkandung dalam proses yang dilampirkan, tetapi juga memiliki penyimpanan lokal sendiri, yang biasa disebut dengan  thread-local storage . Hanya satu dari instruksi dalam sebuah thread yang dapat dijalankan pada waktu tertentu. Jadi, jika sebuah thread terblokir, instruksi lain dalam thread yang sama tidak akan dijalankan sampai pemblokiran tersebut berakhir. Namun demikian, banyak thread dapat dibuat untuk proses yang sama, dan mereka dapat berkomunikasi satu sama lain. Jadi diharapkan aplikasi tidak akan pernah memblokir thread yang dapat mempengaruhi pengalaman pengguna secara negatif. Selain main thread, terdapat juga thread lain yang dikenal dengan  UI thread . Thread ini berfungsi untuk memperbarui user interface (antarmuka) dan juga merespon aksi yang diberikan pada aplikasi. Jika thread ini diblokir, maka semua tugasnya akan terhalangi. Oleh karena itu, jangan sampai kita memblokir UI thread agar aplikasi tetap berjalan dengan semestinya. I/O-Bound Bottlenecks  atau kemacetan adalah suatu hal yang penting untuk ditangani demi mengoptimalkan kinerja aplikasi. Bayangkan saja ketika Anda menggunakan sebuah aplikasi dan terjadi  bottleneck  di dalamnya, kesal sendiri kan? Perangkat  input  dan  output  biasanya sering mempengaruhi sebuah aplikasi mengalami  bottlenecks . Sebagai contoh, memori yang terbatas, kecepatan prosesor, dsb. Lalu bagaimanakah cara untuk mengatasinya? I/O-bound merupakan sebuah algoritma yang bergantung pada perangkat input atau output. Waktu untuk mengeksekusi sebuah I/O-bound tergantung pada kecepatan perangkat yang digunakan. Sebagai contoh, suatu algoritma untuk membaca dan menulis sebuah dokumen. Ini adalah operasi I/O yang akan tergantung pada kecepatan di mana berkas tersebut dapat diakses. Berkas yang disimpan pada SSD akan lebih cepat diakses dibandingkan berkas yang disimpan pada HDD. Algoritma I/O-bound akan selalu menunggu sesuatu yang lain. Penantian terus-menerus ini memungkinkan perangkat yang hanya memiliki satu core untuk menggunakan prosesor demi tugas-tugas bermanfaat lainnya sambil menunggu. Jadi algoritma concurrent yang terikat dengan I/O akan melakukan hal yang sama, terlepas dari eksekusi yang terjadi -apakah paralel atau dalam satu  core? Seperti yang telah disebutkan sebelumnya, sangat penting untuk tidak memblokir UI thread dalam sebuah aplikasi. Oleh karena itu, saran kami terapkanlah concurrency jika aplikasi yang Anda kembangkan punya ketergantungan dengan perangkat I/O.;Process adalah bagian aplikasi yang dijalankan, dapat terdiri dari beberapa thread. Thread merupakan unit eksekusi ringan dalam proses, dengan main thread sebagai fungsi utama. I/O-Bound adalah algoritma bergantung pada kecepatan perangkat input/output, yang memungkinkan optimasi kinerja dengan menunggu tanpa memblokir thread utama. Concurrency membantu mengatasi bottlenecks dengan membagi tugas dan memanfaatkan waktu tunggu perangkat.
Permasalahan Pada Concurrency Membuat  concurrent  program ? Banyak developer sering mengeluhkan itu sulit. Selain kodenya bisa dibilang sulit dituliskan, terdapat juga beberapa tantangan yang perlu dihadapi. Ada beberapa permasalahan yang wajib bisa kita tangani pada concurrency, yaitu  deadlocks ,  livelocks ,  starvation  dan juga  race conditions . Deadlocks Untuk menjamin bahwa kode  concurrent  bisa disinkronkan dengan benar, apa salah satu hal yang tidak bisa dihindari ? Kita perlu menunda/memblokir eksekusi saat sebuah perintah diselesaikan di thread yang berbeda. Hal tersebut disebabkan oleh deadlocks, yaitu sebuah kondisi di mana dua proses atau lebih saling menunggu proses yang lain untuk melepaskan  resource  yang sedang digunakan. Deadlocks mengakibatkan proses-proses yang sedang berjalan, tak kunjung selesai. Kasus ini merupakan umum terjadi ketika banyak proses yang saling berbagi sumber daya. Dalam situasi yang bisa dibilang cukup kompleks itu, tak jarang salah satu proses harus terpaksa diberhentikan. Kasus deadlocks sebenarnya bisa kita amati pada kehidupan nyata. Sebagai contoh, perhatikan ilustrasi berikut ini: Ilustrasi di atas menggambarkan antrian dua mobil yang sama-sama akan menyeberangi sebuah jembatan. Jembatan tersebut bisa kita analogikan sebagai sebuah  resource  yang dibutuhkan oleh kedua antrian kendaraan. Karena keduanya saling membutuhkan jembatan dalam waktu yang sama, maka yang terjadi adalah saling menunggu. Alhasil, tak ada kemajuan pada proses antrian tersebut. Mau tidak mau, salah satu kendaraan harus ada yang mengalah atau dikalahkan. Dalam  programming  situasi seperti itu juga umum terjadi. Misal ada 2 (dua) proses yang sama-sama menunggu proses satunya selesai, baru proses tersebut bisa selesai. Sama seperti ilustrasi mobil. Karena keduanya menunggu satu sama lain, tidak ada dari kedua proses tersebut yang akan selesai. Tugas selanjutnya pun tidak akan pernah bisa dijalankan. Dalam sebuah sistem jaringan kerap jadi masalah pemicu deadlocks. Terlebih jika problem tersebut dibarengi race condition. Alhasil, apa yang terjadi? Muncullah kondisi-kondisi tak terduga yang membuat deadlocks jauh lebih rumit dibandingkan dengan masalah antrian proses. Livelocks Sama halnya dengan deadlocks, livelocks juga merupakan kondisi di mana sebuah proses tidak bisa melanjutkan tugasnya. Namun yang membedakannya adalah bahwa selama livelocks terjadi, keadaan dari aplikasi tetap bisa berubah. Walaupun perubahan keadaan tersebut menyebabkan proses berjalan dengan tidak semestinya. Pernahkah suatu ketika Anda berjalan di trotoar dan secara tidak langsung berhadapan dengan orang lain yang berjalan lurus tepat ke arah Anda? Ya, situasi ini pasti sering terjadi dan kadang bisa menjadi  awkward moment . Secara spontan pasti Anda dan orang tersebut akan berusaha menghindari satu sama lain dengan bergerak ke satu sisi. Tak jarang, Anda bergerak ke kiri sementara orang di depan Anda bergerak ke kanan. Dan karena kalian berdua berjalan di arah yang berlawanan, tentunya malah menghalangi jalan masing-masing. Apakah yang akan terjadi selanjutnya? Bisa jadi, Anda akan bergerak ke kanan, dan pada saat yang sama orang itu bergerak ke kiri. Sekali lagi kalian tidak dapat melanjutkan perjalanan. Kejadian tersebut bisa terjadi berulang kali sampai waktu yang tidak diketahui. Livelock bisa terjadi ketika beberapa proses bisa bereaksi saat mengalami deadlocks. Proses tersebut mencoba keluar dari situasi deadlock, namun waktu yang tidak tepat, menghalanginya.;Concurrency memiliki empat tantangan utama: Deadlocks (proses saling menunggu resource), Livelocks (proses berubah namun tidak maju), Starvation (proses tidak mendapat giliran), dan Race Conditions (data tidak konsisten). Deadlocks terjadi ketika dua proses saling menghalangi, seperti mobil yang saling menunggu di jembatan. Livelocks mirip, namun proses masih bergerak tanpa kemajuan, seperti dua orang yang saling menghindar di trotoar namun tidak kunjung lewat.
https://blog.jetbrains.com/kotlin/2018/10/kotlin-1-3/ Coroutines merupakan fitur unggulan pada Kotlin yang diperkenalkan pada Kotlin versi  1.1 . Saat ini coroutines sudah mencapai versi  1.5.1 . Coroutines adalah cara baru untuk menulis kode  asynchronous  dan  non-blocking . Seperti tagline-nya “ Don’t block, Keep moving ” yang dikenalkan pada saat rilis Kotlin versi 1.3.  [9] Kenapa coroutines sering disebut sebagai thread yang ringan? Coroutines juga mendefinisikan eksekusi dari sekumpulan instruksi untuk dieksekusi oleh prosesor. Selain itu, coroutines juga memiliki  life cycle  yang sama dengan thread. Walaupun coroutines dan threads bekerja dengan cara sama, coroutines jauh lebih ringan dan efisien. Jutaan coroutines dapat berjalan pada beberapa threads. Jika dibandingkan dengan threads, coroutines tidak hanya mudah diterapkan, melainkan juga jauh lebih  powerful . Kelebihan tersebut terutama berlaku pada lingkungan  mobile , di mana setiap  milliseconds  kenaikan kinerja sangat diperhitungkan. Selain itu, perbedaan lainnya adalah coroutines dikelola oleh pengguna, sedangkan threads dikelola oleh sistem operasi. Coroutines dijalankan di dalam threads. Satu thread dapat memiliki banyak coroutine di dalamnya. Namun, seperti yang sudah disebutkan, hanya satu instruksi yang dapat dijalankan dalam thread pada waktu tertentu. Artinya, jika Anda memiliki sepuluh coroutines di thread yang sama, hanya satu dari sepuluh coroutines tersebut yang akan berjalan pada titik waktu tertentu. Walaupun coroutines dijalankan dalam sebuah thread, perlu diperhatikan bahwa keduanya tak saling terikat. Menariknya, kita juga bisa menjalankan bagian dari coroutine dalam sebuah thread, menundanya, kemudian melanjutkannya pada thread yang berbeda. Coroutines cukup fleksibel untuk kita menentukan- Apakah suatu thread akan menjalankan sebuah coroutine atau justru menahannya?;"Coroutines adalah fitur asynchronous dan non-blocking yang diperkenalkan di Kotlin versi 1.1. Mereka disebut ""thread ringan"" karena dapat menjalankan jutaan coroutines dalam beberapa threads. Berbeda dengan threads tradisional, coroutines dikelola pengguna, lebih efisien, dan fleksibel. Satu thread dapat memiliki banyak coroutines, namun hanya satu instruksi yang dijalankan pada satu waktu. Keunggulan utamanya adalah kemampuan untuk beralih antar thread dengan mudah, membuat kode asynchronous lebih sederhana dan powerful."
Starvation Starvation merupakan sebuah kondisi yang biasanya terjadi setelah deadlock. Kondisi deadlock sering kali menyebabkan sebuah proses kekurangan sumber daya sehingga mengalami starvation atau kelaparan. Pada kondisi seperti ini, thread tak dapat akses reguler ke sumber daya bersama dan membuat proses terhenti. Selain deadlock, hal lain yang bisa mengakibatkan starvation adalah ketika terjadi kesalahan sistem. Akibatnya, ada ketimpangan dalam pembagian sumber daya. Sebagai contoh, ketika satu proses bisa mendapat sumber daya, namun tidak dengan proses lain. Biasanya, kesalahan seperti itu disebabkan oleh algoritma penjadwalan ( scheduling algorithm ) yang kurang tepat atau bisa juga karena  resource leak  atau kebocoran sumber daya. Salah satu contoh kesalahan algoritma penjadwalan bisa dilihat ketika sebuah sistem multitasking dirancang dengan tidak baik. Apa akibatnya? Dua tugas pertama selalu beralih, sementara yang ketiga tidak pernah berjalan. Tugas ketiga itulah yang bisa dikatakan menderita starvation. Salah satu solusi untuk starvation adalah dengan menerapkan algoritma penjadwalan dengan antrian prioritas ( process priority ) dan juga menerapkan teknik  aging  atau penuaan.  Aging  merupakan sebuah teknik yang secara bertahap meningkatkan prioritas sebuah proses yang menunggu dalam sistem pada waktu yang cukup lama. Race Conditions Pada pembahasan sebelumnya, kita sudah menyinggung istilah race conditions. Kondisi seperti apakah itu? Race condition merupakan masalah umum pada concurrency, yaitu kondisi di mana terdapat banyak thread yang mengakses data yang dibagikan bersama dan mencoba mengubahnya secara bersamaan. Ini bisa terjadi ketika kode  concurrent  yang dituliskan untuk berjalan secara sekuensial. Artinya, sebuah perintah akan selalu dijalankan dalam urutan tertentu. Ketika race condition terjadi, maka sistem bisa saja melakukan proses yang tidak semestinya. Pada saat itu bug akan muncul. Race condition dikenal sebagai masalah yang sulit untuk direproduksi dan di- debug , karena hasil akhirnya tidak deterministik dan tergantung pada waktu relatif dari thread yang menghalangi. Masalah yang muncul pada production bisa jadi tidak ditemukan pada saat  debug . Oleh karena itu, lebih baik menghindari race condition dengan cara berhati-hati saat merencanakan sebuah sistem. Ini lebih baik daripada harus berusaha memperbaikinya setelah itu. Lebih repot.  Contoh sederhana dari race condition bisa kita lihat pada aplikasi perbelanjaan online. Katakanlah Anda menemukan barang yang ingin Anda beli di sebuah toko online. Pada halaman deskripsi, tampil informasi bahwa stok barang hanya sisa 1 (satu). Lalu Anda langsung mengambil keputusan dengan menekan tombol beli. Pada saat yang sama, ada pengguna lain yang ternyata lebih dahulu membelinya. Kondisi seperti inilah yang mengakibatkan sebuah state atau keadaan, berubah tanpa Anda sadari. Jika sistem tidak dirancang sedemikian rupa, maka masalah tak terduga, bisa mengemuka.;Concurrency menghadapi empat tantangan utama: Deadlocks (proses saling menunggu), Livelocks (proses bergerak tanpa kemajuan), Starvation (proses kelaparan sumber daya), dan Race Conditions (data tidak konsisten). Deadlocks terjadi saat proses saling menghalangi, Livelocks mirip namun proses masih bergerak, Starvation akibat kesalahan algoritma penjadwalan, sedangkan Race Conditions terjadi saat thread mengubah data bersama secara bersamaan. Setiap tantangan memerlukan strategi khusus untuk mencegah dan mengatasi masalah yang kompleks dalam pemrograman paralel.
"Memulai Coroutines Untuk lebih memahami tentang coroutines, mari kita mulai mencobanya langkah demi langkah. Hal pertama yang wajib Anda tahu adalah bahwa coroutines bukanlah bagian dari bahasa Kotlin  [10] . Coroutines hanyalah  library  lain yang disediakan oleh  JetBrains . Untuk itu, agar bisa menggunakannya Anda perlu menambahkan dependensi berikut pada  build.gradle.kts : dependencies {     implementation(""org.jetbrains.kotlinx:kotlinx-coroutines-core:1.5.1"") } Dengan menambahkan dependensi di atas, kini Anda sudah siap untuk mencoba menggunakan fitur-fitur coroutines dalam membuat program concurrency. Yuk kita mulai dari kode yang sangat sederhana berikut ini: import kotlinx.coroutines.*  fun main() = runBlocking{     launch {         delay(1000L)         println(""Coroutines!"")     }     println(""Hello,"")     delay(2000L) } Kode di atas menggambarkan bagaimana coroutines bekerja. Kita menggunakan fungsi  runBlocking  untuk memulai coroutine utama dan  launch  untuk menjalankan coroutine baru. Jika Anda menjalankan program tersebut, maka konsol akan menampilkan hasil ini: Hello, Coroutines! Kata  Hello , akan ditampilkan lebih awal dan kata  Coroutines!  Akan ditampilkan 1 detik setelahnya. Mengapa demikian? Padahal jika diperhatikan, kode untuk menampilkan kata  Coroutines!  dituliskan lebih dulu. Fungsi  delay(1000L)  di dalam  launch  digunakan untuk menunda kode berikutnya selama 1 detik.  delay  adalah fungsi yang spesial pada coroutines. Ia merupakan sebuah  suspending function  yang tidak akan memblokir sebuah thread. Selama proses penundaan tersebut, main thread akan terus berjalan sehingga fungsi  println(""Hello,"")  akan langsung dijalankan. Setelah 1 detik, baru fungsi  println(""Coroutines!"")  akan dijalankan. Sedangkan kode  delay(2000L)  digunakan untuk menunda selama 2 detik sebelum JVM berakhir.  Ini baru sekedar permulaan loh. Masih banyak lagi fungsi-fungsi menarik lain pada coroutines yang dapat mempermudah kita dalam membuat program concurrency. Anda bisa memanfaatkan kumpulan  library  yang dapat ditemukan pada repositori  kotlinx.coroutines . JetBrains selaku tim pengembang juga berkomitmen untuk mempertahankan  backward compatibility  untuk tiap perubahan yang akan dirilis. Itulah mengapa coroutines sudah diperkenalkan sejak Kotlin versi 1.1 dan dirilis resmi pada versi 1.3. Tersedia juga panduan resmi untuk langkah-langkah penerapan coroutines. Ikuti saja  tautan ini .";Coroutines adalah library dari JetBrains yang memudahkan pemrograman concurrency di Kotlin. Untuk menggunakannya, tambahkan dependensi kotlinx-coroutines-core di build.gradle.kts. Contoh sederhana menunjukkan cara kerja coroutines menggunakan runBlocking dan launch. Fungsi delay() adalah suspending function yang tidak memblokir thread, memungkinkan eksekusi non-blocking. Coroutines menyediakan cara mudah menangani tugas asynchronous tanpa kompleksitas thread tradisional, dengan JetBrains menjamin backward compatibility dalam setiap rilisnya.
"Coroutines Builder Pada s ub-modul  sebelumnya kita sudah mencoba menggunakan fungsi  runBlocking  dan  launch  untuk memulai sebuah coroutines. Kedua fungsi tersebut merupakan coroutines builder, yaitu sebuah fungsi yang mengambil suspending lambda dan membuat coroutine untuk menjalankannya. Kotlin menyediakan beberapa coroutine builder yang bisa disesuaikan dengan berbagai macam skenario, seperti: launch Seperti yang sudah kita coba sebelumnya, fungsi ini digunakan untuk memulai sebuah coroutines yang tidak akan mengembalikan sebuah hasil.  launch  akan menghasilkan  Job  yang bisa kita gunakan untuk membatalkan eksekusi. runBlocking Fungsi ini dibuat untuk menjembatani  blocking code  menjadi kode yang dapat ditangguhkan.  runBlocking  akan memblokir sebuah thread yang sedang berjalan hingga eksekusi coroutine selesai. Seperti contoh sebelumnya, kita bisa menggunakannya pada fungsi  main()  dan bisa juga untuk penerapan  unit test .  async Kebalikan dari  launch , fungsi ini digunakan untuk memulai sebuah coroutine yang akan mengembalikan sebuah hasil. Ketika menggunakannya, Anda harus berhati-hati karena ia akan menangkap setiap  exception  yang terjadi di dalam coroutine. Jadi  async  akan mengembalikan  Deferred  yang berisi hasil atau  exception . Ketika yang dikembalikan adalah  exception , maka Anda harus siap untuk menanganinya. Sekarang giliran kita untuk mencoba contoh penerapan coroutine dengan  async . Bayangkan jika kita memiliki 2 (dua)  suspending function  seperti berikut: suspend fun getCapital(): Int {     delay(1000L)     return 50000 }  suspend fun getIncome(): Int {     delay(1000L)     return 75000 } Anggap saja bahwa  delay  pada kedua fungsi tersebut adalah waktu yang dibutuhkan untuk melakukan operasi sebelum hasilnya didapatkan. Selanjutnya kita ingin memanfaatkan keduanya, misalnya untuk menghitung keuntungan seperti berikut: import kotlinx.coroutines.*  fun main() = runBlocking {     val capital = getCapital()     val income = getIncome()     println(""Your profit is ${income - capital}"") } Pada kode di atas, kita menggunakan pendekatan  sequential . Kenapa? Pada dasarnya kode di dalam coroutines juga dijalankan secara berurutan seperti kode normal lain. Dalam praktiknya kita melakukan ini jika kita menggunakan hasil dari fungsi pertama untuk membuat keputusan apakah kita perlu memanggil fungsi kedua. Bagaimana jika tidak ada ketergantungan antara fungsi  getCapital  dan  getIncome  dan kita ingin menjalankan keduanya secara bersamaan? Di sinilah  async  dibutuhkan. Kita bisa menuliskan kode seperti berikut: import kotlinx.coroutines.*  fun main() = runBlocking {     val capital = async { getCapital() }     val income = async { getIncome() }     println(""Your profit is ${income.await() - capital.await()}"") } Dengan kode tersebut, kita telah memanggil fungsi  getCapital  dan  getIncome  di dalam  async. Maka  async  akan mengembalikan hasil dari masing-masing fungsi. Lalu untuk mengakses hasil tersebut, kita perlu menggunakan fungsi  await . Wait..  adakah perbedaan dengan kode sebelumnya? Dengan  async  seolah-olah kedua fungsi tersebut berjalan bersamaan dan membutuhkan waktu yang lebih singkat dari kode sebelumnya. Untuk membuktikannya, yuk coba jalankan kode berikut: import kotlinx.coroutines.* import kotlin.system.measureTimeMillis  fun main() = runBlocking {     val timeOne = measureTimeMillis {         val capital = getCapital()         val income = getIncome()         println(""Your profit is ${income - capital}"")     }      val timeTwo = measureTimeMillis {         val capital = async { getCapital() }         val income = async { getIncome() }         println(""Your profit is ${income.await() - capital.await()}"")     }      println(""Completed in $timeOne ms vs $timeTwo ms"")  } Konsol akan menampilkan hasil berikut: Your profit is 25000 Your profit is 25000 Completed in 2013 ms vs 1025 ms Kita bisa lihat bahwa kode yang dijalankan di dalam  async  bisa selesai hampir 2 kali lebih cepat dibandingkan tanpa  async !";Kotlin menyediakan tiga coroutines builder utama: launch, runBlocking, dan async. Launch digunakan untuk memulai coroutine tanpa mengembalikan hasil, runBlocking menghubungkan kode blocking dengan suspending, sedangkan async memungkinkan menjalankan tugas bersamaan dan mengembalikan hasil. Async sangat efisien untuk operasi independen, dapat mengurangi waktu eksekusi hampir setengah dari metode sequential. Contoh sederhana menunjukkan async dapat menjalankan getCapital() dan getIncome() secara paralel, menghasilkan waktu proses lebih cepat dibandingkan eksekusi berurutan.
Job dan Deferred Secara umum, fungsi  asynchronous  pada coroutines terbagi menjadi 2 (dua) jenis, yaitu fungsi yang mengembalikan hasil dan sebaliknya, fungsi yang tidak mengembalikan hasil. Fungsi yang mengembalikan hasil biasanya digunakan jika kita menginginkan sebuah data ketika fungsi tersebut selesai dijalankan. Sebagai contoh, fungsi untuk mengambil informasi dari  web   service  yang menghasilkan respon berupa  JSON  atau yang lainnya. Sedangkan fungsi yang tidak mengembalikan hasil biasanya digunakan untuk mengirimkan analitik, menuliskan log, atau tugas sejenis lainnya. Sebagai developer, tentunya kita menginginkan tetap bisa mengakses fungsi yang sudah dijalankan. Misalnya, ketika kita ingin membatalkan tugasnya atau memberikan instruksi tambahan ketika fungsi tersebut telah mencapai kondisi tertentu. Untuk bisa melakukannya, Anda perlu memahami tentang  Job  dan  Deferred  pada coroutines. Job Job adalah sebuah hasil dari perintah  asynchronous  yang dijalankan. Objek dari job akan merepresentasikan coroutine yang sebenarnya. Sebuah job akan memiliki 3 (tiga) properti yang nantinya bisa dipetakan ke dalam setiap  state  atau keadaan. Berikut adalah ketiga properti tersebut: isActive Sebuah properti yang menunjukkan ketika sebuah job sedang aktif. isCompleted Sebuah properti yang menunjukkan ketika sebuah job telah selesai. isCancelled Sebuah properti yang menunjukkan ketika sebuah job telah dibatalkan. Pada dasarnya, job akan segera dijalankan setelah ia dibuat. Namun kita juga bisa membuat sebuah job tanpa menjalankannya. Job memiliki beberapa siklus hidup mulai dari pertama kali ia dibuat hingga akhirnya selesai. Kira-kira seperti inilah siklus dari sebuah job jika digambarkan dalam sebuah diagram: Dari diagram di atas, kita bisa melihat bahwa job akan melewati beberapa  state . Pada setiap state tersebut nantinya kita bisa memberikan instruksi sesuai yang kita inginkan. Sebelum kita mengolahnya, mari pahami terlebih dahulu semua state yang ada pada sebuah job. New Keadaan di mana sebuah job telah diinisialisasi namun belum pernah dijalankan. Active Sebuah job akan memiliki status aktif ketika ia sedang berjalan. Dalam hal ini, job yang sedang ditangguhkan ( suspended job ) juga termasuk ke dalam job yang aktif. Completed Ketika job sudah tidak berjalan lagi. Ini berlaku untuk job yang berakhir secara normal, dibatalkan, ataupun karena suatu pengecualian. Cancelling Suatu kondisi ketika fungsi  cancel()  dipanggil pada job yang sedang aktif dan memerlukan waktu untuk pembatalan tersebut selesai. Cancelled Keadaan yang dimiliki oleh sebuah job yang sudah berhasil dibatalkan. Perlu diketahui bahwa job yang dibatalkan juga dapat dianggap sebagai  Completed  job.;Job dan Deferred adalah konsep kunci dalam coroutines Kotlin untuk mengelola tugas asynchronous. Job mewakili coroutine yang sedang berjalan dengan state seperti New, Active, Completed, Cancelling, dan Cancelled, memungkinkan kontrol dan pelacakan eksekusi. Deferred, sebagai turunan Job, fokus pada pengembalian hasil dengan metode await(). Keduanya memberikan mekanisme untuk mengatur, membatalkan, dan memantau proses asynchronous secara efisien, memudahkan pengembang dalam menangani operasi konkuren dengan lebih baik dan terstruktur.
"Membuat Job Baru Job dapat diinisialisasikan menggunakan fungsi  launch()  maupun  Job()  seperti berikut: //menggunakan launch(): fun main() = runBlocking {     val job = launch {         // Do background task here     } }  //menggunakan Job(): fun main() = runBlocking {     val job = Job() } Setelah diinisialisasikan, job akan memiliki  state   New  dan akan langsung dijalankan. Jika Anda ingin membuat sebuah job tanpa langsung menjalankannya, Anda bisa memanfaatkan  CoroutineStart.LAZY  seperti berikut: fun main() = runBlocking {     val job = launch(start = CoroutineStart.LAZY) {         TODO(""Not implemented yet!"")     } } Dengan begitu job tersebut bisa dijalankan saat nanti dibutuhkan. Menjalankan Job Setelah membuat sebuah job, kini kita bisa mulai menjalankan job tersebut. Caranya pun cukup sederhana, kita bisa menggunakan fungsi  start()  seperti berikut: fun main() = runBlocking {     val job = launch(start = CoroutineStart.LAZY) {         delay(1000L)         println(""Start new job!"")     }      job.start()     println(""Other task"") } Atau bisa juga dengan menggunakan fungsi  join() : fun main() = runBlocking {     val job = launch(start = CoroutineStart.LAZY) {         delay(1000L)         println(""Start new job!"")     }      job.join()     println(""Other task"") } Perbedaan dari keduanya adalah bahwa yang  start()  akan memulai job tanpa harus menunggu job tersebut selesai, sedangkan  join()  akan menunda eksekusi sampai job selesai. Jika kode pertama dijalankan, maka konsol akan menampilkan hasil berikut: Other task Start new job! Sedangkan kode kedua akan menampilkan hasil: Start new job! Other task Setelah dijalankan,  job akan memiliki state  Active .";Job dalam Kotlin Coroutines adalah mekanisme untuk mengelola tugas asynchronous. Dapat dibuat menggunakan launch() atau Job(), dengan opsi CoroutineStart.LAZY untuk menunda eksekusi. Metode start() memulai job tanpa menunggu, sementara join() menunda eksekusi hingga job selesai. Setelah diinisialisasi, job berubah dari state New ke Active. Ini memungkinkan kontrol yang fleksibel terhadap jalannya coroutine, memudahkan manajemen tugas konkuren dalam pengembangan aplikasi.
"Membatalkan Job Ibarat pekerjaan di dunia nyata, sebuah job seharusnya bisa dibatalkan. Hanya job yang sedang aktif yang dapat dibatalkan. Anda bisa melakukannya dengan memanggil fungsi  cancel()  seperti berikut: fun main() = runBlocking {     val job = launch {         delay(5000)         println(""Start new job!"")     }      delay(2000)     job.cancel()     println(""Cancelling job..."")     if (job.isCancelled){         println(""Job is cancelled"")     } } Kode di atas menggambarkan sebuah job membutuhkan waktu 5 detik untuk dijalankan. Namun ketika mencapai waktu 2 detik, job tersebut telah dibatalkan. Saat fungsi  cancel()  dipanggil, job akan memasuki  state   Cancelling  sampai pembatalan tersebut berhasil. Kemudian setelah pembatalan berhasil, job akan memiliki  state   Cancelled  dan  Completed . Perlu diketahui bahwa jika  cancel()  dipanggil dalam job baru yang belum dijalankan, job tersebut tidak akan melalui  state   Cancelling , melainkan akan langsung memasuki  state   Cancelled . Kita juga bisa menambahkan parameter terhadap fungsi  cancel() , yaitu parameter  cause  yang bisa digunakan untuk memberitahu kenapa sebuah job dibatalkan. job.cancel(cause = CancellationException(""Time is up!"")) CancellationException  akan mengirimkan nilainya sebagai pengecualian dari job tersebut. Kita pun bisa mengakses nilai tersebut dengan fungsi  getCancellationException . Karena  getCancellationException  masih tahap eksperimen, Anda perlu menambahkan anotasi  @InternalCoroutinesApi . Cobalah modifikasi dan jalankan kode Anda: @InternalCoroutinesApi fun main() = runBlocking {     val job = launch {         delay(5000)         println(""Start new job!"")     }      delay(2000)     job.cancel(cause = CancellationException(""time is up!""))     println(""Cancelling job..."")     if (job.isCancelled){         println(""Job is cancelled because ${job.getCancellationException().message}"")     } } Konsol akan menampilkan hasil berikut: Cancelling job... Job is cancelled because time is up!";Job dalam Kotlin Coroutines dapat dibatalkan menggunakan fungsi cancel() saat job aktif. Pemanggilan cancel() mengubah state job dari Active ke Cancelling, kemudian ke Cancelled. Jika dibatalkan sebelum dijalankan, job langsung masuk state Cancelled. Dapat menambahkan parameter cause untuk menjelaskan alasan pembatalan menggunakan CancellationException. Metode ini memungkinkan kontrol fleksibel terhadap eksekusi coroutine, memudahkan manajemen tugas asynchronous yang tidak lagi diperlukan.
"Deferred Seperti yang sudah disampaikan sebelumnya di bagian coroutines builder,  fungsi  async  akan mengembalikan nilai deferred yang berupa hasil atau  exception . Deferred adalah nilai tangguhan yang dihasilkan dari proses coroutines. Nilai ini nantinya bisa kita kelola sesuai dengan kebutuhan.  Deferred dapat kita ciptakan secara manual. Meskipun begitu, dalam praktiknya, jarang kita membuat deferred secara manual. Biasanya kita hanya bekerja dengan deferred yang dihasilkan oleh  async . Deferred juga memiliki  life cycle  yang sama dengan job. Perbedaannya hanyalah pada tipe hasil yang diberikan. Selain memberikan hasil ketika proses komputasi sukses, ia juga bisa memberikan hasil saat proses tersebut gagal. Hasil dari deferred tersedia ketika mencapai  state   completed  dan dapat diakses dengan fungsi  await . Deferred akan mengirimkan pengecualian jika ia telah gagal. Kita bisa mengakses nilai pengecualian tersebut dengan fungsi  getCompletionExceptionOrNull . Pada dasarnya, nilai deferred juga merupakan sebuah job. Ia diciptakan dan dimulai pada saat coroutines mencapai  state   active . Bagaimanapun, fungsi  async  juga memiliki opsional parameter seperti  CoroutineStart.LAZY  untuk memulainya. Dengan begitu, deferred juga bisa diaktifkan saat fungsi  start ,  join , atau  await  dipanggil. Di s ub-modul  sebelumnya kita sudah membahas kode berikut ini: import kotlinx.coroutines.*  fun main() = runBlocking {     val capital = async { getCapital() }     val income = async { getIncome() }     println(""Your profit is ${income.await() - capital.await()}"") } capital  dan  income  adalah contoh dari nilai deferred yang untuk mengaksesnya kita membutuhkan fungsi  await .";Deferred adalah nilai tangguhan yang dihasilkan dari proses coroutines, biasanya melalui fungsi async(). Memiliki lifecycle mirip job, namun dapat mengembalikan hasil atau exception. Nilai deferred tersedia saat mencapai state completed dan diakses menggunakan fungsi await(). Dapat dibuat dengan parameter opsional seperti CoroutineStart.LAZY untuk mengontrol kapan diaktifkan. Berguna untuk operasi asynchronous yang membutuhkan pengembalian nilai, memungkinkan komputasi paralel dan penanganan hasil atau kesalahan dengan fleksibel.
"Coroutine Dispatcher Seperti yang sudah kita ketahui, coroutines berjalan di atas sebuah thread. Tentunya kita harus mengetahui thread mana yang akan digunakan untuk menjalankan dan melanjutkan sebuah coroutine. Untuk menentukannya kita membutuhkan sebuah  base class  bernama  CoroutineDispatcher . Di dalam kelas tersebut kita akan menemukan beberapa objek yang nantinya bisa digunakan untuk menentukan thread yang berfungsi menjalankan coroutines. Dispatchers.Default Merupakan dispatcher dasar yang digunakan oleh semua  standard builders  seperti  launch ,  async , dll jika tidak ada dispatcher lain yang ditentukan.  Dispatchers.Default  menggunakan kumpulan thread yang ada pada JVM. Pada dasarnya, jumlah maksimal thread yang digunakan adalah sama dengan jumlah  core  dari CPU. Untuk menggunakannya, Anda cukup menggunakan coroutines builder tanpa harus menuliskan dispatcher secara spesifik: launch {     // TODO: Implement suspending lambda here } Namun Anda juga tetap diperbolehkan untuk menuliskannya secara eksplisit: launch(Dispatchers.Default){     // TODO: Implement suspending lambda here } Dispatchers.IO Sebuah dispatcher yang dapat digunakan untuk membongkar pemblokiran operasi I/O. Ia akan menggunakan kumpulan thread yang dibuat berdasarkan permintaan. Anda bisa menerapkannya dengan menambahkan  Dispatchers.IO  pada coroutines builder: launch(Dispatcher.IO){     // TODO: Implement algorithm here } Dispatchers.Unconfined Dispatcher ini akan menjalankan coroutines pada thread yang sedang berjalan sampai mencapai titik penangguhan. Setelah penangguhan, coroutines akan dilanjutkan pada thread dimana komputasi penangguhan yang dipanggil. Sebagai contoh, ketika fungsi  a  memanggil fungsi  b , yang dijalankan dengan dispatcher dalam thread tertentu, fungsi  a  akan dilanjutkan dalam thread yang sama dengan fungsi  b  dijalankan. Perhatikan kode berikut: import kotlinx.coroutines.*  fun main() = runBlocking<Unit> {     launch(Dispatchers.Unconfined) {         println(""Starting in ${Thread.currentThread().name}"")         delay(1000)         println(""Resuming in ${Thread.currentThread().name}"")     }.start() } Jika dijalankan maka konsol akan menampilkan hasil berikut: Starting in main Resuming in kotlinx.coroutines.DefaultExecutor Artinya, coroutine telah dimulai dari main thread, kemudian tertunda oleh fungsi delay selama 1 detik. Setelah itu, coroutine dilanjutkan kembali pada thread  DefaultExecutor . Bersamaan dengan objek-objek tersebut, ada beberapa builder yang dapat digunakan untuk menentukan thread yang dibutuhkan: Single Thread Context Dispatcher ini menjamin bahwa setiap saat coroutine akan dijalankan pada thread yang Anda tentukan. Untuk menerapkannya, Anda bisa memanfaatkan  newSingleThreadContext() seperti kode dibawah ini: import kotlinx.coroutines.*  fun main() = runBlocking<Unit> {     val dispatcher = newSingleThreadContext(""myThread"")     launch(dispatcher) {         println(""Starting in ${Thread.currentThread().name}"")         delay(1000)         println(""Resuming in ${Thread.currentThread().name}"")     }.start() } Jalankan kode tersebut, seharusnya konsol akan menampilkan hasil berikut: Starting in myThread Resuming in myThread Walaupun sudah menjalankan fungsi  delay , coroutine akan tetap berjalan pada  myThread . Thread Pool Sebuah dispatcher yang memiliki kumpulan thread. Ia akan memulai dan melanjutkan coroutine di salah satu thread yang tersedia pada kumpulan tersebut. Runtime akan menentukan thread mana yang tersedia dan juga menentukan bagaimana proses distribusi bebannya. Anda bisa menerapkan thread pool dengan fungsi  newFixedThreadPoolContext()  seperti berikut: import kotlinx.coroutines.*  fun main() = runBlocking<Unit> {     val dispatcher = newFixedThreadPoolContext(3, ""myPool"")      launch(dispatcher) {         println(""Starting in ${Thread.currentThread().name}"")         delay(1000)         println(""Resuming in ${Thread.currentThread().name}"")     }.start() } Pada kode di atas, kita telah menetapkan thread  myPool  sebanyak 3 thread. Runtime akan secara otomatis menentukan pada thread mana coroutine akan dijalankan dan dilanjutkan. Hasil dari kode tersebut adalah: Starting in myPool-1 Resuming in myPool-2";Coroutine Dispatcher mengatur thread untuk menjalankan coroutines dengan beragam pilihan. Dispatchers.Default menggunakan thread pool CPU, Dispatchers.IO untuk operasi I/O, dan Dispatchers.Unconfined berpindah thread sesuai komputasi. Single Thread Context menjamin eksekusi pada thread spesifik, sedangkan Thread Pool mendistribusikan beban di antara beberapa thread. Setiap dispatcher memberikan fleksibilitas dalam mengelola concurrent programming, memungkinkan pengembang mengontrol dengan tepat bagaimana coroutine dijalankan dan dialihkan di antara thread yang tersedia.
"Channels Kita sudah belajar bagaimana membuat dan mengelola coroutines. Seperti kita ketahui, sebuah program dapat memiliki banyak thread dan dalam beberapa thread bisa terdapat jutaan coroutines. Lalu, bagaimana jika ada 2 (dua) coroutines yang saling ingin berinteraksi satu sama lain? Channels adalah jawabnya. Beberapa masalah yang muncul pada concurrency seperti deadlock, race conditions, dan lainnya, sering kali dipicu oleh satu hal, apa itu? Rupanya problem pembagian memori atau sumber daya antar thread. Untuk mengatasinya, banyak  programming language  seperti  Go ,  Dart , dan juga Kotlin telah menyediakan channels. Channels adalah nilai deferred yang menyediakan cara mudah untuk mentransfer nilai tunggal antara coroutine. Pada dasarnya, channels sangat mirip dengan BlockingQueue  [11] . Namun, alih-alih memblokir sebuah thread, channels menangguhkan sebuah coroutine yang jauh lebih ringan. Untuk lebih memahaminya, mari simak kode di bawah ini: import kotlinx.coroutines.* import kotlinx.coroutines.channels.Channel  fun main() = runBlocking(CoroutineName(""main"")) {     val channel = Channel<Int>()     launch(CoroutineName(""v1coroutine"")){         println(""Sending from ${Thread.currentThread().name}"")         for (x in 1..5) channel.send(x * x)     }      repeat(5) { println(channel.receive()) }     println(""received in ${Thread.currentThread().name}"") } Kode di atas akan menghasilkan hasil berikut: Sending from main @v1coroutine#2 1 4 9 16 25 received in main @main#1 Bisa dilihat bahwa pada coroutine  v1coroutine  bahwa channels telah mengirimkan nilai dari hasil komputasi dengan menggunakan fungsi  send . Setelah itu, di coroutine lain ( main ) channel menerima nilai dengan menggunakan fungsi  receive . Kesimpulannya, channels memungkinkan komunikasi yang aman antar kode  concurrent . Ia membuat kode  concurrent  dapat berkomunikasi dengan mengirim dan menerima pesan tanpa harus peduli di thread mana coroutine berjalan.  [12] Selengkapnya tentang channel Anda bisa mempelajarinya pada  tautan ini .";Channels adalah mekanisme komunikasi antar coroutines untuk mentransfer nilai dengan aman, mirip BlockingQueue namun lebih ringan. Menggunakan fungsi send() untuk mengirim dan receive() untuk menerima data antarkoroutine. Channels mengatasi masalah concurrency seperti pembagian memori dan sumber daya antar thread, memungkinkan komunikasi mudah dan efisien tanpa memblokir thread. Cocok untuk pertukaran data antarkoroutine secara aman dan terstruktur, mengurangi risiko race conditions dan deadlock.
"Object Everywhere Pada s ub-modul   Data Types  telah disebutkan bahwa pada Kotlin semua bertindak sebagai objek di mana kita bisa memanggil  member function  dan properti dari sebuah variabel. Objek merupakan hasil realisasi dari sebuah  blueprint  atau  class  yang tentunya memiliki fungsi dan juga properti sama seperti  blueprint -nya. Artinya, dengan membuat objek kita dapat mengakses fungsi dan properti yang terdapat pada kelas tersebut. Pada Kotlin, nilai primitif seperti  String ,  Integer ,  Char ,  Boolean  merupakan sebuah  Object.  Hal ini berbeda dengan bahasa pemrograman lain. Maka dari itu, terdapat sebuah istilah yang terkenal di  Kotlin, yaitu “ Object Everywhere ”. Perhatikan kode berikut: val someString = “Dicoding” Pada kode tersebut kita melakukan pembuatan variabel yang juga merupakan sebuah objek dengan nama  someString . Objek tersebut merupakan realisasi dari kelas  String , maka objek  someString  memiliki fungsi dan properti yang merupakan anggota dari kelas  String . Dari  completion suggestion  yang tersedia pada IntelliJ Idea, kita bisa melihat beberapa fungsi yang dapat digunakan oleh objek  someString . Kita bisa menggunakan fungsi  reverse()  untuk membuat urutan huruf disusun secara terbalik, fungsi  toUpperCase()  yang dapat membuat huruf menjadi kapital atau fungsi  toLowerCase()  yang dapat membuat menjadi huruf kecil. fun main() {     val someString = ""Dicoding""     println(someString.reversed())     println(someString.toUpperCase())     println(someString.toLowerCase()) }  /* Output: gnidociD DICODING dicoding */ Kita juga dapat mengubah tipe data dengan mengakses fungsi yang tersedia dari sebuah objek String.  fun main() {     val someString = ""123""     val someInt = someString.toInt()     val someOtherString = ""12.34""     val someDouble = someOtherString.toDouble()      println(someInt is Int)     println(someDouble is Double) }  /* Output:  true true */ Hasil dari  output  kode menunjukan nilai true pada kedua variabel tersebut, yang artinya kita telah berhasil mengubah suatu tipe data String ke tipe data lainnya dengan menggunakan fungsi yang terdapat pada objek String. Mungkin seperti itulah gambaran mengenai objek. Penting digarisbawahi bahwa objek merupakan realisasi dari sebuah  blueprint  yang tentunya memiliki properti dan fungsi yang sama dengan  blueprint -nya. Salah satu kegunaan objek adalah untuk mengakses berbagai properti dan fungsi pada kelas.";"Di Kotlin, semua tipe data bertindak sebagai objek, termasuk tipe primitif seperti String, Integer, Char, dan Boolean. Setiap objek memiliki fungsi dan properti dari kelasnya sendiri. Misalnya, objek String memiliki metode seperti reversed(), toUpperCase(), toLowerCase(), dan fungsi konversi tipe data (toInt(), toDouble()). Konsep ""Object Everywhere"" memungkinkan manipulasi data dengan mudah dan fleksibel, mengubah cara kerja tradisional pemrograman dengan memberikan kemampuan objek pada semua tipe data."
Class Seperti yang telah dijelaskan dalam pembahasan objek,  C lass  merupakan sebuah  blueprint . Di dalam kelas ini kita mendefinisikan sesuatu yang merupakan  attribute  ataupun  behaviour . Contohnya pada sebuah kelas Kendaraan, atributnya berupa roda, warna, nomor kendaraan, merk, dll. Sedangkan untuk  behaviour  nya yaitu maju, mundur, belok kanan, belok kiri, berhenti. Contoh lainnya pada sebuah kelas  Hewan  atributnya berupa nama, berat, umur, termasuk mamalia atau bukan dll. Sedangkan untuk  behaviour -nya bisa makan, tidur, berjalan, dsb.  Setiap kelas memiliki atribut dan  behaviour . Dalam Kotlin  attributes  lebih sering disebut dengan  properties , sedangkan  behaviour  sering disebut  functions . Properti dalam sebuah kelas memiliki tipe data. Contoh, untuk properti berat pada kelas Hewan dapat bertipe  Double , nama dapat bertipe  String , umur dapat bertipe  Int  dan indikasi mamalia dapat bertipe  Boolean . Jika kelas Hewan kita representasikan dalam bentuk tabel maka akan terlihat seperti: Animal + name: String + weight: Double + age: Int + isMammal: Boolean - eat() - sleep() +  merupakan properti -  merupakan fungsi  Pada pembahasan selanjutnya kita akan mencoba membuat sebuah kelas berdasarkan bentuk tabel di atas. Namun sebelum kita lanjut ke pembahasan berikutnya, mari kita tekankan kembali beberapa hal yang sudah kita pelajari: Class : Merupakan sebuah  blueprint  yang terdapat properti dan fungsi di dalamnya Properties : Karakteristik dari sebuah kelas, memiliki tipe data. Functions : Kemampuan atau aksi dari sebuah kelas.;Kelas adalah blueprint yang mendefinisikan atribut (properties) dan perilaku (functions) suatu objek. Properties memiliki tipe data spesifik seperti String, Double, Int, Boolean, yang menggambarkan karakteristik objek. Functions mendeskripsikan kemampuan atau aksi yang dapat dilakukan objek. Misalnya, kelas Hewan memiliki properties seperti nama, berat, umur, dan isMammal, serta functions seperti eat() dan sleep(). Setiap kelas merepresentasikan model konseptual yang menjelaskan struktur dan perilaku suatu entitas dalam pemrograman.
"Membuat Kelas Untuk mendefinisikan kelas dalam Kotlin, Anda cukup gunakan kata kunci  class  diikuti dengan nama kelas yang akan dibuat. Mari kita buat contoh kelas pada Kotlin: class Animal Sangat mudah bukan? Sekarang kita tambahkan properti dan fungsi pada kelas tersebut. class Animal(val name: String,              val weight: Double,              val age: Int,              val isMammal: Boolean ) {      fun eat(){         println(""$name makan !"")     }      fun sleep() {         println(""$name tidur !"")     } } Lalu untuk membuat sebuah objek dari suatu kelas, Anda bisa perhatikan struktur kode berikut: val nameOfObject = NameOfClass([property1], [property2]) Sama seperti variabel, kita bisa gunakan  val  atau  var , dilanjutkan dengan nama objek yang akan anda buat. Tanda  =  menunjukan bahwa kita akan menginisialisasi suatu objek, kemudian diikuti dengan nama kelas dan tanda kurung. Tanda kurung tersebut menunjukan bahwa kita membuat sebuah objek baru. Di dalam tanda kurung kita dapat menambahkan nilai properti sesuai yang dibutuhkan pada  primary constructor  kelasnya. Maka jika kita coba membuat objek dari kelas yang sudah kita buat, kodenya akan terlihat seperti ini: val dicodingCat = Animal(""Dicoding Miaw"", 4.2, 2,true) Mari kita coba buat kode secara keseluruhan dengan ditambahkan fungsi cetak untuk melihat nilai properti dalam objeknya. class Animal(val name: String,              val weight: Double,              val age: Int,              val isMammal: Boolean ) {      fun eat(){         println(""$name makan!"")     }      fun sleep() {         println(""$name tidur!"")     } }  fun main() {     val dicodingCat = Animal(""Dicoding Miaw"", 4.2, 2,true)     println(""Nama: ${dicodingCat.name}, Berat: ${dicodingCat.weight}, Umur: ${dicodingCat.age}, mamalia: ${dicodingCat.isMammal}"" )     dicodingCat.eat()     dicodingCat.sleep() } Dengan menjalankan program tersebut, maka outputnya sebagai berikut: Nama: Dicoding Miaw, Berat: 4.2, Umur: 2, mamalia: true Dicoding Miaw makan! Dicoding Miaw tidur!";Kelas dalam Kotlin adalah blueprint untuk membuat objek, didefinisikan menggunakan kata kunci 'class' dengan properties dan methods. Properties ditentukan dalam konstruktor primer, mendeskripsikan karakteristik objek, sementara methods menggambarkan perilakunya. Untuk membuat objek, cukup inisialisasi kelas dengan nilai properties yang diperlukan. Setiap objek dapat mengakses properties dan menjalankan methods sesuai definisi kelasnya, memungkinkan pemrograman berorientasi objek yang terstruktur dan mudah dipahami.
"Properties Sebuah kelas dalam Kotlin tentu memiliki properti. Masing - masing kelas memiliki properti yang berbeda. Contoh sebelumnya pada kelas  Animal , properti yang dimiliki berupa  name ,  weight ,  age  dan  isMammal . Sama seperti variabel yang sudah kita pelajari pada s ub-modul   Data Types , properti dapat dideklarasikan sebagai nilai  mutable  dengan menggunakan  var  atau sebagai nilai  read-only  dengan menggunakan  val .  Property Accessor Secara standar ketika properti pada kelas dibuat  mutable , maka Kotlin akan menghasilkan fungsi  getter  dan  setter  pada properti tersebut. Jika properti pada sebuah kelas dibuat  read-only , Kotlin hanya akan menghasilkan fungsi  getter  pada properti tersebut. Namun sebenarnya Anda bisa membuat fungsi  getter  dan  setter  secara manual jika pada kasus tertentu Anda perlu untuk  override  fungsi tersebut. Perhatikan kode berikut: class Animal{     var name: String = ""Dicoding Miaw"" }  fun main(){     val dicodingCat = Animal()     println(""Nama: ${dicodingCat.name}"" )     dicodingCat.name = ""Goose""     println(""Nama: ${dicodingCat.name}"") }  /* output: Nama: Dicoding Miaw Nama: Goose */ Pada kode   ${dicodingCat.name}  sebenarnya terjadi proses pemanggilan fungsi  getter  pada properti  name . Namun kita tidak melakukan  override  pada fungsi  getter   sehingga fungsi tersebut hanya mengembalikan nilai  name  saja. Begitu juga pada kode  dicodingCat.name = ""Goose""  pada kode tersebut terjadi pemanggilan fungsi  setter  pada properti  name .  Tetapi jika kita melakukan  override  pada fungsi  getter  dan juga  setter  , maka kita dapat menambahkan kode lain pada fungsi  getter  sesuai dengan kebutuhan. Mari kita coba modifikasi kode sebelumnya menjadi: class Animal{     var name: String = ""Dicoding Miaw""         get(){             println(""Fungsi Getter terpanggil"")             return field         }         set(value){             println(""Fungsi Setter terpanggil"")             field = value         } }  fun main(){     val dicodingCat = Animal()     println(""Nama: ${dicodingCat.name}"" )     dicodingCat.name = ""Goose""     println(""Nama: ${dicodingCat.name}"") }  /* output: Fungsi Getter terpanggil Nama: Dicoding Miaw Fungsi Setter terpanggil Fungsi Getter terpanggil Nama: Goose */ Urutan pendefinisian fungsi  get()  dan  set()  tidaklah penting, kita dapat mendefinisikan fungsi  get()  tanpa mendefinisikan fungsi  set()  dan juga sebaliknya. Yang terpenting pendeklarasiannya dilakukan setelah mendeklarasikan properti tersebut. Pada fungsi  get() , kita perlu mengembalikan nilai sesuai tipe data dari propertinya atau kita dapat mengembalikan nilai dari properti itu sendiri dengan menggunakan  keyword   field . Sedangkan untuk fungsi  set()  kita memerlukan sebuah parameter. Ini merupakan sebuah nilai baru yang nantinya akan dijadikan nilai properti. Pada kode di atas parameter tersebut ditetapkan dengan nama  value .";Properties dalam Kotlin adalah variabel kelas yang dapat didefinisikan sebagai mutable (var) atau read-only (val), dengan kemampuan otomatis menghasilkan getter dan setter. Anda dapat mengkustomisasi akses dan modifikasi nilai dengan melakukan override pada fungsi getter dan setter, menggunakan 'field' untuk mengembalikan nilai properti. Setiap properti menggambarkan karakteristik objek, memungkinkan kontrol akses dan manipulasi data secara fleksibel dan terstruktur dalam paradigma pemrograman berorientasi objek.
"Ketika suatu objek dibuat, semua properti pada kelas tersebut harus memiliki nilai. Kita dapat langsung menginisialisasi pada properti tertentu atau menginisialisasinya melalui  constructor  (konstruktor). Konstruktor merupakan fungsi spesial yang digunakan untuk menginisialisasi properti yang terdapat pada kelas tersebut.  Terdapat 2 (dua) tipe konstruktor pada Kotlin, yaitu  primary constructor  dan  secondary constructor . Yuk kita coba mempelajarinya bersama. Primary Constructor Seperti namanya, jika kita akan membuat suatu objek dari sebuah kelas dan kelas tersebut memiliki  primary constructor  di dalamnya, maka kita diharuskan mengirim nilai sesuai properti yang dibutuhkan. Penulisan  primary constructor  mirip seperti parameter pada fungsi. Properti cukup dituliskan pada  header class  diawali dengan  var  atau  val . Perhatikan kode berikut: class Animal(val name: String, val weight: Double, val age: Int, val isMammal: Boolean) Pada baris kode tersebut kita tidak hanya membuat sebuah kelas, namun sekaligus menambahkan sebuah  primary constructor  pada kelas tersebut. Sekarang Mari kita coba membuat objek dari kelas tersebut: fun main(){     val dicodingCat = Animal(""Dicoding Miaw"", 4.2, 2, true)     println(""Nama: ${dicodingCat.name}, Berat: ${dicodingCat.weight}, Umur: ${dicodingCat.age}, mamalia: ${dicodingCat.isMammal}"" ) }  /* output:     Nama: Dicoding Miaw, Berat: 4.2, Umur: 2, mamalia: true */ Perhatikan kode di atas. Karena kelas  Animal  memiliki primary constructor, maka saat membuat objeknya kita perlu mengirimkan beberapa nilai yaitu  name ,  weight ,  age  dan  isMammal . Primary constructor  juga dapat memiliki nilai  default , dengan begitu jika kita tidak menetapkan nilai untuk parameter tersebut maka properti tersebut akan memiliki nilai  default . Contohnya, kita bisa memberikan nilai  default  terhadap properti  age . Sehingga ketika pembuatan objek, pengiriman nilai  age  pada  primary constructor  bersifat opsional.  Untuk membuat nilai  default  pada sebuah  primary constructor,  kita perlu menginisialisasi nilai pada saat kita menuliskan properti pada kelas. Perhatikan kode berikut: class Animal(var name: String, var weight: Double, var age: Int = 0, var isMammal: Boolean = true) Kode tersebut menunjukan bahwa kita membuat nilai  default  pada properti  age  yang bernilai  0  dan  isMammal  yang bernilai  true . Sehingga pada pembuatan objek  Animal , kita bisa mengirimkan nilai  name  dan  weight  saja pada  primary constructor . Mari kita coba membuat objek dengan memanfaatkan nilai  default  pada konstruktor. fun main(){     val dicodingCat = Animal(""Dicoding Miaw"", 4.2)     println(""Nama: ${dicodingCat.name}, Berat: ${dicodingCat.weight}, Umur: ${dicodingCat.age}, mamalia: ${dicodingCat.isMammal}"" ) }  /*  output:     Nama: Dicoding Miaw, Berat: 4.2, Umur: 0, mamalia: true */ Hasil dari kode tersebut memperlihatkan bahwa properti  age  dan  isMammal  memiliki nilai  default . Sekali lagi, properti tersebut bersifat  opsional , dengan begitu kita tetap dapat mengirimkan nilai pada properti walaupun telah memiliki nilai  default .  Kita juga dapat secara eksplisit memilih properti yang ingin kita berikan nilai dengan menambahkan nama properti dan tanda  =  sebelum mengisikan nilai properti. val dicodingCat = Animal(""Dicoding Miaw"", 4.2, isMammal =  true) Init block Kotlin menyediakan blok  init  yang memungkinkan kita untuk menuliskan properti di dalam  body class  ketika kita menggunakan  primary constructor . Memang, memiliki kode banyak di dalam  body class  bukanlah hal yang baik. Kotlin bertujuan agar kita dapat menuliskan kode seminimal mungkin. Tapi blok  init  di sini memiliki beberapa fungsi selain menginisialisasi properti kelas.  satu fungsi lainnya adalah untuk membantu dalam memvalidasi sebuah nilai properti sebelum diinisialisasi. Pada kelas  Animal  contohnya, kita dapat melakukan verifikasi bahwa berat dan umur hewan tidak boleh bernilai kurang dari nol. Untuk membuatnya, kita dapat menggunakan  keyword   init  kemudian inisialisasikan semua properti di dalam blok tersebut dengan parameter kelas: class Animal(pName: String, pWeight: Double, pAge: Int, pIsMammal: Boolean){     val name: String     val weight: Double     val age: Int     val isMammal: Boolean      init {         weight = if(pWeight < 0) 0.1 else pWeight         age = if(pAge < 0) 0 else pAge         name = pName         isMammal = pIsMammal     } } Primary constructor  dan  init  harus saling terhubung. Fungsi  init  dijalankan ketika suatu objek dibuat dengan menggunakan  primary constructor . Mari kita coba untuk membuatnya. fun main() {     val dicodingCat = Animal(""Dicoding Miaw"", 4.2, 2, true)     println(""Nama: ${dicodingCat.name}, Berat: ${dicodingCat.weight}, Umur: ${dicodingCat.age}, mamalia: ${dicodingCat.isMammal}"") }  /* output:     Nama: Dicoding Miaw, Berat: 4.2, Umur: 2, mamalia: true */ Perhatikan juga penamaan antara properti pada  body class  dan parameter pada  head class  penamaan antara keduanya harus berbeda agar tidak terjadi ambiguitas. Lantas bagaimana jika kita ingin penamaan keduanya sama? Untuk menghindari ambiguitas kita dapat menggunakan  keyword   this  dalam menginisialisasi properti tersebut dalam blok  init . class Animal(name: String, weight: Double, age: Int, isMammal: Boolean) {     val name: String     val weight: Double     val age: Int     val isMammal: Boolean      init {         this.weight = if(weight < 0) 0.1 else weight         this.age = if(age < 0) 0  else age         this.name = name         this.isMammal = isMammal     } } Kata kunci  this  tersebut merujuk kepada suatu kelas dimana jika kita menggunakannya diikuti dengan nama properti maka kita menunjuk pada properti yang terdapat pada kelas tersebut. Dengan begitu, tidak akan ada ambiguitas walaupun kita menggunakan penamaan yang sama antara properti dan parameter  primary constructor .";Konstruktor adalah fungsi spesial untuk menginisialisasi properti kelas. Kotlin memiliki dua tipe: primary constructor dan secondary constructor. Primary constructor didefinisikan langsung di header kelas dengan properti menggunakan var/val. Konstruktor dapat memiliki nilai default, memungkinkan pembuatan objek dengan parameter opsional. Blok init berguna untuk validasi dan inisialisasi properti sebelum objek dibuat. Kata kunci 'this' digunakan untuk menghindari ambiguitas penamaan antara parameter dan properti kelas.
"Secondary Constructor Secondary constructor  digunakan ketika kita ingin menginisialisasi sebuah kelas dengan cara yang lain. Anda dapat membuat lebih dari satu  secondary constructor . Sebagai contoh, kita bisa menambahkan secondary constructor pada kelas  Animal : class Animal(name: String, weight: Double, age: Int) {     val name: String     val weight: Double     val age: Int     var isMammal: Boolean      init {         this.weight = if(weight < 0) 0.1 else weight         this.age = if(age < 0) 0  else age         this.name = name         this.isMammal = false     }      constructor(name: String, weight: Double, age: Int, isMammal: Boolean) : this(name, weight, age) {         this.isMammal = isMammal     } }  fun main() {     val dicodingCat = Animal(""Dicoding Miaw"", 2.5, 2, true)     println(""Nama: ${dicodingCat.name}, Berat: ${dicodingCat.weight}, Umur: ${dicodingCat.age}, mamalia: ${dicodingCat.isMammal}"")      val dicodingBird = Animal(""Dicoding tweet"", 0.5, 1)     println(""Nama: ${dicodingBird.name}, Berat: ${dicodingBird.weight}, Umur: ${dicodingBird.age}, mamalia: ${dicodingBird.isMammal}"") }  /* output:     Nama: Dicoding Miaw, Berat: 2.5, Umur: 2, mamalia: true     Nama: Dicoding tweet, Berat: 0.5, Umur: 1, mamalia: false */ Dengan begitu, objek Animal dapat diinisialisasi dengan  secondary constructor  ketika nilai  name ,  weight ,  age  dan  isMammal  tersedia. Tetapi jika nilai  isMammal  tidak tersedia,   primary constructor  lah yang akan digunakan dan nilai  isMammal  dapat diinisialisasi pada blok  init  dengan nilai  default . Default Constructor Kotlin secara otomatis membuat sebuah  default constructor  pada kelas jika kita tidak membuat sebuah konstruktor secara manual. Perhatikan kode berikut: class Animal{     val name: String = ""Dicoding Miaw""     val weight: Double = 4.2     val age: Int = 2     val isMammal: Boolean = true }  fun main(){     val dicodingCat = Animal()     println(""Nama: ${dicodingCat.name}, Berat: ${dicodingCat.weight}, Umur: ${dicodingCat.age}, mamalia: ${dicodingCat.isMammal}"" ) }  /* output:     Nama: Dicoding Miaw, Berat: 4.2, Umur: 2, mamalia: true */ Ketika kita membuat sebuah objek,  default konstruktor  akan dipanggil. Konstruktor tersebut akan menginisialisasi properti yang terdapat pada kelas dengan nilai  default .";Secondary constructor digunakan untuk menginisialisasi kelas dengan cara alternatif. Dapat dibuat lebih dari satu secondary constructor. Menggunakan kata kunci 'constructor' dan wajib memanggil primary constructor melalui 'this'. Memungkinkan fleksibilitas dalam pembuatan objek dengan berbagai kombinasi parameter. Jika tidak mendefinisikan konstruktor, Kotlin secara otomatis menyediakan default constructor yang menginisialisasi properti dengan nilai default yang telah ditentukan.
"Inheritances Dalam gambaran dunia nyata, banyak objek yang berbeda tetapi punya kesamaan atau kemiripan tertentu. Contohnya Kucing dan Kambing memiliki banyak kesamaan karena objek tersebut merupakan hewan. Kucing merupakan hewan mamalia, begitu juga dengan kambing. Mungkin yang membedakan objek tersebut adalah cara mereka mencari makanan dan jenis makanan yang dimakan. Sama halnya pada OOP, beberapa objek yang berbeda bisa saja memiliki kesamaan dalam hal tertentu. Di situlah konsep  inheritance  atau  pewarisan  harus diterapkan. Pewarisan dapat mencegah kita melakukan perulangan kode. Untuk lebih memahaminya lihatlah contoh bagan pada sebuah kelas berikut: Cat Fish Snake + name: String + furColor: String + weight: Double + age: Integer + numberOfFeet: Integer + isCarnivore: Boolean + name: String + scaleColor: String + weight: Double + age: Integer + numberOfFin: Integer + isCarnivore: Boolean + name: String + skinColor: String + weight: Double + age: Integer + isToxic: Boolean + isCarnivore: Boolean - eat() - sleep() - playWithHuman() - eat() - sleep() - swim() - eat() - sleep() - bite() Pada bagan tersebut dapat kita lihat pada kelas  Cat ,  Fish  dan  Snake  memiliki beberapa properti yang sama seperti  name ,  weight ,  age ,  isCarnivore  dan juga memiliki beberapa fungsi yang sama seperti  eat()  dan  sleep() .   Jika kita ubah diagram kelas Kucing menjadi sebuah kode maka akan menjadi seperti ini: class Cat(val name: String, val furColor: String, val weight: Double, val age: Integer, val numberOfFeet: Integer, val isCarnivore: Boolean) {     fun eat(){         println(""$name sedang makan!"")     }      fun sleep() {         println(""$name sedang tidur!"")     }      fun playWithHuman() {         println(""$name bermain dengan Manusia!"")     } } Tidak ada masalah dengan kode tersebut, tetapi ketika kita akan membuat kelas dari diagram lainnya contohnya  Fish  maka kita harus menuliskan ulang properti seperti  name ,  weight ,  age  dan properti atau fungsi yang sama lainnya. Hal ini dapat mengurangi efisiensi dalam menuliskan kode.  Dengan teknik  inheritance , kita bisa mengelompokkan properti dan fungsi yang sama. Caranya , buat sebuah kelas baru yang nantinya akan diturunkan sifatnya pada sebuah kelas: Animal + name: String + weight: Double + age: Integer + isCarnivore: Boolean - eat() - sleep() Cat Fish Snake + furColor: String + numberOfFeet: Integer + scaleColor: String + numberOfFin: Integer + skinColor: String + isToxic: Boolean - playWithHuman() - swim() - bite() Ketika kelas  Animal  telah dibuat, kelas lainnya dapat melakukan  extends  pada kelas tersebut. Dalam pewarisan, kelas  Animal  ( main class ) dapat disebut sebagai  super  atau  parent class . Kelas yang melakukan  extends  pada kelas tersebut disebut  child class . Dalam Kotlin untuk melakukan  extends  pada sebuah kelas dapat dilakukan dengan tanda  :  seperti contoh berikut: class ChildClass : ParentClass {  } Mari kita buat kelas  Animal  yang akan berperan sebagai  parent class  seperti berikut:  open class Animal(val name: String, val weight: Double, val age: Int, val isCarnivore: Boolean){      open fun eat(){         println(""$name sedang makan!"")     }      open fun sleep(){         println(""$name sedang tidur!"")     } } Untuk membuat sebuah  super  atau  parent class  kita akan membutuhkan  open class . Kelas pada Kotlin secara  default  bersifat  final , oleh karena itu kita harus mengubahnya menjadi  open class  sebelum melakukan  extends  kelas tersebut.  Ubahlah kelas  Cat  dengan melakukan  extends  pada kelas  Animal  seperti berikut: class Cat(pName: String, pWeight: Double, pAge: Int, pIsCarnivore: Boolean, val furColor: String, val numberOfFeet: Int)     : Animal(pName, pWeight, pAge, pIsCarnivore) {      fun playWithHuman() {         println(""$name bermain bersama Manusia !"")     }      override fun eat(){         println(""$name sedang memakan ikan !"")     }      override fun sleep() {         println(""$name sedang tidur di bantal !"")     } } Dengan begitu, selain fungsi yang terdapat di dalamnya, kelas  Cat  juga dapat mengakses seluruh fungsi dan properti yang terdapat kelas  Animal . fun main(){     val dicodingCat = Cat(""Dicoding Miaw"", 3.2, 2, true, ""Brown"", 4)      dicodingCat.playWithHuman()     dicodingCat.eat()     dicodingCat.sleep() }  /* output:     Dicoding Miaw bermain bersama Manusia !     Dicoding Miaw sedang memakan ikan !     Dicoding Miaw sedang tidur di bantal ! */";Inheritance adalah konsep pewarisan properti dan metode dari kelas induk ke kelas anak. Membantu mengurangi pengulangan kode dengan mengelompokkan fitur umum dalam satu kelas dasar. Menggunakan kata kunci 'open' untuk membuat kelas yang dapat diwariskan, dan ':' untuk melakukan extends. Kelas anak dapat mengakses properti dan metode kelas induk, serta menimpa (override) metode yang sudah ada. Contohnya, kelas Animal sebagai kelas induk, dan kelas Cat sebagai kelas anak yang mewarisi sifat-sifat dasar hewan dengan tambahan karakteristik spesifiknya sendiri.
"Abstract Class Seperti namanya,  abstract  merupakan gambaran umum dari sebuah kelas. Ia tidak dapat direalisasikan dalam sebuah objek. Pada s ub-modul  sebelumnya kita sudah mempunyai kelas  Animal.  Secara harfiah hewan merupakan sebuah sifat. Kita tidak tahu bagaimana objek hewan tersebut. Kita tahu bentuk kucing, ikan dan ular seperti apa tetapi tidak untuk hewan. Maka dari itu konsep  abstract class  perlu diterapkan agar kelas  Animal  tidak dapat direalisasikan dalam bentuk objek namun tetap dapat menurunkan sifatnya kepada  child class -nya. Untuk menjadikan sebuah kelas  abstract,  kita hanya perlu menambahkan  keyword   abstract  sebelum menuliskan nama kelas: abstract class Animal(var name: String, var weight: Double, var age: Int, var isCarnivore: Boolean){      fun eat(){         println(""$name sedang makan !"")     }      fun sleep(){         println(""$name sedang tidur !"")     } } Dengan begitu kelas  Animal  tidak dapat kita inisialisasikan menjadi sebuah objek.  fun main(){     val animal = Animal(""dicoding animal"", 2.6, 1, true) } Ketika kita mencoba membuat objek dari kelas Animal, akan terdapat eror berikut: Cannot create an instance of an abstract class";Abstract class dalam Kotlin adalah kelas yang tidak dapat diinstansiasi langsung, digunakan untuk membuat kerangka umum yang dapat diwariskan ke kelas turunan. Dideklarasikan dengan kata kunci 'abstract', dapat memiliki metode konkret dan abstrak. Kelas turunan wajib mengimplementasikan metode abstrak. Berguna untuk mendefinisikan struktur dasar, memaksa implementasi metode tertentu, dan mengurangi pengulangan kode. Contohnya, kelas Animal abstrak dapat memiliki metode konkret sleep() dan metode abstrak makeSound() yang wajib diimplementasikan oleh kelas turunan seperti Cat.
"Visibility Modifiers Kali ini kita akan mengenal beberapa tentang  visibility  modifiers  atau hak akses Pada Kotlin. Tentunya, tidak semua properti dan fungsi pada sebuah kelas memiliki hak akses publik. Ada beberapa yang hanya dapat diakses dari dalam dan ada yang dapat diakses dari luar kelasnya. Dengan menentukan hak akses tersebut, kita dapat membatasi akses data pada sebuah kelas. Berikut macam - macam hak akses dan penjelasan singkatnya yang dapat digunakan pada Kotlin: Public : Hak akses yang cakupannya paling luas. Anggota yang diberi  modifier  ini dapat diakses dari manapun. Private : Hak akses yang cakupannya paling terbatas. Anggota yang menerapkannya hanya dapat diakses pada  scope  yang sama. Protected : Hak akses yang cakupannya terbatas pada hirarki kelas. Anggota hanya dapat diakses pada kelas turunannya atau kelas itu sendiri. Internal : Hak akses yang cakupannya terbatas pada satu modul. Anggota yang menggunakannya tidak dapat diakses diluar dari modulnya tersebut. Semua  modifier  tersebut bisa digunakan untuk kelas, objek, konstruktor, fungsi, beserta properti yang ada di dalamnya. Kecuali modifier protected yang hanya bisa digunakan untuk anggota di dalam sebuah kelas dan  interface . Protected tidak bisa digunakan pada  package   member  seperti kelas, objek, dan yang lainnya. Setelah mengetahui pentingnya hak akses, selanjutnya kita akan membahas bagaimana kita menentukan hak akses public, private, protected dan internal pada Kotlin. Public Berbeda dengan bahasa pemrograman umumnya,  default modifier  pada Kotlin adalah  public . Ketika sebuah anggota memiliki hak akses public maka anggota tersebut dapat diakses dari luar kelasnya melalui sebuah objek kelas tersebut. Pada pembahasan sebelumnya kita sudah memiliki sebuah kelas  Animal  dengan properti publik seperti  name ,  age ,  weight  dan  isMammal . Properti tersebut dapat kita akses dari luar kelas  Animal . Dari  completion suggestion  terlihat bahwa properti tersebut dapat kita akses di luar dari kelasnya.  Private Ketika suatu anggota memiliki hak akses private, maka anggota tersebut tidak dapat diakses dari luar  scope -nya. Untuk menggunakan  modifier  private kita perlu menambahkan  keyword   private  seperti contoh berikut: private var name: String Mari kita coba ubah hak akses pada seluruh properti kelas  Animal  menjadi private. class Animal(private val name: String, private val weight: Double, private val age: Int, private val isMammal: Boolean)  fun main() {     val dicodingCat = Animal(""Dicoding Miaw"", 2.5, 2)     println(""Nama: ${dicodingCat.name}, Berat: ${dicodingCat.weight}, Umur: ${dicodingCat.age}, mamalia: ${dicodingCat.isMammal}"") } Dengan menggunakan hak akses private, maka kita tidak diizinkan untuk mengakses properti pada kelas  Animal  tersebut  dari luar kelasnya. Anda akan berjumpa dengan  eror  Cannot access '[PROPERTY]': it is private in 'Animal' . Satu satunya cara untuk mengakses properti private dari sebuah kelas adalah dengan menambahkan fungsi  getter  dan  setter  secara manual. Fungsi  getter  dan  setter  sebenarnya dihasilkan secara otomatis oleh Kotlin ketika properti tersebut memiliki hak akses public tetapi tidak untuk private. Untuk penulisan  getter  dan  setter  pada hak akses private sama seperti fungsi pada umumnya: fun getName() : String {     return name }  fun setName(newName: String) {     name = newName } Fungsi  getName()  bertujuan untuk mengembalikan nilai  name  yang memiliki tipe data String. Kemudian fungsi  setName()  bertujuan untuk mengubah nilai properti  name  dengan nilai baru. Fungsi  setName()  membutuhkan satu parameter bertipe String yang nantinya akan dimasukkan nilainya ke dalam properti  name . Mari kita coba menerapkannya. class Animal(private var name: String, private val weight: Double, private val age: Int, private val isMammal: Boolean = true) {      fun getName() : String {         return name     }      fun setName(newName: String) {         name = newName     }  }  fun main() {     val dicodingCat = Animal(""Dicoding Miaw"", 2.5, 2)     println(dicodingCat.getName())     dicodingCat.setName(""Gooose"")     println(dicodingCat.getName()) }  /* output:     Dicoding Miaw     Gooose */ Pada kode di atas, terlihat bahwa kita berhasil mengubah nilai properti  name  dari nilai awal yang kita inisialisasikan pada konstruktor. Ia menjadi nilai baru yang kita tentukan dengan menggunakan fungsi  setName() .  Protected Hak akses  protected  mirip seperti  private , namun pembatasannya lebih luas dalam sebuah hirarki kelas. Hak akses protected digunakan ketika kita menginginkan sebuah anggota dari induk kelas dapat diakses hanya oleh kelas yang merupakan turunannya. Perhatikan kode di bawah ini untuk contoh penggunaan hak akses protected. open class Animal(val name: String, protected val weight: Double)  class Cat(pName: String, pWeight: Double) : Animal(pName, pWeight) Pada kode tersebut, properti  weight  pada kelas  Animal  memiliki hak akses protected. Kita tetap bisa mengaksesnya dari kelas  Cat  yang termasuk dalam hirarki kelas  Animal . Namun kita tidak dapat mengakses properti tersebut secara langsung dari luar hirarki kelasnya. Eror akan terjadi jika kita melakukan hal tersebut. fun main() {     val cat = Cat(""Dicoding Miaw"", 2.0)     println(""Nama Kucing: ${cat.name}"")     println(""Berat Kucing: ${cat.weight}"") //Cannot access 'weight': it is protected in 'Cat' } Internal Internal merupakan hak akses baru yang diperkenalkan pada Kotlin. Hak akses ini membatasi suatu anggota untuk dapat diakses hanya pada satu modul. Berikut ini contoh penggunaan hak akses internal: internal class Animal(val name: String) Pada contoh di atas, kelas Animal telah ditetapkan sebagai kelas internal, maka kelas tersebut hanya dapat diakses dari modul yang sama. Hak akses ini sangat berguna ketika kita mengembangkan sebuah aplikasi yang memiliki beberapa modul di dalamnya.";Visibility Modifiers adalah pengatur hak akses dalam Kotlin yang menentukan ruang lingkup aksesibilitas kelas, objek, konstruktor, fungsi, dan properti. Ada empat tipe utama: Public (akses paling luas, default), Private (akses terbatas dalam scope), Protected (akses dalam hirarki kelas), dan Internal (akses dalam satu modul). Setiap modifier membatasi atau membuka akses anggota kelas, membantu mengontrol enkapsulasi dan keamanan data dalam pemrograman berorientasi objek.
Import dan Packages Seluruh konten pada Kotlin, seperti kelas dan fungsi, dibungkus dalam sebuah  package .  Package  tersebut digunakan untuk mengelompokkan kelas, fungsi dan variabel yang mempunyai kemiripan fungsionalitas. Untuk menggunakan kelas, fungsi maupun variabel yang berada pada suatu  package,  kita harus menuliskan secara lengkap alamat  package  tersebut. Sebagai contoh kita akan menggunakan kelas  Random , maka kita harus menuliskan seperti ini: val someInt = kotlin.random.Random(0).nextInt(1, 10) Kode tersebut menunjukkan bahwa kelas  Random  berada pada  package   kotlin.random , tetapi apakah perlu menuliskan kode sepanjang itu untuk menggunakan sebuah kelas? Tentu tidak, untuk meminimalisir hal tersebut kita cukup mengimpor package kelas  Random . Dengan begitu kita tidak perlu menuliskan kode yang panjang secara berulang. Importing Package Untuk mengimpor suatu  package  kelas, fungsi atau variabel, kita cukup menuliskan  keyword   import  kemudian dilanjutkan dengan alamat spesifiknya seperti:  import packagename.ClassName import packagename.functionName import packagename.propertyName Karena kelas  Random  berada pada  package  kotlin.random , maka penulisannya menjadi seperti ini: import kotlin.random.Random Setelah kita impor kelas  Random  beserta alamat  package -nya, kita dapat menuliskan kelas  Random  secara langsung tanpa menulis seluruh alamat  package -nya. Tentunya hal ini akan membuat waktu dalam menuliskan kode lebih efisien. import kotlin.random.Random  val someInt = Random(0).nextInt(1, 10) Biasanya terdapat banyak kelas, fungsi ataupun variabel dalam sebuah  package . Contohnya kita akan menggunakan beberapa fungsi dan variabel matematika pada  package   kotlin.math  seperti berikut: import kotlin.math.PI import kotlin.math.cos import kotlin.math.sqrt  fun main(){     println(PI)     println(cos(120.0))     println(sqrt(9.0)) }  /* Output:     3.141592653589793     0.8141809705265618     3.0 */ Kita juga dapat mengganti nama sebuah kelas, fungsi atau variabel yang kita import dengan menggunakan alias yang direpresentasikan dengan kata kunci  as . import kotlin.math.PI import kotlin.math.cos as cosinus import kotlin.math.sqrt as akar  fun main(){     println(PI)     println(cosinus(120.0))     println(akar(9.0)) }  /* Output:     3.141592653589793     0.8141809705265618     3.0 */ Biasanya  as  digunakan ketika kita menggunakan sebuah kelas, fungsi, maupun variabel yang memiliki nama yang sama namun berbeda  package -nya. Ini bertujuan untuk menghindari ambiguitas. Seperti yang kita ketahui sebelumnya, pada  package   kotlin.math  terdapat banyak fungsi dan variabel yang dapat kita gunakan. Kita bisa melihat pada  completion suggestion  berikut: Kita dapat mengimpor seluruh kelas, fungsi dan variabel yang berada pada suatu  package  dengan menggunakan tanda   *  pada akhir  package  tersebut. import kotlin.math.*  fun main(){     println(PI)     println(cos(120.0))     println(sqrt(9.0)) }   /* Output:     3.141592653589793     0.8141809705265618     3.0 */;Packages dalam Kotlin adalah mekanisme pengelompokan kelas, fungsi, dan variabel berdasarkan fungsionalitas. Untuk menggunakan komponen dari package lain, gunakan kata kunci 'import'. Contoh: 'import kotlin.random.Random' memungkinkan penggunaan kelas Random tanpa menulis alamat package lengkap. Fitur impor mendukung penggunaan spesifik (*), alias (as), dan membantu mengorganisasi kode secara efisien, memudahkan pengembang dalam manajemen struktur proyek.
"Membuat Package Baru Seperti yang diketahui sebelumnya, package merupakan pembungkus dari kelas ( package-level class ), fungsi ( package-level function ) atau variabel ( package-level variable ) berfungsi serupa. Kita juga sudah mengetahui cara mengimpor suatu kelas, fungsi atau variabel yang terdapat pada sebuah  package . Namun kita belum tahu bagaimana  package  tersebut dibuat. Jadi pada pembahasan kali ini kita akan mencoba bagaimana untuk membuat sebuah  package  pada Kotlin. Idealnya sebuah  package  pada Kotlin dituliskan dengan awalan nama domain perusahaan yang dibalik. Contoh,  com.dicoding . Kemudian diikuti dengan nama  package  yang akan digunakan. Untuk membuat sebuah  package  kita perlu membuat folder  package  pada berkas proyek. Perhatikan  Project Tool Window  yang terdapat pada IntelliJ Idea. Klik kanan pada folder  src  kemudian arahkan pada menu  New > package . Setelah itu ketikkan nama  package  yang akan kita buat, misalnya  com.dicoding.oop.utils: Perlu diingat, penamaan package selalu dituliskan dengan  flatcase , tanpa garis bawah dan dipisahkan dengan titik. Dengan menekan tombol “ OK ” maka kita berhasil membuat sebuah  package folder  pada proyek aplikasi kita. Maka struktur proyek akan menjadi seperti ini: Selanjutnya, buatlah sebuah berkas di dalam  package   utils . Disini kita menamai berkas tersebut dengan nama  MyMath.kt . Bukalah berkas tersebut dan perhatikan baris kode yang dihasilkan oleh IntelliJ Idea. Seharusnya kita melihat baris kode berikut pada berkas  MyMath.kt . package com.dicoding.oop.utils fun sayHello() = println(""Hello From package com.dicoding.oop.utils"") Kita sudah membuat sebuah fungsi  sayHello()  pada  package-level . Untuk mengakses fungsi tersebut kita dapat menuliskan secara eksplisit alamat  package . Buatlah sebuah berkas Kotlin dengan nama  Main.kt  pada  package   com.dicoding.oop  kemudian akses fungsi  sayHello()  yang terdapat pada  package   com.dicoding.oop.utils fun main(){     com.dicoding.oop.utils.sayHello() }  /* Output:     Hello From package com.dicoding.oop.utils */ Atau kita dapat menggunakan fungsi tersebut dengan mengimpor  package-level function  tersebut. package com.dicoding.oop  import com.dicoding.oop.utils.sayHello  fun main() {     sayHello() }  /* Output:     Hello From package com.dicoding.oop.utils */ Untuk dapat memahami tentang package lebih lanjut, mari kita buat beberapa fungsi dan variabel pada package tersebut. Buka kembali berkas  MyMath.kt , tambahkan beberapa fungsi dan variabel yang akan kita gunakan nantinya. package com.dicoding.oop.utils  fun sayHello() = println(""Hello From package utils"")  const val PI = 3.1415926535  // package level variable  fun pow(number: Double, power: Double) : Double {     var result = 1.0     var counter = power     while (counter > 0) {         result *= number         counter--     }     return result }  fun factorial(number: Double) : Double {     var result = 1.0     var counter = 1.0     while (counter <= number) {         result *= counter         counter++     }      return result }  fun areaOfCircle(radius: Double) : Double {     return PI * 2 * radius } Panggil beberapa fungsi dan variabel yang sudah ditambahkan pada  MyMath.kt . package com.dicoding.oop  import com.dicoding.oop.utils.PI import com.dicoding.oop.utils.factorial import com.dicoding.oop.utils.pow import com.dicoding.oop.utils.sayHello  fun main() {     sayHello()     println(factorial(4.0))     println(pow(3.0, 2.0))     println(PI) }  /* output:     Hello From package com.dicoding.oop.utils     24.0     9.0     3.1415926535 */ Pada awal kode terlihat saat kita menggunakan suatu fungsi atau variabel yang berada pada package tertentu, kita perlu melakukan impor pada setiap fungsi atau variabelnya. Tetapi jika kita menggunakan seluruh fungsi atau variabel dalam package tertentu kita bisa menggunakan tanda bintang ( * ) untuk melakukan impor pada seluruh fungsi dan variabel di  package  tersebut. Perhatikan kode berikut: package com.dicoding.oop  import com.dicoding.oop.utils.*  fun main() {     sayHello()     println(factorial(4.0))     println(pow(3.0, 2.0))     println(PI)     println(areaOfCircle(13.0)) }  /* output:     Hello From package com.dicoding.oop.utils     24.0     9.0     3.1415926535     81.681408991 */ Dengan memanggil fungsi  areaOfCircle()  maka kita menggunakan seluruh fungsi dan variabel yang berada pada package  com.dicoding.oop.utils , sehingga  import   package  cukup dilakukan dengan menggunakan tanda bintang ( * ).";Package dalam Kotlin dibuat dengan konvensi nama domain terbalik (contoh: com.dicoding), diikuti nama package spesifik. Proses pembuatan package dilakukan melalui IDE dengan membuat folder struktur package. Package berfungsi mengelompokkan kelas, fungsi, dan variabel. Untuk menggunakannya, impor package menggunakan kata kunci 'import', baik secara spesifik maupun keseluruhan dengan tanda (*). Penamaan package menggunakan huruf kecil (flatcase), dipisahkan titik, tanpa garis bawah. Contoh struktur package memungkinkan pengorganisasian kode yang rapi dan terstruktur.
"Kode yang baik yaitu kode yang terhindar dari segala bentuk kejadian dengan efek buruk pada aplikasi kita. Kejadian tersebut pada programming disebut  Exception.  Hal terburuk yang disebabkan oleh  exception  ini adalah dapat terhentinya aplikasi ketika dijalankan. Hal seperti ini seharusnya kita hindari. Nah karena itu kita harus mengetahui cara menangani suatu  exception  (Exception Handling) pada s ub-modul  selanjutnya. Apa itu Exception? Exception  adalah  event  (kejadian) yang dapat mengacaukan jalannya suatu program. Pada Kotlin semua  exception  bersifat  Unchecked , yang artinya  exception  terjadi karena kesalahan pada kode kita. Berikut ini beberapa contoh  Unchecked Exception  yang sering mengganggu jalannya program kita: ArithmeticException NumberFormatException NullPointerException ArithmeticException  merupakan  exception  yang terjadi karena kita membagi suatu bilangan dengan nilai nol. Berikut merupakan contoh kode yang dapat membangkitkan  ArithmeticException . fun main() {     val someValue = 6     println(someValue / 0) }  /* output:     Exception in thread ""main"" java.lang.ArithmeticException: / by zero */ NumberFormatException  disebabkan karena terjadi kesalahan dalam format angka. Sebagai contoh, kita akan mengubah sebuah nilai String menjadi Integer tetapi nilai String yang akan kita ubah tidak memiliki format angka yang benar, sehingga dapat membangkitkan  NumberFormatException . Berikut contoh kodenya: fun main() {     val someStringValue = ""18.0""     println(someStringValue.toInt()) }  /* output:     Exception in thread ""main"" java.lang.NumberFormatException: For input string: ""18.0"" */ Dan yang terakhir adalah  NullPointerException  atau  NPE . Walaupun Kotlin memiliki operator  Null Safety , NPE tetap bisa saja terjadi. NPE terjadi karena sebuah variabel atau objek memiliki nilai  null , padahal seharusnya objek atau variabel tersebut tidak boleh  null . Berikut contoh kasus yang dapat menyebabkan  NullPointerException : fun main() {     val someNullValue: String? = null     val someMustNotNullValue: String = someNullValue!!     println(someMustNotNullValue) }  /* output:     Exception in thread ""main"" kotlin.NullPointerException at MainKt.main(Main.kt:3) */";Exception adalah kejadian yang mengganggu jalannya program, bersifat Unchecked dalam Kotlin. Tiga jenis umum: ArithmeticException (pembagian nol), NumberFormatException (kesalahan format angka), dan NullPointerException (akses objek null). Contohnya seperti membagi angka dengan nol, mengkonversi string tidak sesuai format, atau memaksa variabel null. Kotlin menyediakan mekanisme null safety, namun tetap membutuhkan kehati-hatian untuk menjaga stabilitas aplikasi dan menghindari error yang dapat menghentikan program.
"Exception handling  dapat diterapkan dengan beberapa cara. Di antaranya adalah dengan menggunakan  try-catch ,  try-catch-finally , dan  multiple catch . Mari kita pelajari ketiga cara tersebut. try-catch Salah satu cara untuk menangani suatu  exception  adalah menggunakan  try-catch . Kode yang dapat membangkitkan suatu  exception  disimpan dalam blok  try , dan jika  exception  tersebut terjadi, maka blok  catch  akan terpanggil. Berikut cara penulisan  try-catch  pada Kotlin:  try {     // Block try, menyimpan kode yang membangkitkan exception } catch (e: SomeException) {     // Block catch akan terpanggil ketika exception bangkit. } Dengan menuliskan kode dalam blok  try , kode kita menjadi terproteksi dari  exception . Jika terjadi  exception  maka program tidak akan terhenti atau  crash , namun akan dilempar menuju blok  catch.   Di sana kita dapat menuliskan sebuah kode alternatif untuk menampilkan pesan eror atau yang lainnya. fun main() {     val someNullValue: String? = null     lateinit var someMustNotNullValue: String      try {         someMustNotNullValue = someNullValue!!         println(someMustNotNullValue)     } catch (e: Exception) {         someMustNotNullValue = ""Nilai String Null""         println(someMustNotNullValue)     } }  /* output:     Nilai String Null */ try-catch-finally Selain terdapat blok  try  dan  catch , ada juga blok  finally . Hanya saja blok ini bersifat opsional.  finally  akan dieksekusi setelah program keluar dari blok  try  ataupun  catch . Bahkan  finally  juga tereksekusi ketika terjadi  exception  yang tidak terduga.  Exception  tidak terduga terjadi ketika kita menggunakan  NullPointerException  pada  catch  namun  exception  yang terjadi adalah  NumberFormatException .  Sebagai contoh, mari kita ubah kode yang sebelumnya dengan menerapkan  finally : fun main() {     val someNullValue: String? = null     lateinit var someMustNotNullValue: String      try {         someMustNotNullValue = someNullValue!!     } catch (e: Exception) {         someMustNotNullValue = ""Nilai String Null""     } finally {         println(someMustNotNullValue)     } }  /* output:     Nilai String Null */ Dengan menerapkan  finally , fungsi  println()  cukup dituliskan pada blok  finally . Multiple Catch Dari kode yang kita coba sebelumnya, kita menggunakan  exception  untuk menangani semua tipe  exception  yang terjadi. Baik itu ketika terjadi  NullPointerException  atau  NumberFormatException . Sebenarnya pada catch kita dapat secara spesifik memilih tipe exception apa yang ingin ditangani.  Multiple catch  memungkinkan untuk penanganan  exception  dapat ditangani lebih dari satu tipe  exception . Hal ini sangat berguna ketika kita ingin menangani setiap tipe  exception  dengan perlakuan yang berbeda. Berikut contoh struktur kode dengan menerapkan  multiple catch : try{     // Block try, menyimpan kode yang membangkitkan exception } catch (e: NullPointerException) {     // Block catch akan terpanggil ketika terjadi NullPointerException. } catch (e: NumberFormatException) {     // Block catch akan terpanggil ketika terjadi NumberFormatException. } catch (e: Exception) {     // Block catch akan terpanggil ketika terjadi Exception selain keduanya. } finally {     // Block finally akan terpanggil setelah keluar dari block try atau catch } Dari struktur kode di atas, kita dapat melihat terdapat 3 (tiga) blok  catch . Block  catch  yang pertama menggunakan parameter  NullPointerException , sehingga jika terjadi  NullPointerException  maka blok  catch  tersebut akan dieksekusi. Yang kedua block  catch  dengan parameter  NumberFormatException , sehingga jika terjadi  NumberFormatException  maka blok tersebut yang akan dieksekusi. Dan yang terakhir blok  catch  dengan parameter  Exception , blok ini akan menangani seluruh  exception  yang terjadi kecuali untuk dua  exception  yang telah ditentukan pada blok sebelumnya.  Mari kita coba terapkan contoh kode yang sebelumnya kita buat dengan menggunakan  multiple catch . import kotlin.NumberFormatException  fun main() {     val someStringValue: String? = null     var someIntValue: Int = 0      try {         someIntValue = someStringValue!!.toInt()     } catch (e: NullPointerException) {         someIntValue = 0     } catch (e: NumberFormatException) {         someIntValue = -1     } finally {         when(someIntValue){             0 -> println(""Catch block NullPointerException terpanggil !"")             -1 -> println(""Catch block NumberFormatException terpanggil !"")             else -> println(someIntValue)         }     } }  /* output:     Catch block NullPointerException terpanggil! */ Output  kode di atas menjelaskan bahwa blok  catch  dengan parameter  NullPointerException  terpanggil. Sebabnya, pada variabel  someStringValue  kita menetapkan  null  sebagai nilainya. Berbeda ketika kita menginisialisasi nilai  someStringValue  dengan nilai “ 12.0 ” maka  exception  yang akan terjadi adalah  NumberFormatException  dengan begitu blok  catch  kedua yang akan terpanggil dan akan menghasilkan  output  sebagai berikut: Catch block NumberFormatException terpanggil! Namun jika kedua exception tersebut tidak terjadi, dalam arti nilai  someStringValue  berhasil diubah dalam bentuk Integer, maka output yang dihasilkan adalah nilai dari Integernya tersebut. Contohnya, saat nilai  someStringValue  diinisialisasi dengan nilai “ 12. ” Berikut ini hasilnya. : 12";Exception handling di Kotlin dilakukan melalui tiga metode: try-catch untuk menangkap exception, try-catch-finally untuk eksekusi kode tambahan, dan multiple catch untuk menangani berbagai tipe exception secara spesifik. Setiap metode memungkinkan programmer mengelola error tanpa menghentikan program, dengan cara meletakkan kode berisiko dalam blok try, menangkap exception di blok catch, dan mengeksekusi kode tambahan di blok finally jika diperlukan, sehingga meningkatkan stabilitas dan kehandalan aplikasi.
"Overloading Pada Kotlin menggunakan dua atau lebih fungsi dengan nama yang sama disebut dengan  overloading .  Overloading  dapat dilakukan selama fungsi itu memiliki parameter yang berbeda. Berikut merupakan contoh overloading fungsi  eat()  pada sebuah kelas  Animal . class Animal(private var name: String) {     fun eat() {         println(""$name makan!"")     }      fun eat(typeFood: String) {         println(""$name memakan $typeFood!"")     }      fun eat(typeFood: String, quantity: Double) {         println(""$name memakan $typeFood sebanyak $quantity grams!"")     }      fun sleep() {         println(""$name tidur!"")     } } Pada kelas  Animal  terdapat beberapa fungsi dengan penamaan yang sama, tetapi tidak menyebabkan eror. Sebabnya, fungsi tersebut memiliki parameter yang berbeda sehingga tidak akan terjadi ambiguitas dalam penggunaan fungsi tersebut. Mari kita coba buat sebuah objek dari kelas tersebut dan mengakses fungsinya satu persatu. fun main() {     val dicodingCat = Animal(""Dicoding Miaw"")      dicodingCat.eat()     dicodingCat.eat(""Ikan Tuna"")     dicodingCat.eat(""Ikan Tuna"", 450.0) } Fungsi  eat()  yang pertama dapat digunakan tanpa mengirimkan parameter apapun. Sedangkan fungsi  eat()  yang kedua kita mengirimkan sebuah parameter String sebagai nilai  typeFood . Dan fungsi  eat()  yang terakhir membutuhkan 2 (dua) buah parameter,  typeFood  dan   quantity .  Overloading  pada fungsi merupakan sebuah fitur yang sangat  powerful . Untuk dapat lebih memahami betapa pentingnya  overloading , mari kita buat sebuah kelas  Calculator  yang di dalamnya memiliki fungsi matematika dengan menerapkan  overloading  pada sebuah fungsi. class Calculator {     fun add(value1: Int, value2: Int) = value1 + value2     fun add(value1: Int, value2: Int, value3: Int) = value1 + value2 + value3     fun add(value1: Double, value2: Double) = value1 + value2     fun add(value1: Float, value2: Float) = value1 + value2      fun min(value1: Int, value2: Int) = if (value1 < value2) value1 else value2     fun min(value1: Double, value2: Double) = if (value1 < value2) value1 else value2 } Kemudian kita buat sebuah objek  Calculator  pada  main()  dan mengakses fungsi yang berada pada kelas tersebut. fun main() {     val calc = Calculator()      println(calc.add(2, 4))     println(calc.add(2.5, 2.2))     println(calc.add(6f, 7f))     println(calc.add(1, 2, 3))      println(calc.min(9, 2))     println(calc.min(17.2, 18.3)) }  /* output     6     4.7     13.0     6     2     17.2 */ Pada contoh yang kita buat, fungsi  add(2, 4)  memanggil fungsi  add  yang memiliki parameter  Integer , fungsi  add(2.5, 2.2)  memanggil fungsi  add  yang memiliki parameter  Double , begitu juga dengan yang lainnya.";Overloading di Kotlin memungkinkan penggunaan fungsi dengan nama sama namun parameter berbeda. Hal ini memudahkan programmer membuat fungsi dengan logika serupa untuk tipe data atau jumlah parameter yang berbeda. Contohnya pada kelas Calculator, fungsi add() dapat menerima Integer, Double, Float, dan kombinasi parameter yang berbeda tanpa menimbulkan konflik. Compiler secara otomatis memilih fungsi yang sesuai berdasarkan tipe dan jumlah parameter yang diberikan, meningkatkan fleksibilitas dan kemudahan penggunaan kode.
"Extension Properties Pada materi  Kotlin Functional Programming  kita sudah mengenal bahwa Kotlin dapat meng- extends  sebuah fungsi pada kelas tanpa harus mewarisi kelasnya. Hal ini dilakukan dengan deklarasi khusus yang disebut dengan  Extension . Extension properties pada Kotlin sama halnya seperti melakukannya pada Extension function. Kita dapat menambahkan sebuah properti tanpa harus membuat sebuah kelas yang mewarisi kelas tersebut. Tetapi perlu diingat bahwa properti yang kita buat bukan benar - benar berada pada kelas. Sebabnya, Extension properties dilakukan di luar kelas. Dengan demikian, Extension properties hanya bisa didefinisikan dengan cara menyediakan  getter  dan/atau  setter  secara eksplisit. Mari kita buat sebuah Extension properties pada kelas  Animal . class Animal(var name: String, var weight: Double, var age: Int, var isMammal: Boolean)  val Animal.getAnimalInfo : String     get() =  ""Nama: ${this.name}, Berat: ${this.weight}, Umur: ${this.age} Mamalia: ${this.isMammal}"" Dengan menambahkan Extension properties  getAnimalInfo  pada kelas  Animal , maka kita dapat menggunakan properti tersebut pada sebuah objek kelas  Animal . fun main() {     val dicodingCat = Animal(""Dicoding Miaw"", 5.0, 2, true)     println(dicodingCat.getAnimalInfo) } Dengan menjalankan kode tersebut maka,  output- nya sebagai berikut: Nama: Dicoding Miaw, Berat: 5.0, Umur: 2 Mammalia: true";Extension Properties di Kotlin memungkinkan penambahan properti baru pada kelas yang sudah ada tanpa memodifikasi kelas asli. Properti ekstensi didefinisikan di luar kelas dengan menyediakan getter dan/atau setter secara eksplisit. Berbeda dengan properti biasa, ekstensi properti tidak benar-benar berada di dalam kelas. Contohnya, pada kelas Animal, kita dapat menambahkan properti getAnimalInfo untuk menampilkan informasi lengkap objek tanpa mengubah definisi kelas asli, meningkatkan fleksibilitas dan kemudahan penggunaan kode.
"Interfaces Interfaces merupakan suatu konsep sifat umum yang nantinya digunakan oleh suatu kelas agar dapat memiliki sifat tersebut. Interface sangat mirip dengan  abstract class , namun tanpa sebuah properti deklarasi dan fungsi yang dideklarasikan tanpa isi. Tujuan dari interface ini hanya untuk diimplementasikan oleh sebuah kelas. Kelas yang mengimplementasikan sebuah interface diharuskan melakukan override seluruh properti dan fungsi sekaligus mendefinisikan isi fungsi yang terdapat pada interfaces-nya. Cara pembuatan sebuah interface mirip dengan membuat kelas. Pada umumnya penamaan sebuah interface dituliskan dengan awalan huruf  I  kapital. Hal ini tidak diharuskan secara sintaks tapi ini merupakan penerapan terbaik dalam penamaan sebuah interface. Tujuannya agar dapat mudah membedakannya dengan kelas. Berikut merupakan contoh pembuatan sebuah interface: interface IFly {     fun fly() } Cara mengimplementasikan sebuah interface pada kelas, sama seperti kita melakukan  extends  pada sebuah  super  atau  parent class . Untuk lebih jelasnya, mari kita buat sebuah kelas burung dengan mengimplementasikan interface  IFly : class Bird : IFly {  } Kita akan mendapati eror ketika selesai menuliskan kode tersebut. Pesan eror tersebut mengatakan “ class Bird is not abstract and does not implement abstract member ”. Maksud dari eror tersebut adalah kita harus  mengimplementasi sebuah  abstract member  yang pada kasus ini adalah sebuah fungsi  abstract  yang terdapat pada  IFly . Maka untuk menghilangkan eror tersebut, kita harus melakukan  override  fungsi yang terdapat pada  IFly . class Bird : IFly {     override fun fly() {         println(""I flying without wings"")     } } Untuk menambahkan sebuah properti pada interface, kita cukup menuliskannya seperti pada kelas namun tanpa melakukan inisialisasi nilai: interface IFly {     fun fly()     val numberOfWings: Int } Sama seperti fungsi, kita juga diharuskan melakukan  override  properti.  Overriding  properti bisa dilakukan pada sebuah konstruktor kelas seperti berikut: class Bird(override val numberOfWings: Int) : IFly {      override fun fly() {         if(numberOfWings > 0) println(""Flying with $numberOfWings wings"")         else println(""I'm Flying without wings"")     } } Anonymous Class Seperti namanya, yang dimaksud dengan anonymous ada class yang tak memiliki nama. Alih-alih mendefinisikan class menggunakan keyword  class , Anda bisa langsung mendefinisikan isi dari sebuah class dengan menggunakan keyword  object:  . Supaya lebih paham, perhatikan contoh kode di bawah ini. interface IFly {     fun fly()     val numberOfWings: Int }   class Bird(override val numberOfWings: Int) : IFly {      override fun fly() {         if(numberOfWings > 0) println(""Flying with $numberOfWings wings"")         else println(""I'm Flying without wings"")     } }    fun flyWithWings(bird: IFly) {     bird.fly() }   fun main() {     flyWithWings( Bird(2) ) } Nah, sekarang kita coba ubah kode tersebut dengan menggunakan anonymous class.  interface IFly {     fun fly()     val numberOfWings: Int }  fun flyWithWings(bird: IFly) {     bird.fly() }  fun main() {     flyWithWings( object : IFly {         override fun fly() {             if(numberOfWings > 0) println(""Flying with $numberOfWings wings"")             else println(""I'm Flying without wings"")         }          override val numberOfWings: Int             get() = 2     } ) } Perhatikan bahwa kita tidak membuat class Bird lagi, tetapi langsung mendefinisikan isi dari kelas tersebut dengan menggunakan keyword  object . Jika dilihat, memang tidak ada nama yang diberikan untuk object yang dibuat ini, inilah yang disebut dengan Anonymous Class.  Anda akan sering menemui konsep seperti ketika memasuki dunia pemrograman Android untuk melakukan perintah tertentu ketika ada aksi, seperti ketika tombol ditekan. Proses seperti ini juga sering disebut dengan listener atau callback.  myButton.setOnClickListener(object : OnClickListener{     override fun onClick(p0: View?) {         //melakukan perintah tertentu     } })";"Interfaces di Kotlin adalah kontrak yang mendefinisikan metode dan properti yang harus diimplementasikan oleh kelas. Cara pembuatannya mirip kelas, dengan penamaan biasanya diawali huruf 'I'. Kelas yang mengimplementasi interface wajib melakukan override seluruh fungsi dan properti. Contohnya, interface IFly dengan fungsi fly() dan properti numberOfWings dapat diimplementasikan pada kelas Bird. Anonymous class memungkinkan implementasi interface secara langsung tanpa membuat kelas terpisah, berguna untuk callback atau listener dengan sintaks object : NamaInterface { override fun/properti }. Fitur ini meningkatkan fleksibilitas dan abstraksi dalam pemrograman Kotlin.



"
"Property Delegation Pengelolaan properti kelas baik itu memberikan atau merubah sebuah nilai dapat didelegasikan kepada kelas lain. Dengan ini kita dapat meminimalisir  boilerplate  dalam penulisan  getter  dan  setter  (jika properties menggunakan  var ) pada setiap kelas yang kita buat. Sebagai contoh, kita memiliki tiga buah kelas yang di dalamnya memiliki satu properti String. Jika kita ingin menerapkan  getter  dan  setter  pada setiap properti kelasnya, maka kita perlu menuliskan  getter  dan  setter  tersebut pada seluruh kelas. Hal tersebut dapat mengurangi efisiensi dalam menuliskan kode karena terlalu banyak kode yang harus kita tulis secara berulang. Solusinya, kita perlu membuat sebuah kelas yang memang bertugas untuk mengatur atau mengelola fungsi  getter  dan  setter  untuk sebuah properti kelas. Teknik tersebut pada Kotlin dinamakan  Delegate . Sebelum mendelegasikan sebuah properti kita perlu membuat kelas delegasi terlebih dahulu. Mari kita buat sebuah kelas delegasi. import kotlin.reflect.KProperty   class DelegateName {     private var value: String = ""Default""      operator fun getValue(classRef: Any?, property: KProperty<*>) : String {         println(""Fungsi ini sama seperti getter untuk properti ${property.name} pada class $classRef"")         return value     }      operator fun setValue(classRef: Any?, property: KProperty<*>, newValue: String){         println(""Fungsi ini sama seperti setter untuk properti ${property.name} pada class $classRef"")         println(""Nilai ${property.name} dari: $value akan berubah menjadi $newValue"")         value = newValue     } } Kemudian untuk mendelegasikan sebuah properti kelas, kita gunakan  keyword   by  dalam menginisialisasi properti tersebut kemudian diikuti dengan namanya. Perhatikan kode berikut: class Animal {     var name: String by DelegateName() } Dengan begitu nilai properti  name  dikelola melalui kelas  DelegateName . Kita dapat mendelegasikan banyak properti yang terdapat pada banyak kelas kepada satu kelas Delegate saja. Perhatikan kode berikut untuk untuk lebih jelasnya: class Animal {     var name: String by DelegateName() }  class Person {     var name: String by DelegateName() }  class Hero {     var name: String by DelegateName() } Mari kita membuat sebuah objek, ubah dan akses nilai propertinya pada setiap kelas, kemudian jalankan. Maka hasilnya akan seperti pada kode berikut: fun main() {     val animal = Animal()     animal.name = ""Dicoding Miaw""     println(""Nama Hewan: ${animal.name}"")      val person = Person()     person.name = ""Dimas""     println(""Nama Orang: ${person.name}"")      val hero = Hero()     hero.name = ""Gatotkaca""     println(""Nama Pahlawan: ${hero.name}"") }  /* output:     Fungsi ini sama seperti setter untuk properti name pada class Animal@17f052a3     Nilai name dari: Default akan berubah menjadi Dicoding Miaw     Fungsi ini sama seperti getter untuk properti name pada class Animal@17f052a3     Nama Hewan: Dicoding Miaw     Fungsi ini sama seperti setter untuk properti name pada class Person@2e0fa5d3     Nilai name dari: Default akan berubah menjadi Dimas     Fungsi ini sama seperti getter untuk properti name pada class Person@2e0fa5d3     Nama Orang: Dimas     Fungsi ini sama seperti setter untuk properti name pada class Hero@5010be6     Nilai name dari: Default akan berubah menjadi Gatotkaca     Fungsi ini sama seperti getter untuk properti name pada class Hero@5010be6     Nama Pahlawan: Gatotkaca */ Pada contoh di atas, delegasi hanya dapat digunakan oleh properti yang memiliki tipe data String. Namun kita juga dapat membuat sebuah delegasi kelas umum yang dapat digunakan oleh seluruh tipe data dengan memanfaatkan tipe data  Any . class DelegateGenericClass {     private var value: Any = ""Default""      operator fun getValue(classRef: Any, property: KProperty<*>): Any {         println(""Fungsi ini sama seperti getter untuk properti ${property.name} pada class $classRef"")         return value     }      operator fun setValue(classRef: Any, property: KProperty<*>, newValue: Any) {         println(""Nilai ${property.name} dari: $value akan berubah menjadi $newValue"")         value = newValue     } }  class Animal {     var name: Any by DelegateGenericClass()     var weight: Any by DelegateGenericClass()     var age: Any by DelegateGenericClass() } Kemudian mari kita membuat sebuah objek dari kelas  Animal , ubah dan akses nilai propertinya kemudian jalankan. Maka hasilnya akan seperti pada kode berikut: fun main(){     val animal = Animal()     animal.name = ""Dicoding cat""     animal.weight = 6.2     animal.age = 1      println(""Nama: ${animal.name}"")     println(""Berat: ${animal.weight}"")     println(""Umur: ${animal.age} Tahun"") }  /* output:     Nilai name dari: Default akan berubah menjadi Dicoding cat     Nilai weight dari: Default akan berubah menjadi 6.2     Nilai age dari: Default akan berubah menjadi 1     Fungsi ini sama seperti getter untuk properti name pada class Animal@17f052a3     Nama: Dicoding cat     Fungsi ini sama seperti getter untuk properti weight pada class Animal@17f052a3     Berat: 6.2     Fungsi ini sama seperti getter untuk properti age pada class Animal@17f052a3     Umur: 1 Tahun */ Perhatikan kode diatas, kita telah memberikan nilai pada setiap properti dengan tipe data yang berbeda. Tetapi dengan  DelegateGenericClass() , pengelolaan properti dapat digunakan pada seluruh tipe data properti.  Sip! Itulah penjelasan terkait property delegation yang bakal sering Anda ketika membuat aplikasi Android nanti. Jika tertarik untuk mendalami lebih lanjut, Anda dapat melihat beberapa referensi berikut. How to Kotlin - from the lead Kotlin language designer (Google I/O '18)";Property Delegation di Kotlin memungkinkan pendelegasian pengelolaan properti ke kelas lain menggunakan keyword 'by', mengurangi kode berulang. Dengan membuat kelas delegasi yang mengimplementasikan operator getValue() dan setValue(), pengembang dapat menstandarisasi cara kerja getter dan setter lintas berbagai kelas. Teknik ini memudahkan validasi, logging, dan manajemen properti secara fleksibel, mendukung berbagai tipe data dan memungkinkan implementasi logika khusus untuk setiap properti tanpa menulis ulang kode yang sama berulang kali.
Anatomi Function Pada s ub-modul  pengenalan, kita sudah belajar tentang  function  (fungsi). Mulai dari bagaimana cara kita mendeklarasinya, menentukan apakah fungsi tersebut dapat mengembalikan nilai, serta melampirkan sebuah argumen ketika fungsi tersebut digunakan.  Pada s ub-modul  ini kita akan membahas lebih dalam tentang bagian apa saja yang terdapat dalam sebuah fungsi. Pada dasarnya sebuah fungsi memiliki 2 (dua) bagian utama yaitu  function header  dan  function body . Function Header Function header adalah bagian yang merupakan konstruksi dari sebuah fungsi untuk menentukan perilakunya akan seperti apa. Di dalam function header terdapat  visibility modifier , kata kunci  fun , nama, daftar parameter dan nilai kembalian dari fungsi tersebut. Visibility Modifier Visibility modifier atau tingkatan akses merupakan bagian spesifik dari sebuah bahasa pemrograman yang ditujukan untuk mengatur bagaimana hak akses dari sebuah kelas, fungsi, properti dan variabel. Secara  default  ketika kita membuat sebuah fungsi baru, ia akan memiliki  modifier   public . Artinya fungsi tersebut dapat diakses dari luar kelas. Sedangkan contoh pada ilustrasi di atas adalah sebuah fungsi yang memiliki  modifier   private.  Maka akses dari fungsi tersebut terbatas hanya untuk kelas di mana fungsi tersebut dideklarasi. Terdapat beberapa  visibility modifier  yang akan kita pelajari bersama pada s ub-modul   Object Orientation Programming  nanti. Function Name Setelah  visibility modifier , selanjutnya adalah kata kunci  fun  . Ini digunakan untuk menandakan jika baris kode tersebut merupakan sebuah fungsi yang kemudian diikuti oleh nama dari fungsi tersebut. Nama dari sebuah fungsi merupakan sebuah  identifier  yang akan memudahkan kita untuk menggunakan fungsi tersebut. Perlu diketahui bahwa kita tidak bisa memberikan nama yang sama untuk beberapa fungsi. Untuk penamaan dari sebuah fungsi sendiri menggunakan format penulisan  camelCase . Nama dari fungsi tersebut diawali dengan huruf kecil dan huruf besar untuk kata berikutnya. Ini merupakan standar penulisan resmi yang sudah ditentukan. Function Parameter Ketika kita mendeklarasikan sebuah fungsi baru, kita bisa atau tanpa menetapkan parameter tersebut. Parameter adalah data atau nilai yang disematkan ketika fungsi tersebut dipanggil. Nantinya parameter akan diproses di dalam fungsi tersebut. Kita bisa melampirkan nilai konstan atau variabel untuk sebuah fungsi ketika ia dipanggil. Parameter dari sebuah fungsi terdiri dari nama dan tipe dari parameter itu sendiri. Ia digunakan untuk menentukan nilai atau variabel apa yang dapat dilampirkan. Setiap parameter dipisahkan oleh tanda ( , ). Catatan: setiap parameter bersifat  read-only , sehingga kita hanya diijinkan untuk menggunakan nilainya untuk diproduksi. Function return type Terakhir adalah return type. Setiap fungsi yang kita deklarasi sejatinya akan selalu mengembalikan dan nilai yang akan dikembalikan bisa kita gunakan untuk keperluan lain. Misalnya untuk dijadikan sebagai argumen untuk fungsi lainnya. Lalu apakah tipe ini harus ditentukan setiap deklarasi sebuah fungsi? Tentu tidak. Jika kita tidak menentukan return type, secara implisit fungsi tersebut akan mengembalikan nilai dengan tipe  Unit , yaitu return type yang tidak mengembalikan nilai signifikan. Function Body Setelah function header, selanjutnya adalah  function body , yang ditandai dengan  curly braces.  Di dalamnya kita akan menempatkan sebuah logika kode baik itu sebuah  expression  atau  statement . Seperti yang dijelaskan pada s ub-modul  pengenalan, jika kita menetapkan sebuah fungsi dapat mengembalikan nilai, maka kita wajib menambah sebuah baris kode yang diawali dengan kata kunci return yang diikuti oleh  expression  untuk menetapkan nilai yang akan dikembalikan. Sebaliknya, jika kita tidak ingin mengembalikan nilai, kita tidak perlu menambahkannya seperti yang disebutkan di atas. Setiap fungsi yang kita deklarasikan, memiliki ruang lingkup tersendiri. Contohnya saat kita mendeklarasi sebuah variabel di dalamnya, variabel tersebut akan menjadi variabel lokal untuk fungsi itu sendiri. Dengan demikian, variabel tersebut tidak dapat diakses dari fungsi lainnya meskipun berada di dalam satu kelas yang sama.;Anatomi fungsi di Kotlin terdiri dari dua bagian utama: function header dan function body. Function header mencakup visibility modifier (default public), kata kunci fun, nama fungsi (camelCase), parameter (opsional), dan return type (default Unit). Visibility modifier mengatur hak akses fungsi, parameter menentukan input yang dapat diterima, sedangkan return type menunjukkan tipe nilai yang dikembalikan. Function body, yang dibatasi curly braces, berisi logika kode dan statement. Setiap fungsi memiliki ruang lingkup sendiri, dengan variabel lokal yang hanya dapat diakses dalam fungsi tersebut. Return type dapat diabaikan, namun jika ingin mengembalikan nilai, wajib menggunakan kata kunci return.
"Di beberapa kasus pembuatannya, sebuah fungsi bisa menjadi cukup kompleks dengan banyaknya parameter. Alhasil saat ingin memanggil fungsi tersebut, kita harus menghafal posisi dari parameter agar tidak salah dalam melampirkan sebuah argumen. Named Argument Untuk mengatasi hal ini Kotlin menawarkan sebuah cara. Dengan ini, kita tak perlu lagi menghafal posisi dari sebuah parameter. Karena ketika sebuah fungsi dipanggil, kita bisa menentukan argumen dari parameter mana yang ingin dilampirkan dengan memanggil nama dari parameter tersebut. Misalnya kita mempunyai sebuah fungsi seperti berikut: fun getFullName(first: String, middle: String, last: String): String {     return ""$first $middle $last"" } Nah, dengan memanfaatkan named argument, kita bisa menuliskannya seperti di bawah ini: fun main() {     val fullName = getFullName(first = ""Kotlin"" , middle = "" is "", last = ""Awesome"")     print(fullName) }  fun getFullName(first: String, middle: String, last: String): String {     return ""$first $middle $last"" } Menariknya lagi, kita bisa mengubah posisi dari argumen ketika dilampirkan, misalnya seperti ini: fun main() {     val fullName = getFullName(middle = "" is "" , first = ""Kotlin"", last = ""Awesome"")     print(fullName) }  fun getFullName(first: String, middle: String, last: String): String {     return ""$first $middle $last"" } Dengan cara seperti di atas, kita tidak perlu lagi menghafal posisi dari parameter jika ingin melampirkan sebuah argumen. Cukup hafalkan nama dari parameter tersebut. Default Argument Tidak sampai di situ, Kotlin juga memungkinkan kita untuk menentukan nilai  default  dari sebuah parameter. Jika kita melewatkan argumen untuk dilampirkan, maka nilai  default  tersebut lah yang akan digunakan. Untuk menambahkan nilai default itu sendiri pun cukup mudah, yaitu dengan cara menempatkannya langsung tepat di samping dari parameter seperti halnya ketika ingin menginisialisasikan sebuah nilai untuk variabel. Contohnya seperti berikut: fun getFullName(         first: String = ""Kotlin"",          middle: String = "" is "",          last: String = ""Awesome""): String {     return ""$first $middle $last"" } Kita bisa memanggil fungsi di atas seperti biasanya. Tetapi karena parameternya sudah memiliki nilai, maka argumen untuk fungsi tersebut bisa dilewatkan ketika dipanggil. fun main() {     val fullName = getFullName()     print(fullName) }  fun getFullName(         first: String = ""Kotlin"",          middle: String = "" is "",          last: String = ""Awesome""): String {     return ""$first $middle $last"" }  /*    output : Kotlin is Awesome */ Menarik bukan? Ketika kita telah menetapkan nilai  default , kita tak perlu khawatir saat lupa melampirkan sebuah argumen. Tentunya ini menghindari kita dari eror. Meskipun begitu, kita tetap bisa melampirkan sebuah argumen. Contohnya seperti berikut: fun main() {     val fullName = getFullName(first = ""Dicoding"")     print(fullName) }  fun getFullName(         first: String = ""Kotlin"",          middle: String = "" is "",          last: String = ""Awesome""): String {     return ""$first $middle $last"" }  /*     output : Dicoding is Awesome  */ Dengan memanfaatkan named dan default   argument, kode yang kita tulis lebih mudah dibaca. Ini pun dapat membantu kita dalam menggunakan fungsi yang cukup kompleks.";Kotlin menyediakan fitur Named Argument dan Default Argument untuk menyederhanakan pemanggilan fungsi dengan parameter kompleks. Named Argument memungkinkan pengisian argumen berdasarkan nama parameter tanpa terikat urutan, sementara Default Argument mengizinkan penetapan nilai default pada parameter. Kedua fitur ini meningkatkan fleksibilitas dan keterbacaan kode, memudahkan pengembang dalam mendefinisikan dan memanggil fungsi dengan berbagai variasi parameter, serta mengurangi potensi kesalahan saat menulis kode.
"Vararg (Variable Argument) Selain named dan default argument, Kotlin juga memiliki  vararg (variable argument) . Dengan menggunakan kata kunci  vararg  kita juga bisa menyederhanakan beberapa parameter yang memiliki tipe data yang sama menjadi parameter tunggal.  Dengan   vararg  sebuah fungsi dapat memiliki jumlah parameter berdasarkan jumlah argumen yang kita masukkan ketika fungsi tersebut dipanggil. Contoh dari penggunaan  vararg  adalah sebagai berikut: fun sumNumbers(vararg number: Int): Int {     return number.sum() } Bisa kita perhatikan pada contoh kode di atas bahwa kata kunci  vararg  ditempatkan sebelum nama parameter. Ketika ingin memanggil fungsi tersebut, kita bisa melampirkan beberapa argumen, misal seperti berikut: fun main() {     val number = sumNumbers(10, 20, 30, 40)     print(number) }  fun sumNumbers(vararg number: Int): Int {     return number.sum() }  /*    output : 100 */ Selain itu kita juga bisa menerapkan Generic untuk tipe parameter ketika parameter tersebut ditentukan dengan  vararg . Contohnya seperti berikut: fun <T> asList(vararg input: T): List<T> {     val result = ArrayList<T>()     for (item in input)         result.add(item)     return result } Ketika sebuah parameter ditentukan dengan  vararg , pada dasarnya semua argumen yang dilampirkan, ditampung di dalam sebuah  Array <out T>.  Contohnya bisa kita lihat pada contoh kode di atas.  Karena pada dasarnya adalah sebuah Array, maka kita bisa memanggil fungsi atau properti yang tersedia pada kelas Array dari dalam fungsi tersebut. Misal properti  size : fun main() {     val number = getNumberSize(10, 20, 30, 40, 50)     print(number) }  fun getNumberSize(vararg number: Int): Int {     return number.size }  /*    output : 5 */ Lalu kapan kita membutuhkan  vararg ?  Ketika sebuah fungsi yang menggunakannya tidak mengetahui jumlah argumen yang akan disematkan ketika fungsi tersebut dipanggil. Contoh penerapan bisa kita liat pada fungsi  String.format() ,  di mana fungsi tersebut terdapat parameter yang ditandai dengan  vararg  dan dapat disematkan beberapa argumen tanpa harus tahu batasannya. Aturan pada Vararg Arguments Dalam penggunaannya, terdapat aturan yang perlu kita ketahui. Pertama, di dalam sebuah fungsi, tidak diizinkan untuk memiliki 2 (dua) parameter bertanda  vararg . fun sumNumbers(vararg number: Int, vararg number2: Int) Ketika kode di atas dijalankan, proses kompilasi akan gagal dengan log eror sebagai berikut: Kotlin: Multiple vararg-parameters are prohibited Selanjutnya jika kita ingin menambahkan parameter baru tanpa kata kunci  vararg , parameter yang ditandai dengan  vararg  sebaiknya berada pada posisi terakhir. Contohnya seperti berikut: fun main() {     sets(""Kotlin"", 10, 10) }  fun sets(name: String, vararg number: Int): Int {     ... } Lalu bagaimana jika kita ingin menempatkan parameter yang ditandai  vararg  bukan pada posisi pertama? Kita bisa mendefinisikannya secara langsung. Namun berbeda saat fungsi tersebut dipanggil di mana kita harus menggunakan  named argument  saat ingin melampirkan argumen untuk parameter yang tidak ditandai dengan  vararg . Contohnya seperti berikut: fun main() {     sets(10, 10, name = ""Kotlin"") }  fun sets(vararg number: Int, name: String): Int {     ... } Kenapa demikian? Saat kita tidak menandai argumen tersebut untuk parameter yang mana, kompiler akan menetapkan jika argumen tersebut untuk parameter yang ditandai dengan  vararg . Vararg vs Array<T> Karena semua argumen ditampung di dalam sebuah Array, maka akan muncul pertanyaan, ""Apa bedanya ketika kita menggunakan  Array<T>  sebagai tipe parameter?"" Misal seperti berikut: fun sets(number: Array<Int>){     ... } Dari sini kita bisa lihat langsung letak perbedaannya di mana. Ketika fungsi di atas dipanggil, fungsi tersebut membutuhkan argumen berupa nilai yang sudah berbentuk Array seperti berikut: fun main() {     val number = arrayOf(10, 20, 30, 40)     sets(number) }  fun sets(number: Array<Int>) {     ... } Berbeda ketika kita menggunakan  vararg.  Kita bisa memasukkan argumen satu persatu. Lalu apakah bisa kita memasukkan nilai yang sudah berbentuk Array sebagai argumen untuk parameter yang ditandai dengan  vararg ? Tentu bisa! Dengan memanfaatkan  spread operator  ( * ) seperti berikut: fun main() {     val number = intArrayOf(10, 20, 30, 40)     sets(10, 20, 20, *number , 10) }  fun sets(vararg number: Int): Int {     ... } Dalam penggunaannya,  spread operator  ditempatkan sebelum nama variabel yang ingin dilampirkan.";Vararg (Variable Argument) memungkinkan fungsi menerima jumlah argumen tidak terbatas dengan tipe data sama. Parameter vararg ditandai dengan kata kunci vararg dan ditampung dalam array. Contohnya: fun sumNumbers(vararg number: Int): Int { return number.sum() }. Fungsi ini dapat dipanggil dengan beragam jumlah argumen: sumNumbers(10, 20, 30). Vararg mendukung generic, memiliki aturan spesifik dalam penempatan parameter, dan dapat menggunakan spread operator (*) untuk memasukkan array sebagai argumen. Fitur ini sangat berguna untuk fungsi dengan argumen dinamis seperti String.format().
"Kotlin memungkinkan kita untuk menambahkan sebuah fungsi baru pada sebuah kelas tanpa harus mewarisi kelas tersebut. Misal kita ingin menambahkan fungsi baru untuk kelas Int, maka kita akan menuliskannya seperti berikut: class NewInt : Int(){     fun printInt(){         println(""value $this"")     } } Ketika dijalankan, kode di atas akan gagal dikompilasi, kenapa? Karena kelas  Int  bersifat  final , sehingga tidak memungkinkan untuk mewarisi kelas tersebut. Untuk itu, kita bisa melakukannya dengan deklarasi khusus yang disebut dengan  Extensions .  Kotlin mendukung 2 (dua)  extension  yang dapat digunakan, yaitu  Extension Functions  dan  Extension Properties . Jika extension functions digunakan untuk menambahkan fungsi baru, extension properties tentunya digunakan untuk menambahkan sebuah properti baru. Extension Functions Untuk mendeklarasikan sebuah extension functions, kita perlu menentukan terlebih dahulu  receiver type , kemudian nama dari fungsi tersebut yang mana keduanya dipisahkan oleh titik ( . ). Contohnya, seperti berikut: fun Int.printInt() {     print(""value $this"") } Bisa kita perhatikan, kelas  Int  pada kode di atas digunakan sebagai  receiver type , sedangkan kata kunci  this  adalah  receiver type  yang bertindak sebagai objeknya. Nilai dari objek tersebut bisa digunakan di dalam  extension  yang sudah dibuat.  Untuk memanggil extension functions di atas, lakukan dengan cara seperti berikut: fun main() {     10.printInt() }  fun Int.printInt() {     print(""value $this"") }  /*    output : value 10 */ Kita juga bisa menetapkan jika extension functions tersebut dapat mengembalikan nilai, deklarasinya pun sama halnya seperti fungsi pada umumnya. Contohnya seperti berikut: fun main() {     println(10.plusThree()) }  fun Int.plusThree(): Int {     return this + 3 }  /*    output : 13 */ Extension Properties Selanjutnya adalah extension properties. Seperti yang disebutkan di awal, Kotlin juga mendukung  extension  untuk menambah sebuah properti baru pada sebuah kelas tanpa harus menyentuh kode di dalam kelas tersebut. Deklarasinya pun sama seperti extension functions. Kita terlebih dahulu menentukan  receiver type  kemudian nama dari properti tersebut. Contoh seperti berikut: val Int.slice: Int     get() = this / 2 Untuk memanggil  extension  di atas, lakukan dengan cara berikut: fun main() {     println(10.slice) }  val Int.slice: Int     get() = this / 2  /*    output : 5 */ Yang perlu diketahui,  extension  tidak benar-benar mengubah sebuah kelas dengan menambahkan sebuah fungsi atau properti baru. Ini karena  extension  memiliki hubungan langsung dengan kelas yang ingin diperluas fungsionalitasnya. Sehingga extension properties hanya bisa dideklarasikan dengan cara menyediakan  getter  atau  setter  secara eksplisit.";Extension di Kotlin memungkinkan penambahan fungsi atau properti baru pada kelas tanpa mewarisi atau memodifikasi kelas asli. Terdapat dua jenis: Extension Functions dan Extension Properties. Extension Functions ditambahkan dengan sintaks fun ReceiverType.functionName(), contoh fun Int.printInt(). Extension Properties menggunakan val ReceiverType.propertyName: Type, seperti val Int.slice: Int get() = this / 2. Kata kunci this merujuk pada objek penerima. Extension tidak mengubah kelas asli, hanya menyediakan fungsionalitas tambahan secara sintaksis.
Nullable Receiver Menariknya, kita bisa juga mendeklarasikan sebuah extension dengan  nullable receiver type . Alhasil, extension tersebut bisa dipanggil pada objek yang bahkan nilainya  null . val Int?.slice: Int     get() = if (this == null) 0 else this.div(2) If expression pada contoh di atas adalah untuk memeriksa apakah  receiver   object -nya bernilai  null . Jika tidak bernilai  null , maka  receiver object  tersebut akan secara otomatis di- casting  menjadi tipe  non-null , sehingga kita bisa menggunakan nilainya. Selain menggunakan if expression, kita juga bisa menggunakan elvis operator. Misalnya seperti berikut: val Int?.slice: Int     get() = this?.div(2) ?: 0 Untuk memanggilnya pun sama seperti extension properties sebelumnya. fun main() {     val value: Int? = null      println(value.slice) }  val Int?.slice: Int     get() = this?.div(2) ?: 0  /*    output : 0 */ Lalu kapan kita membutuhkannya? Tentunya jika kita mempunyai sebuah objek yang bernilai  null . Saat kita tidak menetapkannya dengan  nullable receiver type , maka kita perlu memeriksa apakah objek tersebut bernilai  null  atau tidak? Bisa juga dengan menggunakan operator safe call setiap kali  extension  tersebut dipanggil. Contohnya seperti berikut: fun main() {     val value: Int? = null     val value1: Int? = null      println(value?.slice)     println(value1?.slice) }  val Int.slice: Int     get() = this.div(2)  /*    output : null             null  */ Kita juga bisa menentukan nilai dari  receiver object  jika bernilai  null . Sehingga kita tidak perlu lagi menggunakan operator safe call ketika ingin memanggil  extension  tersebut. fun main() {     val value: Int? = null     val value1: Int? = null      println(value.slice)     println(value1.slice) }  val Int?.slice: Int     get() = this?.div(2) ?: 0  /*    output : 0             0  */;Nullable Receiver di Kotlin memungkinkan deklarasi extension pada tipe nullable, sehingga extension dapat dipanggil bahkan pada objek null. Dengan menggunakan nullable receiver type, kita bisa menangani null secara lebih elegan melalui if expression atau elvis operator. Contohnya: val Int?.slice: Int get() = this?.div(2) ?: 0. Pendekatan ini memudahkan penanganan objek nullable tanpa harus secara eksplisit memeriksa null setiap kali extension dipanggil, menghemat baris kode dan meningkatkan keterbacaan.
"Lambda Lambda expression, biasa disebut dengan  anonymous function  atau  function literal  adalah fitur yang cukup populer sampai sekarang dalam dunia  functional programming . Bisa disebut sebagai  anonymous  karena lambda tidak memiliki sebuah nama seperti halnya sebuah fungsi pada umumnya. Karena merupakan sebuah fungsi, lambda juga dapat memiliki daftar  parameter ,  body  dan  return type . Istilah lambda sendiri berasal dari istilah akademis  lambda calculus  yang digunakan untuk menggambarkan proses komputasi. Sebelum mempelajarinya lebih dalam, ada baiknya jika kita tahu beberapa karakteristik dari lambda berikut: Dalam menggunakan lambda, kita tidak perlu mendeklarasi tipe spesifik untuk nilai kembaliannya. Tipe tersebut akan ditentukan oleh kompiler secara otomatis. Walaupun merupakan sebuah fungsi, lambda tidak membutuhkan kata kunci  fun  dan  visibility modifier  saat dideklarasikan, karena lambda bersifat  anonymous . Parameter yang akan ditetapkan berada di dalam kurung kurawal  {} .  Ketika ingin mengembalikan nilai, kata kunci return tidak diperlukan lagi karena kompiler akan secara otomatis mengembalikan nilai dari dalam  body . Lambda expression dapat digunakan sebagai argumen untuk sebuah  parameter  dan dapat disimpan ke dalam sebuah variabel. Dari beberapa karakteristik di atas, lambda sangat berguna karena dapat membuat penulisan kode menjadi lebih mudah dan sederhana. Salah satu contohnya adalah kita bisa menghindari  boilerplate code  dalam menggunakan  anonymous class  seperti berikut: val comparator = object :Runnable{     override fun run() {         // TODO:     } } Dengan lambda, kita bisa menyederhanakannya menjadi seperti di bawah ini: val comparator = Runnable {     // TODO: } Menggunakan Lambda Expression Setelah mengetahui apa itu lambda dan karakteristiknya, bagaimana cara mendeklarasikannya? Perhatikan contoh kode di bawah ini. val message = { println(""Hello From Lambda"") } Kode di atas adalah contoh deklarasi dari lambda, di mana fungsi lambda di atas ditandai dengan sepasang kurung kurawal. Di dalamnya terdapat fungsi untuk mencetak teks pada konsol. Ketika ingin menggunakannya, kita bisa memanggilnya seperti halnya kita memanggil sebuah fungsi pada umumnya. fun main() {     message() }  val message = { println(""Hello From Lambda"") }  /*    output : Hello From Lambda */ Jika kita ingin menambahkan sebuah parameter pada fungsi lambda, kita bisa menuliskannya seperti berikut: fun main() {     printMessage(""Hello From Lambda"") }  val printMessage = { message: String -> println(message) }  /*    output : Hello From Lambda */ Seperti yang disebutkan sebelumnya, parameter dari sebuah lambda berada di dalam kurung kurawal. Untuk membedakannya dengan  body , daftar  parameter  yang ada dipisahkan dengan tanda  -> . Kemudian, bagaimana cara mendeklarasi lambda agar dapat mengembalikan nilai? Untuk itu kita bisa menuliskannya seperti di bawah ini:  fun main() {     val length = messageLength(""Hello From lambda"")     println(""Message length $length"") }  val messageLength = { message: String -> message.length }  /*    output : Message length 17 */ Bisa kita perhatikan, kita tidak membutuhkan tipe kembalian dan kata kunci  return  untuk mengembalikan sebuah nilai. Pada dasarnya, kompiler akan mengembalikan nilai berdasarkan  expression  atau  statement  di baris terakhir di dalam  body .";"Lambda expression adalah fungsi anonim tanpa nama, dideklarasikan dengan kurung kurawal {}. Karakteristiknya: tidak memerlukan kata kunci fun, tipe kembalian otomatis, tidak membutuhkan return eksplisit. Contoh sederhana: val message = { println(""Hello"") }. Parameter ditulis sebelum tanda panah (->) dan body berada dalam kurung kurawal. Lambda sangat fleksibel: bisa menerima parameter, mengembalikan nilai, dan digunakan sebagai argumen fungsi, memungkinkan gaya pemrograman fungsional yang lebih ringkas."
"Higher-Order Function Dalam mendeklarasi lambda, khususnya jika ingin ditetapkan agar dapat mengembalikan nilai, terkadang kompiler tidak dapat menentukan tipenya. Alhasil, kita perlu menuliskannya secara eksplisit. Terdapat beberapa tipe deklarasi yang dapat kita gunakan untuk mendeklarasi lambda, antara lain:  var sum: (Int) -> Int = { value -> value + value } Tipe deklarasi pada kode di atas adalah contoh ketika kita ingin membuat lambda yang memiliki 1 (satu) parameter dengan tipe kembalian Int. Untuk tipe deklarasi lainnya akan kita bahas pada s ub-modul  berikutnya. Dengan ditetapkannya tipe deklarasi pada fungsi tersebut, memungkinkan kita untuk bisa menggunakannya sebagai argumen untuk fungsi lainnya. Contohnya seperti berikut: fun main() {     printResult(10 ,sum) }  fun printResult(value: Int, sum: (Int) -> Int) {     val result = sum(value)     println(result) }  var sum: (Int) -> Int = { value -> value + value }  /*    output : 20 */ Atau kita bisa melampirkannya secara langsung ketika fungsi  printResult()  di atas dipanggil seperti berikut: fun main() {     printResult(10){ value ->         value + value     } }  fun printResult(value: Int, sum: (Int) -> Int) {     val result = sum(value)     println(result) }  /*    output : 20 */ Konsep ini dinamakan sebagai  Higher-Order Function , yaitu sebuah fungsi yang menggunakan fungsi lainnya sebagai parameter, menjadikan tipe kembalian, ataupun keduanya. Yang perlu diperhatikan adalah, jika argumen terakhir dari fungsi merupakan sebuah lambda expression, maka lambda expression tersebut ditempatkan di luar  parenthesis  seperti pada contoh kode di atas. Inline Function Seperti yang Anda lihat, Higher-Order Function sangat bermanfaat untuk mengembangkan aplikasi. Namun, perlu diketahui bahwa penggunaan Higher-Order Function memiliki dampak terhadap performa program. Hal ini karena ketika Higher-Order Function dijalankan, di balik layar terjadi proses pembuatan instance yang banyak jika dipangil berulang-ulang. Memang jika kodenya masih sedikit, hal ini tidaklah begitu terasa. Namun, jika ada sudah mulai banyak, baru akan terasa dampaknya. Sebagai contoh perhatikan kode berikut. fun main() {     printResult(10){ value ->         value + value     }     printResult(20){ value ->         value + value     } }  fun printResult(value: Int, sum: (Int) -> Int) {     val result = sum(value)     println(result) } Perhatikan bahwa printResult yang mengandung Higher-Order Function dipanggil dua kali. Kemudian perhatikan kode yang dihasilkan oleh compiler dengan cara memilih  Tools > Kotlin > Show Kotlin Bytecode . Kemudian tekan tombol  Decompile  pada panel Kotlin Bytecode. Alhasil, lihatlah kode yang sudah di-decompile tersebut. public static final void main() {    printResult(10, (Function1)null.INSTANCE);    printResult(20, (Function1)null.INSTANCE); } ... Perhatikan bahwa instance dari printResult dibuat sesuai dengan berapa kali fungsi tersebut dipanggil. Ini baru dua, bayangkan jika ada ratusan pemanggil fungsi. Tentu instance yang dibuat akan sangat banyak. Nah, untuk mengatasi hal tersebut, muncullah keyword inline seperti berikut.  inline  fun printResult(value: Int, sum: (Int) -> Int) {     val result = sum(value)     println(result) } Inline adalah fitur dalam bahasa Kotlin yang memungkinkan Anda untuk menyertakan seluruh kode dari suatu fungsi atau lambda (expression function) pada saat kompilasi, sehingga mempercepat waktu eksekusi program. Apabila kita periksa pada kode yang sudah di-decompile, hasilnya seperti berikut. public static final void main() {    int value$iv = 10;    int $i$f$printResult = false;    int var3 = false;    int result$iv = value$iv + value$iv;    System.out.println(result$iv);    value$iv = 20;    $i$f$printResult = false;    var3 = false;    result$iv = value$iv + value$iv;    System.out.println(result$iv); } ... public static final void printResult(int value, @NotNull Function1 sum) {    int $i$f$printResult = 0;    Intrinsics.checkNotNullParameter(sum, ""sum"");    int result = ((Number)sum.invoke(value)).intValue();    System.out.println(result); } Anda tidak perlu paham kode yang dihasilkan, tetapi cukup perhatikan bahwa sekarang ada fungsi printResult yang juga dibuat di kode tersebut, sehingga tidak ada pembuatan instance yang banyak lagi.  Tanpa inline, bayangkan Anda seperti menyalin tulisan ke dalam kertas lain secara manual. Jika membutuhkan banyak salinan, tentu Anda akan memakan waktu dan membutuhkan usaha lebih. Nah, penggunaan inline ibarat penggunaan fotocopy, Anda cukup membuat mesin fotocopy sekali dan mesin tersebut yang akan menyalin tulisan dengan mudah dan tentunya cepat.  Namun, perlu diingat bahwa mesin tersebut juga membutuhkan ruang lebih banyak dan memakan lebih banyak energi. Penggunakan inline juga dapat menyebabkan file binary program menjadi lebih besar dan memperlambat waktu kompilasi. Oleh karena itu, perlu dipikirkan dengan baik sebelum menggunakan inline.";Higher-Order Function adalah fungsi yang dapat menerima fungsi lain sebagai parameter atau mengembalikan fungsi. Ditandai dengan tipe deklarasi seperti (Int) -> Int. Inline Function mengoptimalkan performa dengan menyalin langsung kode fungsi saat kompilasi, mengurangi overhead pembuatan instance. Contoh: inline fun printResult(value: Int, sum: (Int) -> Int). Namun, penggunaan inline perlu dipertimbangkan karena dapat meningkatkan ukuran binary dan waktu kompilasi.
